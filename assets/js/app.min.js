/*!
  * Bootstrap v5.0.0-beta1 (https://getbootstrap.com/)
  * Copyright 2011-2020 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t() }(this, (function () { "use strict"; function e(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } function t(t, i, n) { return i && e(t.prototype, i), n && e(t, n), t } function i() { return (i = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t]; for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]) } return e }).apply(this, arguments) } function n(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t } var s, r, o = function (e) { do { e += Math.floor(1e6 * Math.random()) } while (document.getElementById(e)); return e }, a = function (e) { var t = e.getAttribute("data-bs-target"); if (!t || "#" === t) { var i = e.getAttribute("href"); t = i && "#" !== i ? i.trim() : null } return t }, l = function (e) { var t = a(e); return t && document.querySelector(t) ? t : null }, c = function (e) { var t = a(e); return t ? document.querySelector(t) : null }, d = function (e) { if (!e) return 0; var t = window.getComputedStyle(e), i = t.transitionDuration, n = t.transitionDelay, s = Number.parseFloat(i), r = Number.parseFloat(n); return s || r ? (i = i.split(",")[0], n = n.split(",")[0], 1e3 * (Number.parseFloat(i) + Number.parseFloat(n))) : 0 }, u = function (e) { e.dispatchEvent(new Event("transitionend")) }, p = function (e) { return (e[0] || e).nodeType }, f = function (e, t) { var i = !1, n = t + 5; e.addEventListener("transitionend", (function t() { i = !0, e.removeEventListener("transitionend", t) })), setTimeout((function () { i || u(e) }), n) }, h = function (e, t, i) { Object.keys(i).forEach((function (n) { var s, r = i[n], o = t[n], a = o && p(o) ? "element" : null == (s = o) ? "" + s : {}.toString.call(s).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(r).test(a)) throw new Error(e.toUpperCase() + ': Option "' + n + '" provided type "' + a + '" but expected type "' + r + '".') })) }, m = function (e) { if (!e) return !1; if (e.style && e.parentNode && e.parentNode.style) { var t = getComputedStyle(e), i = getComputedStyle(e.parentNode); return "none" !== t.display && "none" !== i.display && "hidden" !== t.visibility } return !1 }, g = function () { return function () { } }, v = function (e) { return e.offsetHeight }, y = function () { var e = window.jQuery; return e && !document.body.hasAttribute("data-bs-no-jquery") ? e : null }, b = function (e) { "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", e) : e() }, w = "rtl" === document.documentElement.dir, E = (s = {}, r = 1, { set: function (e, t, i) { void 0 === e.bsKey && (e.bsKey = { key: t, id: r }, r++), s[e.bsKey.id] = i }, get: function (e, t) { if (!e || void 0 === e.bsKey) return null; var i = e.bsKey; return i.key === t ? s[i.id] : null }, delete: function (e, t) { if (void 0 !== e.bsKey) { var i = e.bsKey; i.key === t && (delete s[i.id], delete e.bsKey) } } }), _ = function (e, t, i) { E.set(e, t, i) }, x = function (e, t) { return E.get(e, t) }, S = /[^.]*(?=\..*)\.|.*/, T = /\..*/, C = /::\d+$/, M = {}, L = 1, I = { mouseenter: "mouseover", mouseleave: "mouseout" }, A = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function P(e, t) { return t && t + "::" + L++ || e.uidEvent || L++ } function O(e) { var t = P(e); return e.uidEvent = t, M[t] = M[t] || {}, M[t] } function k(e, t, i) { void 0 === i && (i = null); for (var n = Object.keys(e), s = 0, r = n.length; s < r; s++) { var o = e[n[s]]; if (o.originalHandler === t && o.delegationSelector === i) return o } return null } function z(e, t, i) { var n = "string" == typeof t, s = n ? i : t, r = e.replace(T, ""), o = I[r]; return o && (r = o), A.has(r) || (r = e), [n, s, r] } function D(e, t, i, n, s) { if ("string" == typeof t && e) { i || (i = n, n = null); var r = z(t, i, n), o = r[0], a = r[1], l = r[2], c = O(e), d = c[l] || (c[l] = {}), u = k(d, a, o ? i : null); if (u) u.oneOff = u.oneOff && s; else { var p = P(a, t.replace(S, "")), f = o ? function (e, t, i) { return function n(s) { for (var r = e.querySelectorAll(t), o = s.target; o && o !== this; o = o.parentNode)for (var a = r.length; a--;)if (r[a] === o) return s.delegateTarget = o, n.oneOff && $.off(e, s.type, i), i.apply(o, [s]); return null } }(e, i, n) : function (e, t) { return function i(n) { return n.delegateTarget = e, i.oneOff && $.off(e, n.type, t), t.apply(e, [n]) } }(e, i); f.delegationSelector = o ? i : null, f.originalHandler = a, f.oneOff = s, f.uidEvent = p, d[p] = f, e.addEventListener(l, f, o) } } } function j(e, t, i, n, s) { var r = k(t[i], n, s); r && (e.removeEventListener(i, r, Boolean(s)), delete t[i][r.uidEvent]) } var $ = { on: function (e, t, i, n) { D(e, t, i, n, !1) }, one: function (e, t, i, n) { D(e, t, i, n, !0) }, off: function (e, t, i, n) { if ("string" == typeof t && e) { var s = z(t, i, n), r = s[0], o = s[1], a = s[2], l = a !== t, c = O(e), d = t.startsWith("."); if (void 0 === o) { d && Object.keys(c).forEach((function (i) { !function (e, t, i, n) { var s = t[i] || {}; Object.keys(s).forEach((function (r) { if (r.includes(n)) { var o = s[r]; j(e, t, i, o.originalHandler, o.delegationSelector) } })) }(e, c, i, t.slice(1)) })); var u = c[a] || {}; Object.keys(u).forEach((function (i) { var n = i.replace(C, ""); if (!l || t.includes(n)) { var s = u[i]; j(e, c, a, s.originalHandler, s.delegationSelector) } })) } else { if (!c || !c[a]) return; j(e, c, a, o, r ? i : null) } } }, trigger: function (e, t, i) { if ("string" != typeof t || !e) return null; var n, s = y(), r = t.replace(T, ""), o = t !== r, a = A.has(r), l = !0, c = !0, d = !1, u = null; return o && s && (n = s.Event(t, i), s(e).trigger(n), l = !n.isPropagationStopped(), c = !n.isImmediatePropagationStopped(), d = n.isDefaultPrevented()), a ? (u = document.createEvent("HTMLEvents")).initEvent(r, l, !0) : u = new CustomEvent(t, { bubbles: l, cancelable: !0 }), void 0 !== i && Object.keys(i).forEach((function (e) { Object.defineProperty(u, e, { get: function () { return i[e] } }) })), d && u.preventDefault(), c && e.dispatchEvent(u), u.defaultPrevented && void 0 !== n && n.preventDefault(), u } }, N = function () { function e(e) { e && (this._element = e, _(e, this.constructor.DATA_KEY, this)) } return e.prototype.dispose = function () { (function (e, t) { E.delete(e, t) })(this._element, this.constructor.DATA_KEY), this._element = null }, e.getInstance = function (e) { return x(e, this.DATA_KEY) }, t(e, null, [{ key: "VERSION", get: function () { return "5.0.0-beta1" } }]), e }(), H = "alert", B = function (e) { function i() { return e.apply(this, arguments) || this } n(i, e); var s = i.prototype; return s.close = function (e) { var t = e ? this._getRootElement(e) : this._element, i = this._triggerCloseEvent(t); null === i || i.defaultPrevented || this._removeElement(t) }, s._getRootElement = function (e) { return c(e) || e.closest(".alert") }, s._triggerCloseEvent = function (e) { return $.trigger(e, "close.bs.alert") }, s._removeElement = function (e) { var t = this; if (e.classList.remove("show"), e.classList.contains("fade")) { var i = d(e); $.one(e, "transitionend", (function () { return t._destroyElement(e) })), f(e, i) } else this._destroyElement(e) }, s._destroyElement = function (e) { e.parentNode && e.parentNode.removeChild(e), $.trigger(e, "closed.bs.alert") }, i.jQueryInterface = function (e) { return this.each((function () { var t = x(this, "bs.alert"); t || (t = new i(this)), "close" === e && t[e](this) })) }, i.handleDismiss = function (e) { return function (t) { t && t.preventDefault(), e.close(this) } }, t(i, null, [{ key: "DATA_KEY", get: function () { return "bs.alert" } }]), i }(N); $.on(document, "click.bs.alert.data-api", '[data-bs-dismiss="alert"]', B.handleDismiss(new B)), b((function () { var e = y(); if (e) { var t = e.fn[H]; e.fn[H] = B.jQueryInterface, e.fn[H].Constructor = B, e.fn[H].noConflict = function () { return e.fn[H] = t, B.jQueryInterface } } })); var W = function (e) { function i() { return e.apply(this, arguments) || this } return n(i, e), i.prototype.toggle = function () { this._element.setAttribute("aria-pressed", this._element.classList.toggle("active")) }, i.jQueryInterface = function (e) { return this.each((function () { var t = x(this, "bs.button"); t || (t = new i(this)), "toggle" === e && t[e]() })) }, t(i, null, [{ key: "DATA_KEY", get: function () { return "bs.button" } }]), i }(N); function R(e) { return "true" === e || "false" !== e && (e === Number(e).toString() ? Number(e) : "" === e || "null" === e ? null : e) } function F(e) { return e.replace(/[A-Z]/g, (function (e) { return "-" + e.toLowerCase() })) } $.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', (function (e) { e.preventDefault(); var t = e.target.closest('[data-bs-toggle="button"]'), i = x(t, "bs.button"); i || (i = new W(t)), i.toggle() })), b((function () { var e = y(); if (e) { var t = e.fn.button; e.fn.button = W.jQueryInterface, e.fn.button.Constructor = W, e.fn.button.noConflict = function () { return e.fn.button = t, W.jQueryInterface } } })); var q = { setDataAttribute: function (e, t, i) { e.setAttribute("data-bs-" + F(t), i) }, removeDataAttribute: function (e, t) { e.removeAttribute("data-bs-" + F(t)) }, getDataAttributes: function (e) { if (!e) return {}; var t = {}; return Object.keys(e.dataset).filter((function (e) { return e.startsWith("bs") })).forEach((function (i) { var n = i.replace(/^bs/, ""); n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = R(e.dataset[i]) })), t }, getDataAttribute: function (e, t) { return R(e.getAttribute("data-bs-" + F(t))) }, offset: function (e) { var t = e.getBoundingClientRect(); return { top: t.top + document.body.scrollTop, left: t.left + document.body.scrollLeft } }, position: function (e) { return { top: e.offsetTop, left: e.offsetLeft } } }, Y = { matches: function (e, t) { return e.matches(t) }, find: function (e, t) { var i; return void 0 === t && (t = document.documentElement), (i = []).concat.apply(i, Element.prototype.querySelectorAll.call(t, e)) }, findOne: function (e, t) { return void 0 === t && (t = document.documentElement), Element.prototype.querySelector.call(t, e) }, children: function (e, t) { var i; return (i = []).concat.apply(i, e.children).filter((function (e) { return e.matches(t) })) }, parents: function (e, t) { for (var i = [], n = e.parentNode; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType;)this.matches(n, t) && i.push(n), n = n.parentNode; return i }, prev: function (e, t) { for (var i = e.previousElementSibling; i;) { if (i.matches(t)) return [i]; i = i.previousElementSibling } return [] }, next: function (e, t) { for (var i = e.nextElementSibling; i;) { if (this.matches(i, t)) return [i]; i = i.nextElementSibling } return [] } }, G = "carousel", X = { interval: 5e3, keyboard: !0, slide: !1, pause: "hover", wrap: !0, touch: !0 }, V = { interval: "(number|boolean)", keyboard: "boolean", slide: "(boolean|string)", pause: "(string|boolean)", wrap: "boolean", touch: "boolean" }, U = { TOUCH: "touch", PEN: "pen" }, Q = function (e) { function s(t, i) { var n; return (n = e.call(this, t) || this)._items = null, n._interval = null, n._activeElement = null, n._isPaused = !1, n._isSliding = !1, n.touchTimeout = null, n.touchStartX = 0, n.touchDeltaX = 0, n._config = n._getConfig(i), n._indicatorsElement = Y.findOne(".carousel-indicators", n._element), n._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, n._pointerEvent = Boolean(window.PointerEvent), n._addEventListeners(), n } n(s, e); var r = s.prototype; return r.next = function () { this._isSliding || this._slide("next") }, r.nextWhenVisible = function () { !document.hidden && m(this._element) && this.next() }, r.prev = function () { this._isSliding || this._slide("prev") }, r.pause = function (e) { e || (this._isPaused = !0), Y.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (u(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null }, r.cycle = function (e) { e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)) }, r.to = function (e) { var t = this; this._activeElement = Y.findOne(".active.carousel-item", this._element); var i = this._getItemIndex(this._activeElement); if (!(e > this._items.length - 1 || e < 0)) if (this._isSliding) $.one(this._element, "slid.bs.carousel", (function () { return t.to(e) })); else { if (i === e) return this.pause(), void this.cycle(); var n = e > i ? "next" : "prev"; this._slide(n, this._items[e]) } }, r.dispose = function () { e.prototype.dispose.call(this), $.off(this._element, ".bs.carousel"), this._items = null, this._config = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null }, r._getConfig = function (e) { return e = i({}, X, e), h(G, e, V), e }, r._handleSwipe = function () { var e = Math.abs(this.touchDeltaX); if (!(e <= 40)) { var t = e / this.touchDeltaX; this.touchDeltaX = 0, t > 0 && this.prev(), t < 0 && this.next() } }, r._addEventListeners = function () { var e = this; this._config.keyboard && $.on(this._element, "keydown.bs.carousel", (function (t) { return e._keydown(t) })), "hover" === this._config.pause && ($.on(this._element, "mouseenter.bs.carousel", (function (t) { return e.pause(t) })), $.on(this._element, "mouseleave.bs.carousel", (function (t) { return e.cycle(t) }))), this._config.touch && this._touchSupported && this._addTouchEventListeners() }, r._addTouchEventListeners = function () { var e = this, t = function (t) { e._pointerEvent && U[t.pointerType.toUpperCase()] ? e.touchStartX = t.clientX : e._pointerEvent || (e.touchStartX = t.touches[0].clientX) }, i = function (t) { e._pointerEvent && U[t.pointerType.toUpperCase()] && (e.touchDeltaX = t.clientX - e.touchStartX), e._handleSwipe(), "hover" === e._config.pause && (e.pause(), e.touchTimeout && clearTimeout(e.touchTimeout), e.touchTimeout = setTimeout((function (t) { return e.cycle(t) }), 500 + e._config.interval)) }; Y.find(".carousel-item img", this._element).forEach((function (e) { $.on(e, "dragstart.bs.carousel", (function (e) { return e.preventDefault() })) })), this._pointerEvent ? ($.on(this._element, "pointerdown.bs.carousel", (function (e) { return t(e) })), $.on(this._element, "pointerup.bs.carousel", (function (e) { return i(e) })), this._element.classList.add("pointer-event")) : ($.on(this._element, "touchstart.bs.carousel", (function (e) { return t(e) })), $.on(this._element, "touchmove.bs.carousel", (function (t) { return function (t) { t.touches && t.touches.length > 1 ? e.touchDeltaX = 0 : e.touchDeltaX = t.touches[0].clientX - e.touchStartX }(t) })), $.on(this._element, "touchend.bs.carousel", (function (e) { return i(e) }))) }, r._keydown = function (e) { if (!/input|textarea/i.test(e.target.tagName)) switch (e.key) { case "ArrowLeft": e.preventDefault(), this.prev(); break; case "ArrowRight": e.preventDefault(), this.next() } }, r._getItemIndex = function (e) { return this._items = e && e.parentNode ? Y.find(".carousel-item", e.parentNode) : [], this._items.indexOf(e) }, r._getItemByDirection = function (e, t) { var i = "next" === e, n = "prev" === e, s = this._getItemIndex(t), r = this._items.length - 1; if ((n && 0 === s || i && s === r) && !this._config.wrap) return t; var o = (s + ("prev" === e ? -1 : 1)) % this._items.length; return -1 === o ? this._items[this._items.length - 1] : this._items[o] }, r._triggerSlideEvent = function (e, t) { var i = this._getItemIndex(e), n = this._getItemIndex(Y.findOne(".active.carousel-item", this._element)); return $.trigger(this._element, "slide.bs.carousel", { relatedTarget: e, direction: t, from: n, to: i }) }, r._setActiveIndicatorElement = function (e) { if (this._indicatorsElement) { for (var t = Y.find(".active", this._indicatorsElement), i = 0; i < t.length; i++)t[i].classList.remove("active"); var n = this._indicatorsElement.children[this._getItemIndex(e)]; n && n.classList.add("active") } }, r._updateInterval = function () { var e = this._activeElement || Y.findOne(".active.carousel-item", this._element); if (e) { var t = Number.parseInt(e.getAttribute("data-bs-interval"), 10); t ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = t) : this._config.interval = this._config.defaultInterval || this._config.interval } }, r._slide = function (e, t) { var i, n, s, r = this, o = Y.findOne(".active.carousel-item", this._element), a = this._getItemIndex(o), l = t || o && this._getItemByDirection(e, o), c = this._getItemIndex(l), u = Boolean(this._interval); if ("next" === e ? (i = "carousel-item-start", n = "carousel-item-next", s = "left") : (i = "carousel-item-end", n = "carousel-item-prev", s = "right"), l && l.classList.contains("active")) this._isSliding = !1; else if (!this._triggerSlideEvent(l, s).defaultPrevented && o && l) { if (this._isSliding = !0, u && this.pause(), this._setActiveIndicatorElement(l), this._activeElement = l, this._element.classList.contains("slide")) { l.classList.add(n), v(l), o.classList.add(i), l.classList.add(i); var p = d(o); $.one(o, "transitionend", (function () { l.classList.remove(i, n), l.classList.add("active"), o.classList.remove("active", n, i), r._isSliding = !1, setTimeout((function () { $.trigger(r._element, "slid.bs.carousel", { relatedTarget: l, direction: s, from: a, to: c }) }), 0) })), f(o, p) } else o.classList.remove("active"), l.classList.add("active"), this._isSliding = !1, $.trigger(this._element, "slid.bs.carousel", { relatedTarget: l, direction: s, from: a, to: c }); u && this.cycle() } }, s.carouselInterface = function (e, t) { var n = x(e, "bs.carousel"), r = i({}, X, q.getDataAttributes(e)); "object" == typeof t && (r = i({}, r, t)); var o = "string" == typeof t ? t : r.slide; if (n || (n = new s(e, r)), "number" == typeof t) n.to(t); else if ("string" == typeof o) { if (void 0 === n[o]) throw new TypeError('No method named "' + o + '"'); n[o]() } else r.interval && r.ride && (n.pause(), n.cycle()) }, s.jQueryInterface = function (e) { return this.each((function () { s.carouselInterface(this, e) })) }, s.dataApiClickHandler = function (e) { var t = c(this); if (t && t.classList.contains("carousel")) { var n = i({}, q.getDataAttributes(t), q.getDataAttributes(this)), r = this.getAttribute("data-bs-slide-to"); r && (n.interval = !1), s.carouselInterface(t, n), r && x(t, "bs.carousel").to(r), e.preventDefault() } }, t(s, null, [{ key: "Default", get: function () { return X } }, { key: "DATA_KEY", get: function () { return "bs.carousel" } }]), s }(N); $.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Q.dataApiClickHandler), $.on(window, "load.bs.carousel.data-api", (function () { for (var e = Y.find('[data-bs-ride="carousel"]'), t = 0, i = e.length; t < i; t++)Q.carouselInterface(e[t], x(e[t], "bs.carousel")) })), b((function () { var e = y(); if (e) { var t = e.fn[G]; e.fn[G] = Q.jQueryInterface, e.fn[G].Constructor = Q, e.fn[G].noConflict = function () { return e.fn[G] = t, Q.jQueryInterface } } })); var K = "collapse", Z = { toggle: !0, parent: "" }, J = { toggle: "boolean", parent: "(string|element)" }, ee = function (e) { function s(t, i) { var n; (n = e.call(this, t) || this)._isTransitioning = !1, n._config = n._getConfig(i), n._triggerArray = Y.find('[data-bs-toggle="collapse"][href="#' + t.id + '"],[data-bs-toggle="collapse"][data-bs-target="#' + t.id + '"]'); for (var s = Y.find('[data-bs-toggle="collapse"]'), r = 0, o = s.length; r < o; r++) { var a = s[r], c = l(a), d = Y.find(c).filter((function (e) { return e === t })); null !== c && d.length && (n._selector = c, n._triggerArray.push(a)) } return n._parent = n._config.parent ? n._getParent() : null, n._config.parent || n._addAriaAndCollapsedClass(n._element, n._triggerArray), n._config.toggle && n.toggle(), n } n(s, e); var r = s.prototype; return r.toggle = function () { this._element.classList.contains("show") ? this.hide() : this.show() }, r.show = function () { var e = this; if (!this._isTransitioning && !this._element.classList.contains("show")) { var t, i; this._parent && 0 === (t = Y.find(".show, .collapsing", this._parent).filter((function (t) { return "string" == typeof e._config.parent ? t.getAttribute("data-bs-parent") === e._config.parent : t.classList.contains("collapse") }))).length && (t = null); var n = Y.findOne(this._selector); if (t) { var r = t.find((function (e) { return n !== e })); if ((i = r ? x(r, "bs.collapse") : null) && i._isTransitioning) return } if (!$.trigger(this._element, "show.bs.collapse").defaultPrevented) { t && t.forEach((function (e) { n !== e && s.collapseInterface(e, "hide"), i || _(e, "bs.collapse", null) })); var o = this._getDimension(); this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[o] = 0, this._triggerArray.length && this._triggerArray.forEach((function (e) { e.classList.remove("collapsed"), e.setAttribute("aria-expanded", !0) })), this.setTransitioning(!0); var a = "scroll" + (o[0].toUpperCase() + o.slice(1)), l = d(this._element); $.one(this._element, "transitionend", (function () { e._element.classList.remove("collapsing"), e._element.classList.add("collapse", "show"), e._element.style[o] = "", e.setTransitioning(!1), $.trigger(e._element, "shown.bs.collapse") })), f(this._element, l), this._element.style[o] = this._element[a] + "px" } } }, r.hide = function () { var e = this; if (!this._isTransitioning && this._element.classList.contains("show") && !$.trigger(this._element, "hide.bs.collapse").defaultPrevented) { var t = this._getDimension(); this._element.style[t] = this._element.getBoundingClientRect()[t] + "px", v(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show"); var i = this._triggerArray.length; if (i > 0) for (var n = 0; n < i; n++) { var s = this._triggerArray[n], r = c(s); r && !r.classList.contains("show") && (s.classList.add("collapsed"), s.setAttribute("aria-expanded", !1)) } this.setTransitioning(!0), this._element.style[t] = ""; var o = d(this._element); $.one(this._element, "transitionend", (function () { e.setTransitioning(!1), e._element.classList.remove("collapsing"), e._element.classList.add("collapse"), $.trigger(e._element, "hidden.bs.collapse") })), f(this._element, o) } }, r.setTransitioning = function (e) { this._isTransitioning = e }, r.dispose = function () { e.prototype.dispose.call(this), this._config = null, this._parent = null, this._triggerArray = null, this._isTransitioning = null }, r._getConfig = function (e) { return (e = i({}, Z, e)).toggle = Boolean(e.toggle), h(K, e, J), e }, r._getDimension = function () { return this._element.classList.contains("width") ? "width" : "height" }, r._getParent = function () { var e = this, t = this._config.parent; p(t) ? void 0 === t.jquery && void 0 === t[0] || (t = t[0]) : t = Y.findOne(t); var i = '[data-bs-toggle="collapse"][data-bs-parent="' + t + '"]'; return Y.find(i, t).forEach((function (t) { var i = c(t); e._addAriaAndCollapsedClass(i, [t]) })), t }, r._addAriaAndCollapsedClass = function (e, t) { if (e && t.length) { var i = e.classList.contains("show"); t.forEach((function (e) { i ? e.classList.remove("collapsed") : e.classList.add("collapsed"), e.setAttribute("aria-expanded", i) })) } }, s.collapseInterface = function (e, t) { var n = x(e, "bs.collapse"), r = i({}, Z, q.getDataAttributes(e), "object" == typeof t && t ? t : {}); if (!n && r.toggle && "string" == typeof t && /show|hide/.test(t) && (r.toggle = !1), n || (n = new s(e, r)), "string" == typeof t) { if (void 0 === n[t]) throw new TypeError('No method named "' + t + '"'); n[t]() } }, s.jQueryInterface = function (e) { return this.each((function () { s.collapseInterface(this, e) })) }, t(s, null, [{ key: "Default", get: function () { return Z } }, { key: "DATA_KEY", get: function () { return "bs.collapse" } }]), s }(N); $.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', (function (e) { "A" === e.target.tagName && e.preventDefault(); var t = q.getDataAttributes(this), i = l(this); Y.find(i).forEach((function (e) { var i, n = x(e, "bs.collapse"); n ? (null === n._parent && "string" == typeof t.parent && (n._config.parent = t.parent, n._parent = n._getParent()), i = "toggle") : i = t, ee.collapseInterface(e, i) })) })), b((function () { var e = y(); if (e) { var t = e.fn[K]; e.fn[K] = ee.jQueryInterface, e.fn[K].Constructor = ee, e.fn[K].noConflict = function () { return e.fn[K] = t, ee.jQueryInterface } } })); var te = "top", ie = "bottom", ne = "right", se = "left", re = [te, ie, ne, se], oe = re.reduce((function (e, t) { return e.concat([t + "-start", t + "-end"]) }), []), ae = [].concat(re, ["auto"]).reduce((function (e, t) { return e.concat([t, t + "-start", t + "-end"]) }), []), le = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; function ce(e) { return e ? (e.nodeName || "").toLowerCase() : null } function de(e) { if ("[object Window]" !== e.toString()) { var t = e.ownerDocument; return t && t.defaultView || window } return e } function ue(e) { return e instanceof de(e).Element || e instanceof Element } function pe(e) { return e instanceof de(e).HTMLElement || e instanceof HTMLElement } var fe = { name: "applyStyles", enabled: !0, phase: "write", fn: function (e) { var t = e.state; Object.keys(t.elements).forEach((function (e) { var i = t.styles[e] || {}, n = t.attributes[e] || {}, s = t.elements[e]; pe(s) && ce(s) && (Object.assign(s.style, i), Object.keys(n).forEach((function (e) { var t = n[e]; !1 === t ? s.removeAttribute(e) : s.setAttribute(e, !0 === t ? "" : t) }))) })) }, effect: function (e) { var t = e.state, i = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, i.popper), t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow), function () { Object.keys(t.elements).forEach((function (e) { var n = t.elements[e], s = t.attributes[e] || {}, r = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : i[e]).reduce((function (e, t) { return e[t] = "", e }), {}); pe(n) && ce(n) && (Object.assign(n.style, r), Object.keys(s).forEach((function (e) { n.removeAttribute(e) }))) })) } }, requires: ["computeStyles"] }; function he(e) { return e.split("-")[0] } function me(e) { return { x: e.offsetLeft, y: e.offsetTop, width: e.offsetWidth, height: e.offsetHeight } } function ge(e, t) { var i, n = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (n && ((i = n) instanceof de(i).ShadowRoot || i instanceof ShadowRoot)) { var s = t; do { if (s && e.isSameNode(s)) return !0; s = s.parentNode || s.host } while (s) } return !1 } function ve(e) { return de(e).getComputedStyle(e) } function ye(e) { return ["table", "td", "th"].indexOf(ce(e)) >= 0 } function be(e) { return ((ue(e) ? e.ownerDocument : e.document) || window.document).documentElement } function we(e) { return "html" === ce(e) ? e : e.assignedSlot || e.parentNode || e.host || be(e) } function Ee(e) { if (!pe(e) || "fixed" === ve(e).position) return null; var t = e.offsetParent; if (t) { var i = be(t); if ("body" === ce(t) && "static" === ve(t).position && "static" !== ve(i).position) return i } return t } function _e(e) { for (var t = de(e), i = Ee(e); i && ye(i) && "static" === ve(i).position;)i = Ee(i); return i && "body" === ce(i) && "static" === ve(i).position ? t : i || function (e) { for (var t = we(e); pe(t) && ["html", "body"].indexOf(ce(t)) < 0;) { var i = ve(t); if ("none" !== i.transform || "none" !== i.perspective || i.willChange && "auto" !== i.willChange) return t; t = t.parentNode } return null }(e) || t } function xe(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function Se(e, t, i) { return Math.max(e, Math.min(t, i)) } function Te(e) { return Object.assign(Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }), e) } function Ce(e, t) { return t.reduce((function (t, i) { return t[i] = e, t }), {}) } var Me = { name: "arrow", enabled: !0, phase: "main", fn: function (e) { var t, i = e.state, n = e.name, s = i.elements.arrow, r = i.modifiersData.popperOffsets, o = he(i.placement), a = xe(o), l = [se, ne].indexOf(o) >= 0 ? "height" : "width"; if (s && r) { var c = i.modifiersData[n + "#persistent"].padding, d = me(s), u = "y" === a ? te : se, p = "y" === a ? ie : ne, f = i.rects.reference[l] + i.rects.reference[a] - r[a] - i.rects.popper[l], h = r[a] - i.rects.reference[a], m = _e(s), g = m ? "y" === a ? m.clientHeight || 0 : m.clientWidth || 0 : 0, v = f / 2 - h / 2, y = c[u], b = g - d[l] - c[p], w = g / 2 - d[l] / 2 + v, E = Se(y, w, b), _ = a; i.modifiersData[n] = ((t = {})[_] = E, t.centerOffset = E - w, t) } }, effect: function (e) { var t = e.state, i = e.options, n = e.name, s = i.element, r = void 0 === s ? "[data-popper-arrow]" : s, o = i.padding, a = void 0 === o ? 0 : o; null != r && ("string" != typeof r || (r = t.elements.popper.querySelector(r))) && ge(t.elements.popper, r) && (t.elements.arrow = r, t.modifiersData[n + "#persistent"] = { padding: Te("number" != typeof a ? a : Ce(a, re)) }) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }, Le = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function Ie(e) { var t, i = e.popper, n = e.popperRect, s = e.placement, r = e.offsets, o = e.position, a = e.gpuAcceleration, l = e.adaptive, c = function (e) { var t = e.x, i = e.y, n = window.devicePixelRatio || 1; return { x: Math.round(t * n) / n || 0, y: Math.round(i * n) / n || 0 } }(r), d = c.x, u = c.y, p = r.hasOwnProperty("x"), f = r.hasOwnProperty("y"), h = se, m = te, g = window; if (l) { var v = _e(i); v === de(i) && (v = be(i)), s === te && (m = ie, u -= v.clientHeight - n.height, u *= a ? 1 : -1), s === se && (h = ne, d -= v.clientWidth - n.width, d *= a ? 1 : -1) } var y, b = Object.assign({ position: o }, l && Le); return a ? Object.assign(Object.assign({}, b), {}, ((y = {})[m] = f ? "0" : "", y[h] = p ? "0" : "", y.transform = (g.devicePixelRatio || 1) < 2 ? "translate(" + d + "px, " + u + "px)" : "translate3d(" + d + "px, " + u + "px, 0)", y)) : Object.assign(Object.assign({}, b), {}, ((t = {})[m] = f ? u + "px" : "", t[h] = p ? d + "px" : "", t.transform = "", t)) } var Ae = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) { var t = e.state, i = e.options, n = i.gpuAcceleration, s = void 0 === n || n, r = i.adaptive, o = void 0 === r || r, a = { placement: he(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: s }; null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign(Object.assign({}, t.styles.popper), Ie(Object.assign(Object.assign({}, a), {}, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign(Object.assign({}, t.styles.arrow), Ie(Object.assign(Object.assign({}, a), {}, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1 })))), t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, { "data-popper-placement": t.placement }) }, data: {} }, Pe = { passive: !0 }, Oe = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (e) { var t = e.state, i = e.instance, n = e.options, s = n.scroll, r = void 0 === s || s, o = n.resize, a = void 0 === o || o, l = de(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper); return r && c.forEach((function (e) { e.addEventListener("scroll", i.update, Pe) })), a && l.addEventListener("resize", i.update, Pe), function () { r && c.forEach((function (e) { e.removeEventListener("scroll", i.update, Pe) })), a && l.removeEventListener("resize", i.update, Pe) } }, data: {} }, ke = { left: "right", right: "left", bottom: "top", top: "bottom" }; function ze(e) { return e.replace(/left|right|bottom|top/g, (function (e) { return ke[e] })) } var De = { start: "end", end: "start" }; function je(e) { return e.replace(/start|end/g, (function (e) { return De[e] })) } function $e(e) { var t = e.getBoundingClientRect(); return { width: t.width, height: t.height, top: t.top, right: t.right, bottom: t.bottom, left: t.left, x: t.left, y: t.top } } function Ne(e) { var t = de(e); return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function He(e) { return $e(be(e)).left + Ne(e).scrollLeft } function Be(e) { var t = ve(e), i = t.overflow, n = t.overflowX, s = t.overflowY; return /auto|scroll|overlay|hidden/.test(i + s + n) } function We(e, t) { void 0 === t && (t = []); var i = function e(t) { return ["html", "body", "#document"].indexOf(ce(t)) >= 0 ? t.ownerDocument.body : pe(t) && Be(t) ? t : e(we(t)) }(e), n = "body" === ce(i), s = de(i), r = n ? [s].concat(s.visualViewport || [], Be(i) ? i : []) : i, o = t.concat(r); return n ? o : o.concat(We(we(r))) } function Re(e) { return Object.assign(Object.assign({}, e), {}, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function Fe(e, t) { return "viewport" === t ? Re(function (e) { var t = de(e), i = be(e), n = t.visualViewport, s = i.clientWidth, r = i.clientHeight, o = 0, a = 0; return n && (s = n.width, r = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = n.offsetLeft, a = n.offsetTop)), { width: s, height: r, x: o + He(e), y: a } }(e)) : pe(t) ? function (e) { var t = $e(e); return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t }(t) : Re(function (e) { var t = be(e), i = Ne(e), n = e.ownerDocument.body, s = Math.max(t.scrollWidth, t.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = Math.max(t.scrollHeight, t.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), o = -i.scrollLeft + He(e), a = -i.scrollTop; return "rtl" === ve(n || t).direction && (o += Math.max(t.clientWidth, n ? n.clientWidth : 0) - s), { width: s, height: r, x: o, y: a } }(be(e))) } function qe(e) { return e.split("-")[1] } function Ye(e) { var t, i = e.reference, n = e.element, s = e.placement, r = s ? he(s) : null, o = s ? qe(s) : null, a = i.x + i.width / 2 - n.width / 2, l = i.y + i.height / 2 - n.height / 2; switch (r) { case te: t = { x: a, y: i.y - n.height }; break; case ie: t = { x: a, y: i.y + i.height }; break; case ne: t = { x: i.x + i.width, y: l }; break; case se: t = { x: i.x - n.width, y: l }; break; default: t = { x: i.x, y: i.y } }var c = r ? xe(r) : null; if (null != c) { var d = "y" === c ? "height" : "width"; switch (o) { case "start": t[c] = Math.floor(t[c]) - Math.floor(i[d] / 2 - n[d] / 2); break; case "end": t[c] = Math.floor(t[c]) + Math.ceil(i[d] / 2 - n[d] / 2) } } return t } function Ge(e, t) { void 0 === t && (t = {}); var i = t, n = i.placement, s = void 0 === n ? e.placement : n, r = i.boundary, o = void 0 === r ? "clippingParents" : r, a = i.rootBoundary, l = void 0 === a ? "viewport" : a, c = i.elementContext, d = void 0 === c ? "popper" : c, u = i.altBoundary, p = void 0 !== u && u, f = i.padding, h = void 0 === f ? 0 : f, m = Te("number" != typeof h ? h : Ce(h, re)), g = "popper" === d ? "reference" : "popper", v = e.elements.reference, y = e.rects.popper, b = e.elements[p ? g : d], w = function (e, t, i) { var n = "clippingParents" === t ? function (e) { var t = We(we(e)), i = ["absolute", "fixed"].indexOf(ve(e).position) >= 0 && pe(e) ? _e(e) : e; return ue(i) ? t.filter((function (e) { return ue(e) && ge(e, i) && "body" !== ce(e) })) : [] }(e) : [].concat(t), s = [].concat(n, [i]), r = s[0], o = s.reduce((function (t, i) { var n = Fe(e, i); return t.top = Math.max(n.top, t.top), t.right = Math.min(n.right, t.right), t.bottom = Math.min(n.bottom, t.bottom), t.left = Math.max(n.left, t.left), t }), Fe(e, r)); return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o }(ue(b) ? b : b.contextElement || be(e.elements.popper), o, l), E = $e(v), _ = Ye({ reference: E, element: y, strategy: "absolute", placement: s }), x = Re(Object.assign(Object.assign({}, y), _)), S = "popper" === d ? x : E, T = { top: w.top - S.top + m.top, bottom: S.bottom - w.bottom + m.bottom, left: w.left - S.left + m.left, right: S.right - w.right + m.right }, C = e.modifiersData.offset; if ("popper" === d && C) { var M = C[s]; Object.keys(T).forEach((function (e) { var t = [ne, ie].indexOf(e) >= 0 ? 1 : -1, i = [te, ie].indexOf(e) >= 0 ? "y" : "x"; T[e] += M[i] * t })) } return T } var Xe = { name: "flip", enabled: !0, phase: "main", fn: function (e) { var t = e.state, i = e.options, n = e.name; if (!t.modifiersData[n]._skip) { for (var s = i.mainAxis, r = void 0 === s || s, o = i.altAxis, a = void 0 === o || o, l = i.fallbackPlacements, c = i.padding, d = i.boundary, u = i.rootBoundary, p = i.altBoundary, f = i.flipVariations, h = void 0 === f || f, m = i.allowedAutoPlacements, g = t.options.placement, v = he(g), y = l || (v !== g && h ? function (e) { if ("auto" === he(e)) return []; var t = ze(e); return [je(e), t, je(t)] }(g) : [ze(g)]), b = [g].concat(y).reduce((function (e, i) { return e.concat("auto" === he(i) ? function (e, t) { void 0 === t && (t = {}); var i = t, n = i.placement, s = i.boundary, r = i.rootBoundary, o = i.padding, a = i.flipVariations, l = i.allowedAutoPlacements, c = void 0 === l ? ae : l, d = qe(n), u = d ? a ? oe : oe.filter((function (e) { return qe(e) === d })) : re, p = u.filter((function (e) { return c.indexOf(e) >= 0 })); 0 === p.length && (p = u); var f = p.reduce((function (t, i) { return t[i] = Ge(e, { placement: i, boundary: s, rootBoundary: r, padding: o })[he(i)], t }), {}); return Object.keys(f).sort((function (e, t) { return f[e] - f[t] })) }(t, { placement: i, boundary: d, rootBoundary: u, padding: c, flipVariations: h, allowedAutoPlacements: m }) : i) }), []), w = t.rects.reference, E = t.rects.popper, _ = new Map, x = !0, S = b[0], T = 0; T < b.length; T++) { var C = b[T], M = he(C), L = "start" === qe(C), I = [te, ie].indexOf(M) >= 0, A = I ? "width" : "height", P = Ge(t, { placement: C, boundary: d, rootBoundary: u, altBoundary: p, padding: c }), O = I ? L ? ne : se : L ? ie : te; w[A] > E[A] && (O = ze(O)); var k = ze(O), z = []; if (r && z.push(P[M] <= 0), a && z.push(P[O] <= 0, P[k] <= 0), z.every((function (e) { return e }))) { S = C, x = !1; break } _.set(C, z) } if (x) for (var D = function (e) { var t = b.find((function (t) { var i = _.get(t); if (i) return i.slice(0, e).every((function (e) { return e })) })); if (t) return S = t, "break" }, j = h ? 3 : 1; j > 0 && "break" !== D(j); j--); t.placement !== S && (t.modifiersData[n]._skip = !0, t.placement = S, t.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function Ve(e, t, i) { return void 0 === i && (i = { x: 0, y: 0 }), { top: e.top - t.height - i.y, right: e.right - t.width + i.x, bottom: e.bottom - t.height + i.y, left: e.left - t.width - i.x } } function Ue(e) { return [te, ne, ie, se].some((function (t) { return e[t] >= 0 })) } var Qe = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) { var t = e.state, i = e.name, n = t.rects.reference, s = t.rects.popper, r = t.modifiersData.preventOverflow, o = Ge(t, { elementContext: "reference" }), a = Ge(t, { altBoundary: !0 }), l = Ve(o, n), c = Ve(a, s, r), d = Ue(l), u = Ue(c); t.modifiersData[i] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: d, hasPopperEscaped: u }, t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, { "data-popper-reference-hidden": d, "data-popper-escaped": u }) } }, Ke = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var t = e.state, i = e.options, n = e.name, s = i.offset, r = void 0 === s ? [0, 0] : s, o = ae.reduce((function (e, i) { return e[i] = function (e, t, i) { var n = he(e), s = [se, te].indexOf(n) >= 0 ? -1 : 1, r = "function" == typeof i ? i(Object.assign(Object.assign({}, t), {}, { placement: e })) : i, o = r[0], a = r[1]; return o = o || 0, a = (a || 0) * s, [se, ne].indexOf(n) >= 0 ? { x: a, y: o } : { x: o, y: a } }(i, t.rects, r), e }), {}), a = o[t.placement], l = a.x, c = a.y; null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[n] = o } }, Ze = { name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) { var t = e.state, i = e.name; t.modifiersData[i] = Ye({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) }, data: {} }, Je = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) { var t = e.state, i = e.options, n = e.name, s = i.mainAxis, r = void 0 === s || s, o = i.altAxis, a = void 0 !== o && o, l = i.boundary, c = i.rootBoundary, d = i.altBoundary, u = i.padding, p = i.tether, f = void 0 === p || p, h = i.tetherOffset, m = void 0 === h ? 0 : h, g = Ge(t, { boundary: l, rootBoundary: c, padding: u, altBoundary: d }), v = he(t.placement), y = qe(t.placement), b = !y, w = xe(v), E = "x" === w ? "y" : "x", _ = t.modifiersData.popperOffsets, x = t.rects.reference, S = t.rects.popper, T = "function" == typeof m ? m(Object.assign(Object.assign({}, t.rects), {}, { placement: t.placement })) : m, C = { x: 0, y: 0 }; if (_) { if (r) { var M = "y" === w ? te : se, L = "y" === w ? ie : ne, I = "y" === w ? "height" : "width", A = _[w], P = _[w] + g[M], O = _[w] - g[L], k = f ? -S[I] / 2 : 0, z = "start" === y ? x[I] : S[I], D = "start" === y ? -S[I] : -x[I], j = t.elements.arrow, $ = f && j ? me(j) : { width: 0, height: 0 }, N = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, H = N[M], B = N[L], W = Se(0, x[I], $[I]), R = b ? x[I] / 2 - k - W - H - T : z - W - H - T, F = b ? -x[I] / 2 + k + W + B + T : D + W + B + T, q = t.elements.arrow && _e(t.elements.arrow), Y = q ? "y" === w ? q.clientTop || 0 : q.clientLeft || 0 : 0, G = t.modifiersData.offset ? t.modifiersData.offset[t.placement][w] : 0, X = _[w] + R - G - Y, V = _[w] + F - G, U = Se(f ? Math.min(P, X) : P, A, f ? Math.max(O, V) : O); _[w] = U, C[w] = U - A } if (a) { var Q = "x" === w ? te : se, K = "x" === w ? ie : ne, Z = _[E], J = Se(Z + g[Q], Z, Z - g[K]); _[E] = J, C[E] = J - Z } t.modifiersData[n] = C } }, requiresIfExists: ["offset"] }; function et(e, t, i) { void 0 === i && (i = !1); var n, s, r = be(t), o = $e(e), a = pe(t), l = { scrollLeft: 0, scrollTop: 0 }, c = { x: 0, y: 0 }; return (a || !a && !i) && (("body" !== ce(t) || Be(r)) && (l = (n = t) !== de(n) && pe(n) ? { scrollLeft: (s = n).scrollLeft, scrollTop: s.scrollTop } : Ne(n)), pe(t) ? ((c = $e(t)).x += t.clientLeft, c.y += t.clientTop) : r && (c.x = He(r))), { x: o.left + l.scrollLeft - c.x, y: o.top + l.scrollTop - c.y, width: o.width, height: o.height } } var tt = { placement: "bottom", modifiers: [], strategy: "absolute" }; function it() { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; return !t.some((function (e) { return !(e && "function" == typeof e.getBoundingClientRect) })) } function nt(e) { void 0 === e && (e = {}); var t = e, i = t.defaultModifiers, n = void 0 === i ? [] : i, s = t.defaultOptions, r = void 0 === s ? tt : s; return function (e, t, i) { void 0 === i && (i = r); var s, o, a = { placement: "bottom", orderedModifiers: [], options: Object.assign(Object.assign({}, tt), r), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }, l = [], c = !1, d = { state: a, setOptions: function (i) { u(), a.options = Object.assign(Object.assign(Object.assign({}, r), a.options), i), a.scrollParents = { reference: ue(e) ? We(e) : e.contextElement ? We(e.contextElement) : [], popper: We(t) }; var s, o, c = function (e) { var t = function (e) { var t = new Map, i = new Set, n = []; return e.forEach((function (e) { t.set(e.name, e) })), e.forEach((function (e) { i.has(e.name) || function e(s) { i.add(s.name), [].concat(s.requires || [], s.requiresIfExists || []).forEach((function (n) { if (!i.has(n)) { var s = t.get(n); s && e(s) } })), n.push(s) }(e) })), n }(e); return le.reduce((function (e, i) { return e.concat(t.filter((function (e) { return e.phase === i }))) }), []) }((s = [].concat(n, a.options.modifiers), o = s.reduce((function (e, t) { var i = e[t.name]; return e[t.name] = i ? Object.assign(Object.assign(Object.assign({}, i), t), {}, { options: Object.assign(Object.assign({}, i.options), t.options), data: Object.assign(Object.assign({}, i.data), t.data) }) : t, e }), {}), Object.keys(o).map((function (e) { return o[e] })))); return a.orderedModifiers = c.filter((function (e) { return e.enabled })), a.orderedModifiers.forEach((function (e) { var t = e.name, i = e.options, n = void 0 === i ? {} : i, s = e.effect; if ("function" == typeof s) { var r = s({ state: a, name: t, instance: d, options: n }); l.push(r || function () { }) } })), d.update() }, forceUpdate: function () { if (!c) { var e = a.elements, t = e.reference, i = e.popper; if (it(t, i)) { a.rects = { reference: et(t, _e(i), "fixed" === a.options.strategy), popper: me(i) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function (e) { return a.modifiersData[e.name] = Object.assign({}, e.data) })); for (var n = 0; n < a.orderedModifiers.length; n++)if (!0 !== a.reset) { var s = a.orderedModifiers[n], r = s.fn, o = s.options, l = void 0 === o ? {} : o, u = s.name; "function" == typeof r && (a = r({ state: a, options: l, name: u, instance: d }) || a) } else a.reset = !1, n = -1 } } }, update: (s = function () { return new Promise((function (e) { d.forceUpdate(), e(a) })) }, function () { return o || (o = new Promise((function (e) { Promise.resolve().then((function () { o = void 0, e(s()) })) }))), o }), destroy: function () { u(), c = !0 } }; if (!it(e, t)) return d; function u() { l.forEach((function (e) { return e() })), l = [] } return d.setOptions(i).then((function (e) { !c && i.onFirstUpdate && i.onFirstUpdate(e) })), d } } var st = nt(), rt = nt({ defaultModifiers: [Oe, Ze, Ae, fe] }), ot = nt({ defaultModifiers: [Oe, Ze, Ae, fe, Ke, Xe, Je, Me, Qe] }), at = Object.freeze({ __proto__: null, popperGenerator: nt, detectOverflow: Ge, createPopperBase: st, createPopper: ot, createPopperLite: rt, top: te, bottom: ie, right: ne, left: se, auto: "auto", basePlacements: re, start: "start", end: "end", clippingParents: "clippingParents", viewport: "viewport", popper: "popper", reference: "reference", variationPlacements: oe, placements: ae, beforeRead: "beforeRead", read: "read", afterRead: "afterRead", beforeMain: "beforeMain", main: "main", afterMain: "afterMain", beforeWrite: "beforeWrite", write: "write", afterWrite: "afterWrite", modifierPhases: le, applyStyles: fe, arrow: Me, computeStyles: Ae, eventListeners: Oe, flip: Xe, hide: Qe, offset: Ke, popperOffsets: Ze, preventOverflow: Je }), lt = "dropdown", ct = new RegExp("ArrowUp|ArrowDown|Escape"), dt = w ? "top-end" : "top-start", ut = w ? "top-start" : "top-end", pt = w ? "bottom-end" : "bottom-start", ft = w ? "bottom-start" : "bottom-end", ht = w ? "left-start" : "right-start", mt = w ? "right-start" : "left-start", gt = { offset: 0, flip: !0, boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null }, vt = { offset: "(number|string|function)", flip: "boolean", boundary: "(string|element)", reference: "(string|element)", display: "string", popperConfig: "(null|object)" }, yt = function (e) { function s(t, i) { var n; return (n = e.call(this, t) || this)._popper = null, n._config = n._getConfig(i), n._menu = n._getMenuElement(), n._inNavbar = n._detectNavbar(), n._addEventListeners(), n } n(s, e); var r = s.prototype; return r.toggle = function () { if (!this._element.disabled && !this._element.classList.contains("disabled")) { var e = this._element.classList.contains("show"); s.clearMenus(), e || this.show() } }, r.show = function () { if (!(this._element.disabled || this._element.classList.contains("disabled") || this._menu.classList.contains("show"))) { var e = s.getParentFromElement(this._element), t = { relatedTarget: this._element }; if (!$.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) { if (!this._inNavbar) { if (void 0 === at) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); var i = this._element; "parent" === this._config.reference ? i = e : p(this._config.reference) && (i = this._config.reference, void 0 !== this._config.reference.jquery && (i = this._config.reference[0])), this._popper = ot(i, this._menu, this._getPopperConfig()) } var n; "ontouchstart" in document.documentElement && !e.closest(".navbar-nav") && (n = []).concat.apply(n, document.body.children).forEach((function (e) { return $.on(e, "mouseover", null, (function () { })) })), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), $.trigger(e, "shown.bs.dropdown", t) } } }, r.hide = function () { if (!this._element.disabled && !this._element.classList.contains("disabled") && this._menu.classList.contains("show")) { var e = s.getParentFromElement(this._element), t = { relatedTarget: this._element }; $.trigger(e, "hide.bs.dropdown", t).defaultPrevented || (this._popper && this._popper.destroy(), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), $.trigger(e, "hidden.bs.dropdown", t)) } }, r.dispose = function () { e.prototype.dispose.call(this), $.off(this._element, ".bs.dropdown"), this._menu = null, this._popper && (this._popper.destroy(), this._popper = null) }, r.update = function () { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() }, r._addEventListeners = function () { var e = this; $.on(this._element, "click.bs.dropdown", (function (t) { t.preventDefault(), t.stopPropagation(), e.toggle() })) }, r._getConfig = function (e) { return e = i({}, this.constructor.Default, q.getDataAttributes(this._element), e), h(lt, e, this.constructor.DefaultType), e }, r._getMenuElement = function () { return Y.next(this._element, ".dropdown-menu")[0] }, r._getPlacement = function () { var e = this._element.parentNode; if (e.classList.contains("dropend")) return ht; if (e.classList.contains("dropstart")) return mt; var t = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim(); return e.classList.contains("dropup") ? t ? ut : dt : t ? ft : pt }, r._detectNavbar = function () { return null !== this._element.closest(".navbar") }, r._getPopperConfig = function () { var e = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { altBoundary: this._config.flip, rootBoundary: this._config.boundary } }] }; return "static" === this._config.display && (e.modifiers = [{ name: "applyStyles", enabled: !1 }]), i({}, e, this._config.popperConfig) }, s.dropdownInterface = function (e, t) { var i = x(e, "bs.dropdown"); if (i || (i = new s(e, "object" == typeof t ? t : null)), "string" == typeof t) { if (void 0 === i[t]) throw new TypeError('No method named "' + t + '"'); i[t]() } }, s.jQueryInterface = function (e) { return this.each((function () { s.dropdownInterface(this, e) })) }, s.clearMenus = function (e) { if (!e || 2 !== e.button && ("keyup" !== e.type || "Tab" === e.key)) for (var t = Y.find('[data-bs-toggle="dropdown"]'), i = 0, n = t.length; i < n; i++) { var r = s.getParentFromElement(t[i]), o = x(t[i], "bs.dropdown"), a = { relatedTarget: t[i] }; if (e && "click" === e.type && (a.clickEvent = e), o) { var l, c = o._menu; if (t[i].classList.contains("show") && !(e && ("click" === e.type && /input|textarea/i.test(e.target.tagName) || "keyup" === e.type && "Tab" === e.key) && c.contains(e.target) || $.trigger(r, "hide.bs.dropdown", a).defaultPrevented)) "ontouchstart" in document.documentElement && (l = []).concat.apply(l, document.body.children).forEach((function (e) { return $.off(e, "mouseover", null, (function () { })) })), t[i].setAttribute("aria-expanded", "false"), o._popper && o._popper.destroy(), c.classList.remove("show"), t[i].classList.remove("show"), $.trigger(r, "hidden.bs.dropdown", a) } } }, s.getParentFromElement = function (e) { return c(e) || e.parentNode }, s.dataApiKeydownHandler = function (e) { if (!(/input|textarea/i.test(e.target.tagName) ? "Space" === e.key || "Escape" !== e.key && ("ArrowDown" !== e.key && "ArrowUp" !== e.key || e.target.closest(".dropdown-menu")) : !ct.test(e.key)) && (e.preventDefault(), e.stopPropagation(), !this.disabled && !this.classList.contains("disabled"))) { var t = s.getParentFromElement(this), i = this.classList.contains("show"); if ("Escape" === e.key) return (this.matches('[data-bs-toggle="dropdown"]') ? this : Y.prev(this, '[data-bs-toggle="dropdown"]')[0]).focus(), void s.clearMenus(); if (i && "Space" !== e.key) { var n = Y.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", t).filter(m); if (n.length) { var r = n.indexOf(e.target); "ArrowUp" === e.key && r > 0 && r--, "ArrowDown" === e.key && r < n.length - 1 && r++, n[r = -1 === r ? 0 : r].focus() } } else s.clearMenus() } }, t(s, null, [{ key: "Default", get: function () { return gt } }, { key: "DefaultType", get: function () { return vt } }, { key: "DATA_KEY", get: function () { return "bs.dropdown" } }]), s }(N); $.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', yt.dataApiKeydownHandler), $.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", yt.dataApiKeydownHandler), $.on(document, "click.bs.dropdown.data-api", yt.clearMenus), $.on(document, "keyup.bs.dropdown.data-api", yt.clearMenus), $.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', (function (e) { e.preventDefault(), e.stopPropagation(), yt.dropdownInterface(this, "toggle") })), $.on(document, "click.bs.dropdown.data-api", ".dropdown form", (function (e) { return e.stopPropagation() })), b((function () { var e = y(); if (e) { var t = e.fn[lt]; e.fn[lt] = yt.jQueryInterface, e.fn[lt].Constructor = yt, e.fn[lt].noConflict = function () { return e.fn[lt] = t, yt.jQueryInterface } } })); var bt = { backdrop: !0, keyboard: !0, focus: !0 }, wt = { backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean" }, Et = function (e) { function s(t, i) { var n; return (n = e.call(this, t) || this)._config = n._getConfig(i), n._dialog = Y.findOne(".modal-dialog", t), n._backdrop = null, n._isShown = !1, n._isBodyOverflowing = !1, n._ignoreBackdropClick = !1, n._isTransitioning = !1, n._scrollbarWidth = 0, n } n(s, e); var r = s.prototype; return r.toggle = function (e) { return this._isShown ? this.hide() : this.show(e) }, r.show = function (e) { var t = this; if (!this._isShown && !this._isTransitioning) { this._element.classList.contains("fade") && (this._isTransitioning = !0); var i = $.trigger(this._element, "show.bs.modal", { relatedTarget: e }); this._isShown || i.defaultPrevented || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), $.on(this._element, "click.dismiss.bs.modal", '[data-bs-dismiss="modal"]', (function (e) { return t.hide(e) })), $.on(this._dialog, "mousedown.dismiss.bs.modal", (function () { $.one(t._element, "mouseup.dismiss.bs.modal", (function (e) { e.target === t._element && (t._ignoreBackdropClick = !0) })) })), this._showBackdrop((function () { return t._showElement(e) }))) } }, r.hide = function (e) { var t = this; if (e && e.preventDefault(), this._isShown && !this._isTransitioning && !$.trigger(this._element, "hide.bs.modal").defaultPrevented) { this._isShown = !1; var i = this._element.classList.contains("fade"); if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), $.off(document, "focusin.bs.modal"), this._element.classList.remove("show"), $.off(this._element, "click.dismiss.bs.modal"), $.off(this._dialog, "mousedown.dismiss.bs.modal"), i) { var n = d(this._element); $.one(this._element, "transitionend", (function (e) { return t._hideModal(e) })), f(this._element, n) } else this._hideModal() } }, r.dispose = function () { [window, this._element, this._dialog].forEach((function (e) { return $.off(e, ".bs.modal") })), e.prototype.dispose.call(this), $.off(document, "focusin.bs.modal"), this._config = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null }, r.handleUpdate = function () { this._adjustDialog() }, r._getConfig = function (e) { return e = i({}, bt, e), h("modal", e, wt), e }, r._showElement = function (e) { var t = this, i = this._element.classList.contains("fade"), n = Y.findOne(".modal-body", this._dialog); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, n && (n.scrollTop = 0), i && v(this._element), this._element.classList.add("show"), this._config.focus && this._enforceFocus(); var s = function () { t._config.focus && t._element.focus(), t._isTransitioning = !1, $.trigger(t._element, "shown.bs.modal", { relatedTarget: e }) }; if (i) { var r = d(this._dialog); $.one(this._dialog, "transitionend", s), f(this._dialog, r) } else s() }, r._enforceFocus = function () { var e = this; $.off(document, "focusin.bs.modal"), $.on(document, "focusin.bs.modal", (function (t) { document === t.target || e._element === t.target || e._element.contains(t.target) || e._element.focus() })) }, r._setEscapeEvent = function () { var e = this; this._isShown ? $.on(this._element, "keydown.dismiss.bs.modal", (function (t) { e._config.keyboard && "Escape" === t.key ? (t.preventDefault(), e.hide()) : e._config.keyboard || "Escape" !== t.key || e._triggerBackdropTransition() })) : $.off(this._element, "keydown.dismiss.bs.modal") }, r._setResizeEvent = function () { var e = this; this._isShown ? $.on(window, "resize.bs.modal", (function () { return e._adjustDialog() })) : $.off(window, "resize.bs.modal") }, r._hideModal = function () { var e = this; this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._showBackdrop((function () { document.body.classList.remove("modal-open"), e._resetAdjustments(), e._resetScrollbar(), $.trigger(e._element, "hidden.bs.modal") })) }, r._removeBackdrop = function () { this._backdrop.parentNode.removeChild(this._backdrop), this._backdrop = null }, r._showBackdrop = function (e) { var t = this, i = this._element.classList.contains("fade") ? "fade" : ""; if (this._isShown && this._config.backdrop) { if (this._backdrop = document.createElement("div"), this._backdrop.className = "modal-backdrop", i && this._backdrop.classList.add(i), document.body.appendChild(this._backdrop), $.on(this._element, "click.dismiss.bs.modal", (function (e) { t._ignoreBackdropClick ? t._ignoreBackdropClick = !1 : e.target === e.currentTarget && ("static" === t._config.backdrop ? t._triggerBackdropTransition() : t.hide()) })), i && v(this._backdrop), this._backdrop.classList.add("show"), !i) return void e(); var n = d(this._backdrop); $.one(this._backdrop, "transitionend", e), f(this._backdrop, n) } else if (!this._isShown && this._backdrop) { this._backdrop.classList.remove("show"); var s = function () { t._removeBackdrop(), e() }; if (this._element.classList.contains("fade")) { var r = d(this._backdrop); $.one(this._backdrop, "transitionend", s), f(this._backdrop, r) } else s() } else e() }, r._triggerBackdropTransition = function () { var e = this; if (!$.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) { var t = this._element.scrollHeight > document.documentElement.clientHeight; t || (this._element.style.overflowY = "hidden"), this._element.classList.add("modal-static"); var i = d(this._dialog); $.off(this._element, "transitionend"), $.one(this._element, "transitionend", (function () { e._element.classList.remove("modal-static"), t || ($.one(e._element, "transitionend", (function () { e._element.style.overflowY = "" })), f(e._element, i)) })), f(this._element, i), this._element.focus() } }, r._adjustDialog = function () { var e = this._element.scrollHeight > document.documentElement.clientHeight; (!this._isBodyOverflowing && e && !w || this._isBodyOverflowing && !e && w) && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), (this._isBodyOverflowing && !e && !w || !this._isBodyOverflowing && e && w) && (this._element.style.paddingRight = this._scrollbarWidth + "px") }, r._resetAdjustments = function () { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" }, r._checkScrollbar = function () { var e = document.body.getBoundingClientRect(); this._isBodyOverflowing = Math.round(e.left + e.right) < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth() }, r._setScrollbar = function () { var e = this; if (this._isBodyOverflowing) { Y.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function (t) { var i = t.style.paddingRight, n = window.getComputedStyle(t)["padding-right"]; q.setDataAttribute(t, "padding-right", i), t.style.paddingRight = Number.parseFloat(n) + e._scrollbarWidth + "px" })), Y.find(".sticky-top").forEach((function (t) { var i = t.style.marginRight, n = window.getComputedStyle(t)["margin-right"]; q.setDataAttribute(t, "margin-right", i), t.style.marginRight = Number.parseFloat(n) - e._scrollbarWidth + "px" })); var t = document.body.style.paddingRight, i = window.getComputedStyle(document.body)["padding-right"]; q.setDataAttribute(document.body, "padding-right", t), document.body.style.paddingRight = Number.parseFloat(i) + this._scrollbarWidth + "px" } document.body.classList.add("modal-open") }, r._resetScrollbar = function () { Y.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function (e) { var t = q.getDataAttribute(e, "padding-right"); void 0 !== t && (q.removeDataAttribute(e, "padding-right"), e.style.paddingRight = t) })), Y.find(".sticky-top").forEach((function (e) { var t = q.getDataAttribute(e, "margin-right"); void 0 !== t && (q.removeDataAttribute(e, "margin-right"), e.style.marginRight = t) })); var e = q.getDataAttribute(document.body, "padding-right"); void 0 === e ? document.body.style.paddingRight = "" : (q.removeDataAttribute(document.body, "padding-right"), document.body.style.paddingRight = e) }, r._getScrollbarWidth = function () { var e = document.createElement("div"); e.className = "modal-scrollbar-measure", document.body.appendChild(e); var t = e.getBoundingClientRect().width - e.clientWidth; return document.body.removeChild(e), t }, s.jQueryInterface = function (e, t) { return this.each((function () { var n = x(this, "bs.modal"), r = i({}, bt, q.getDataAttributes(this), "object" == typeof e && e ? e : {}); if (n || (n = new s(this, r)), "string" == typeof e) { if (void 0 === n[e]) throw new TypeError('No method named "' + e + '"'); n[e](t) } })) }, t(s, null, [{ key: "Default", get: function () { return bt } }, { key: "DATA_KEY", get: function () { return "bs.modal" } }]), s }(N); $.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function (e) { var t = this, n = c(this); "A" !== this.tagName && "AREA" !== this.tagName || e.preventDefault(), $.one(n, "show.bs.modal", (function (e) { e.defaultPrevented || $.one(n, "hidden.bs.modal", (function () { m(t) && t.focus() })) })); var s = x(n, "bs.modal"); if (!s) { var r = i({}, q.getDataAttributes(n), q.getDataAttributes(this)); s = new Et(n, r) } s.show(this) })), b((function () { var e = y(); if (e) { var t = e.fn.modal; e.fn.modal = Et.jQueryInterface, e.fn.modal.Constructor = Et, e.fn.modal.noConflict = function () { return e.fn.modal = t, Et.jQueryInterface } } })); var _t = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), xt = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi, St = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i; function Tt(e, t, i) { var n; if (!e.length) return e; if (i && "function" == typeof i) return i(e); for (var s = (new window.DOMParser).parseFromString(e, "text/html"), r = Object.keys(t), o = (n = []).concat.apply(n, s.body.querySelectorAll("*")), a = function (e, i) { var n, s = o[e], a = s.nodeName.toLowerCase(); if (!r.includes(a)) return s.parentNode.removeChild(s), "continue"; var l = (n = []).concat.apply(n, s.attributes), c = [].concat(t["*"] || [], t[a] || []); l.forEach((function (e) { (function (e, t) { var i = e.nodeName.toLowerCase(); if (t.includes(i)) return !_t.has(i) || Boolean(e.nodeValue.match(xt) || e.nodeValue.match(St)); for (var n = t.filter((function (e) { return e instanceof RegExp })), s = 0, r = n.length; s < r; s++)if (i.match(n[s])) return !0; return !1 })(e, c) || s.removeAttribute(e.nodeName) })) }, l = 0, c = o.length; l < c; l++)a(l); return s.body.innerHTML } var Ct = "tooltip", Mt = new RegExp("(^|\\s)bs-tooltip\\S+", "g"), Lt = new Set(["sanitize", "allowList", "sanitizeFn"]), It = { animation: "boolean", template: "string", title: "(string|element|function)", trigger: "string", delay: "(number|object)", html: "boolean", selector: "(string|boolean)", placement: "(string|function)", container: "(string|element|boolean)", fallbackPlacements: "(null|array)", boundary: "(string|element)", customClass: "(string|function)", sanitize: "boolean", sanitizeFn: "(null|function)", allowList: "object", popperConfig: "(null|object)" }, At = { AUTO: "auto", TOP: "top", RIGHT: w ? "left" : "right", BOTTOM: "bottom", LEFT: w ? "right" : "left" }, Pt = { animation: !0, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, selector: !1, placement: "top", container: !1, fallbackPlacements: null, boundary: "clippingParents", customClass: "", sanitize: !0, sanitizeFn: null, allowList: { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, popperConfig: null }, Ot = { HIDE: "hide.bs.tooltip", HIDDEN: "hidden.bs.tooltip", SHOW: "show.bs.tooltip", SHOWN: "shown.bs.tooltip", INSERTED: "inserted.bs.tooltip", CLICK: "click.bs.tooltip", FOCUSIN: "focusin.bs.tooltip", FOCUSOUT: "focusout.bs.tooltip", MOUSEENTER: "mouseenter.bs.tooltip", MOUSELEAVE: "mouseleave.bs.tooltip" }, kt = function (e) { function s(t, i) { var n; if (void 0 === at) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); return (n = e.call(this, t) || this)._isEnabled = !0, n._timeout = 0, n._hoverState = "", n._activeTrigger = {}, n._popper = null, n.config = n._getConfig(i), n.tip = null, n._setListeners(), n } n(s, e); var r = s.prototype; return r.enable = function () { this._isEnabled = !0 }, r.disable = function () { this._isEnabled = !1 }, r.toggleEnabled = function () { this._isEnabled = !this._isEnabled }, r.toggle = function (e) { if (this._isEnabled) if (e) { var t = this.constructor.DATA_KEY, i = x(e.delegateTarget, t); i || (i = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, t, i)), i._activeTrigger.click = !i._activeTrigger.click, i._isWithActiveTrigger() ? i._enter(null, i) : i._leave(null, i) } else { if (this.getTipElement().classList.contains("show")) return void this._leave(null, this); this._enter(null, this) } }, r.dispose = function () { clearTimeout(this._timeout), $.off(this._element, this.constructor.EVENT_KEY), $.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.parentNode.removeChild(this.tip), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, this._popper && this._popper.destroy(), this._popper = null, this.config = null, this.tip = null, e.prototype.dispose.call(this) }, r.show = function () { var e = this; if ("none" === this._element.style.display) throw new Error("Please use show on visible elements"); if (this.isWithContent() && this._isEnabled) { var t = $.trigger(this._element, this.constructor.Event.SHOW), i = function e(t) { if (!document.documentElement.attachShadow) return null; if ("function" == typeof t.getRootNode) { var i = t.getRootNode(); return i instanceof ShadowRoot ? i : null } return t instanceof ShadowRoot ? t : t.parentNode ? e(t.parentNode) : null }(this._element), n = null === i ? this._element.ownerDocument.documentElement.contains(this._element) : i.contains(this._element); if (t.defaultPrevented || !n) return; var s = this.getTipElement(), r = o(this.constructor.NAME); s.setAttribute("id", r), this._element.setAttribute("aria-describedby", r), this.setContent(), this.config.animation && s.classList.add("fade"); var a = "function" == typeof this.config.placement ? this.config.placement.call(this, s, this._element) : this.config.placement, l = this._getAttachment(a); this._addAttachmentClass(l); var c = this._getContainer(); _(s, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || c.appendChild(s), $.trigger(this._element, this.constructor.Event.INSERTED), this._popper = ot(this._element, s, this._getPopperConfig(l)), s.classList.add("show"); var u, p, h = "function" == typeof this.config.customClass ? this.config.customClass() : this.config.customClass; h && (u = s.classList).add.apply(u, h.split(" ")), "ontouchstart" in document.documentElement && (p = []).concat.apply(p, document.body.children).forEach((function (e) { $.on(e, "mouseover", (function () { })) })); var m = function () { var t = e._hoverState; e._hoverState = null, $.trigger(e._element, e.constructor.Event.SHOWN), "out" === t && e._leave(null, e) }; if (this.tip.classList.contains("fade")) { var g = d(this.tip); $.one(this.tip, "transitionend", m), f(this.tip, g) } else m() } }, r.hide = function () { var e = this; if (this._popper) { var t = this.getTipElement(), i = function () { "show" !== e._hoverState && t.parentNode && t.parentNode.removeChild(t), e._cleanTipClass(), e._element.removeAttribute("aria-describedby"), $.trigger(e._element, e.constructor.Event.HIDDEN), e._popper && (e._popper.destroy(), e._popper = null) }; if (!$.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) { var n; if (t.classList.remove("show"), "ontouchstart" in document.documentElement && (n = []).concat.apply(n, document.body.children).forEach((function (e) { return $.off(e, "mouseover", g) })), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this.tip.classList.contains("fade")) { var s = d(t); $.one(t, "transitionend", i), f(t, s) } else i(); this._hoverState = "" } } }, r.update = function () { null !== this._popper && this._popper.update() }, r.isWithContent = function () { return Boolean(this.getTitle()) }, r.getTipElement = function () { if (this.tip) return this.tip; var e = document.createElement("div"); return e.innerHTML = this.config.template, this.tip = e.children[0], this.tip }, r.setContent = function () { var e = this.getTipElement(); this.setElementContent(Y.findOne(".tooltip-inner", e), this.getTitle()), e.classList.remove("fade", "show") }, r.setElementContent = function (e, t) { if (null !== e) return "object" == typeof t && p(t) ? (t.jquery && (t = t[0]), void (this.config.html ? t.parentNode !== e && (e.innerHTML = "", e.appendChild(t)) : e.textContent = t.textContent)) : void (this.config.html ? (this.config.sanitize && (t = Tt(t, this.config.allowList, this.config.sanitizeFn)), e.innerHTML = t) : e.textContent = t) }, r.getTitle = function () { var e = this._element.getAttribute("data-bs-original-title"); return e || (e = "function" == typeof this.config.title ? this.config.title.call(this._element) : this.config.title), e }, r.updateAttachment = function (e) { return "right" === e ? "end" : "left" === e ? "start" : e }, r._getPopperConfig = function (e) { var t = this, n = { name: "flip", options: { altBoundary: !0 } }; return this.config.fallbackPlacements && (n.options.fallbackPlacements = this.config.fallbackPlacements), i({}, { placement: e, modifiers: [n, { name: "preventOverflow", options: { rootBoundary: this.config.boundary } }, { name: "arrow", options: { element: "." + this.constructor.NAME + "-arrow" } }, { name: "onChange", enabled: !0, phase: "afterWrite", fn: function (e) { return t._handlePopperPlacementChange(e) } }], onFirstUpdate: function (e) { e.options.placement !== e.placement && t._handlePopperPlacementChange(e) } }, this.config.popperConfig) }, r._addAttachmentClass = function (e) { this.getTipElement().classList.add("bs-tooltip-" + this.updateAttachment(e)) }, r._getContainer = function () { return !1 === this.config.container ? document.body : p(this.config.container) ? this.config.container : Y.findOne(this.config.container) }, r._getAttachment = function (e) { return At[e.toUpperCase()] }, r._setListeners = function () { var e = this; this.config.trigger.split(" ").forEach((function (t) { if ("click" === t) $.on(e._element, e.constructor.Event.CLICK, e.config.selector, (function (t) { return e.toggle(t) })); else if ("manual" !== t) { var i = "hover" === t ? e.constructor.Event.MOUSEENTER : e.constructor.Event.FOCUSIN, n = "hover" === t ? e.constructor.Event.MOUSELEAVE : e.constructor.Event.FOCUSOUT; $.on(e._element, i, e.config.selector, (function (t) { return e._enter(t) })), $.on(e._element, n, e.config.selector, (function (t) { return e._leave(t) })) } })), this._hideModalHandler = function () { e._element && e.hide() }, $.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.config.selector ? this.config = i({}, this.config, { trigger: "manual", selector: "" }) : this._fixTitle() }, r._fixTitle = function () { var e = this._element.getAttribute("title"), t = typeof this._element.getAttribute("data-bs-original-title"); (e || "string" !== t) && (this._element.setAttribute("data-bs-original-title", e || ""), !e || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", e), this._element.setAttribute("title", "")) }, r._enter = function (e, t) { var i = this.constructor.DATA_KEY; (t = t || x(e.delegateTarget, i)) || (t = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, i, t)), e && (t._activeTrigger["focusin" === e.type ? "focus" : "hover"] = !0), t.getTipElement().classList.contains("show") || "show" === t._hoverState ? t._hoverState = "show" : (clearTimeout(t._timeout), t._hoverState = "show", t.config.delay && t.config.delay.show ? t._timeout = setTimeout((function () { "show" === t._hoverState && t.show() }), t.config.delay.show) : t.show()) }, r._leave = function (e, t) { var i = this.constructor.DATA_KEY; (t = t || x(e.delegateTarget, i)) || (t = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, i, t)), e && (t._activeTrigger["focusout" === e.type ? "focus" : "hover"] = !1), t._isWithActiveTrigger() || (clearTimeout(t._timeout), t._hoverState = "out", t.config.delay && t.config.delay.hide ? t._timeout = setTimeout((function () { "out" === t._hoverState && t.hide() }), t.config.delay.hide) : t.hide()) }, r._isWithActiveTrigger = function () { for (var e in this._activeTrigger) if (this._activeTrigger[e]) return !0; return !1 }, r._getConfig = function (e) { var t = q.getDataAttributes(this._element); return Object.keys(t).forEach((function (e) { Lt.has(e) && delete t[e] })), e && "object" == typeof e.container && e.container.jquery && (e.container = e.container[0]), "number" == typeof (e = i({}, this.constructor.Default, t, "object" == typeof e && e ? e : {})).delay && (e.delay = { show: e.delay, hide: e.delay }), "number" == typeof e.title && (e.title = e.title.toString()), "number" == typeof e.content && (e.content = e.content.toString()), h(Ct, e, this.constructor.DefaultType), e.sanitize && (e.template = Tt(e.template, e.allowList, e.sanitizeFn)), e }, r._getDelegateConfig = function () { var e = {}; if (this.config) for (var t in this.config) this.constructor.Default[t] !== this.config[t] && (e[t] = this.config[t]); return e }, r._cleanTipClass = function () { var e = this.getTipElement(), t = e.getAttribute("class").match(Mt); null !== t && t.length > 0 && t.map((function (e) { return e.trim() })).forEach((function (t) { return e.classList.remove(t) })) }, r._handlePopperPlacementChange = function (e) { var t = e.state; t && (this.tip = t.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(t.placement))) }, s.jQueryInterface = function (e) { return this.each((function () { var t = x(this, "bs.tooltip"), i = "object" == typeof e && e; if ((t || !/dispose|hide/.test(e)) && (t || (t = new s(this, i)), "string" == typeof e)) { if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"'); t[e]() } })) }, t(s, null, [{ key: "Default", get: function () { return Pt } }, { key: "NAME", get: function () { return Ct } }, { key: "DATA_KEY", get: function () { return "bs.tooltip" } }, { key: "Event", get: function () { return Ot } }, { key: "EVENT_KEY", get: function () { return ".bs.tooltip" } }, { key: "DefaultType", get: function () { return It } }]), s }(N); b((function () { var e = y(); if (e) { var t = e.fn[Ct]; e.fn[Ct] = kt.jQueryInterface, e.fn[Ct].Constructor = kt, e.fn[Ct].noConflict = function () { return e.fn[Ct] = t, kt.jQueryInterface } } })); var zt = "popover", Dt = new RegExp("(^|\\s)bs-popover\\S+", "g"), jt = i({}, kt.Default, { placement: "right", trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }), $t = i({}, kt.DefaultType, { content: "(string|element|function)" }), Nt = { HIDE: "hide.bs.popover", HIDDEN: "hidden.bs.popover", SHOW: "show.bs.popover", SHOWN: "shown.bs.popover", INSERTED: "inserted.bs.popover", CLICK: "click.bs.popover", FOCUSIN: "focusin.bs.popover", FOCUSOUT: "focusout.bs.popover", MOUSEENTER: "mouseenter.bs.popover", MOUSELEAVE: "mouseleave.bs.popover" }, Ht = function (e) { function i() { return e.apply(this, arguments) || this } n(i, e); var s = i.prototype; return s.isWithContent = function () { return this.getTitle() || this._getContent() }, s.setContent = function () { var e = this.getTipElement(); this.setElementContent(Y.findOne(".popover-header", e), this.getTitle()); var t = this._getContent(); "function" == typeof t && (t = t.call(this._element)), this.setElementContent(Y.findOne(".popover-body", e), t), e.classList.remove("fade", "show") }, s._addAttachmentClass = function (e) { this.getTipElement().classList.add("bs-popover-" + this.updateAttachment(e)) }, s._getContent = function () { return this._element.getAttribute("data-bs-content") || this.config.content }, s._cleanTipClass = function () { var e = this.getTipElement(), t = e.getAttribute("class").match(Dt); null !== t && t.length > 0 && t.map((function (e) { return e.trim() })).forEach((function (t) { return e.classList.remove(t) })) }, i.jQueryInterface = function (e) { return this.each((function () { var t = x(this, "bs.popover"), n = "object" == typeof e ? e : null; if ((t || !/dispose|hide/.test(e)) && (t || (t = new i(this, n), _(this, "bs.popover", t)), "string" == typeof e)) { if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"'); t[e]() } })) }, t(i, null, [{ key: "Default", get: function () { return jt } }, { key: "NAME", get: function () { return zt } }, { key: "DATA_KEY", get: function () { return "bs.popover" } }, { key: "Event", get: function () { return Nt } }, { key: "EVENT_KEY", get: function () { return ".bs.popover" } }, { key: "DefaultType", get: function () { return $t } }]), i }(kt); b((function () { var e = y(); if (e) { var t = e.fn[zt]; e.fn[zt] = Ht.jQueryInterface, e.fn[zt].Constructor = Ht, e.fn[zt].noConflict = function () { return e.fn[zt] = t, Ht.jQueryInterface } } })); var Bt = "scrollspy", Wt = { offset: 10, method: "auto", target: "" }, Rt = { offset: "number", method: "string", target: "(string|element)" }, Ft = function (e) { function s(t, i) { var n; return (n = e.call(this, t) || this)._scrollElement = "BODY" === t.tagName ? window : t, n._config = n._getConfig(i), n._selector = n._config.target + " .nav-link, " + n._config.target + " .list-group-item, " + n._config.target + " .dropdown-item", n._offsets = [], n._targets = [], n._activeTarget = null, n._scrollHeight = 0, $.on(n._scrollElement, "scroll.bs.scrollspy", (function (e) { return n._process(e) })), n.refresh(), n._process(), n } n(s, e); var r = s.prototype; return r.refresh = function () { var e = this, t = this._scrollElement === this._scrollElement.window ? "offset" : "position", i = "auto" === this._config.method ? t : this._config.method, n = "position" === i ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), Y.find(this._selector).map((function (e) { var t = l(e), s = t ? Y.findOne(t) : null; if (s) { var r = s.getBoundingClientRect(); if (r.width || r.height) return [q[i](s).top + n, t] } return null })).filter((function (e) { return e })).sort((function (e, t) { return e[0] - t[0] })).forEach((function (t) { e._offsets.push(t[0]), e._targets.push(t[1]) })) }, r.dispose = function () { e.prototype.dispose.call(this), $.off(this._scrollElement, ".bs.scrollspy"), this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null }, r._getConfig = function (e) { if ("string" != typeof (e = i({}, Wt, "object" == typeof e && e ? e : {})).target && p(e.target)) { var t = e.target.id; t || (t = o(Bt), e.target.id = t), e.target = "#" + t } return h(Bt, e, Rt), e }, r._getScrollTop = function () { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop }, r._getScrollHeight = function () { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) }, r._getOffsetHeight = function () { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height }, r._process = function () { var e = this._getScrollTop() + this._config.offset, t = this._getScrollHeight(), i = this._config.offset + t - this._getOffsetHeight(); if (this._scrollHeight !== t && this.refresh(), e >= i) { var n = this._targets[this._targets.length - 1]; this._activeTarget !== n && this._activate(n) } else { if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (var s = this._offsets.length; s--;)this._activeTarget !== this._targets[s] && e >= this._offsets[s] && (void 0 === this._offsets[s + 1] || e < this._offsets[s + 1]) && this._activate(this._targets[s]) } }, r._activate = function (e) { this._activeTarget = e, this._clear(); var t = this._selector.split(",").map((function (t) { return t + '[data-bs-target="' + e + '"],' + t + '[href="' + e + '"]' })), i = Y.findOne(t.join(",")); i.classList.contains("dropdown-item") ? (Y.findOne(".dropdown-toggle", i.closest(".dropdown")).classList.add("active"), i.classList.add("active")) : (i.classList.add("active"), Y.parents(i, ".nav, .list-group").forEach((function (e) { Y.prev(e, ".nav-link, .list-group-item").forEach((function (e) { return e.classList.add("active") })), Y.prev(e, ".nav-item").forEach((function (e) { Y.children(e, ".nav-link").forEach((function (e) { return e.classList.add("active") })) })) }))), $.trigger(this._scrollElement, "activate.bs.scrollspy", { relatedTarget: e }) }, r._clear = function () { Y.find(this._selector).filter((function (e) { return e.classList.contains("active") })).forEach((function (e) { return e.classList.remove("active") })) }, s.jQueryInterface = function (e) { return this.each((function () { var t = x(this, "bs.scrollspy"); if (t || (t = new s(this, "object" == typeof e && e)), "string" == typeof e) { if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"'); t[e]() } })) }, t(s, null, [{ key: "Default", get: function () { return Wt } }, { key: "DATA_KEY", get: function () { return "bs.scrollspy" } }]), s }(N); $.on(window, "load.bs.scrollspy.data-api", (function () { Y.find('[data-bs-spy="scroll"]').forEach((function (e) { return new Ft(e, q.getDataAttributes(e)) })) })), b((function () { var e = y(); if (e) { var t = e.fn[Bt]; e.fn[Bt] = Ft.jQueryInterface, e.fn[Bt].Constructor = Ft, e.fn[Bt].noConflict = function () { return e.fn[Bt] = t, Ft.jQueryInterface } } })); var qt = function (e) { function i() { return e.apply(this, arguments) || this } n(i, e); var s = i.prototype; return s.show = function () { var e = this; if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active") || this._element.classList.contains("disabled"))) { var t, i = c(this._element), n = this._element.closest(".nav, .list-group"); if (n) { var s = "UL" === n.nodeName || "OL" === n.nodeName ? ":scope > li > .active" : ".active"; t = (t = Y.find(s, n))[t.length - 1] } var r = null; if (t && (r = $.trigger(t, "hide.bs.tab", { relatedTarget: this._element })), !($.trigger(this._element, "show.bs.tab", { relatedTarget: t }).defaultPrevented || null !== r && r.defaultPrevented)) { this._activate(this._element, n); var o = function () { $.trigger(t, "hidden.bs.tab", { relatedTarget: e._element }), $.trigger(e._element, "shown.bs.tab", { relatedTarget: t }) }; i ? this._activate(i, i.parentNode, o) : o() } } }, s._activate = function (e, t, i) { var n = this, s = (!t || "UL" !== t.nodeName && "OL" !== t.nodeName ? Y.children(t, ".active") : Y.find(":scope > li > .active", t))[0], r = i && s && s.classList.contains("fade"), o = function () { return n._transitionComplete(e, s, i) }; if (s && r) { var a = d(s); s.classList.remove("show"), $.one(s, "transitionend", o), f(s, a) } else o() }, s._transitionComplete = function (e, t, i) { if (t) { t.classList.remove("active"); var n = Y.findOne(":scope > .dropdown-menu .active", t.parentNode); n && n.classList.remove("active"), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !1) } e.classList.add("active"), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !0), v(e), e.classList.contains("fade") && e.classList.add("show"), e.parentNode && e.parentNode.classList.contains("dropdown-menu") && (e.closest(".dropdown") && Y.find(".dropdown-toggle").forEach((function (e) { return e.classList.add("active") })), e.setAttribute("aria-expanded", !0)), i && i() }, i.jQueryInterface = function (e) { return this.each((function () { var t = x(this, "bs.tab") || new i(this); if ("string" == typeof e) { if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"'); t[e]() } })) }, t(i, null, [{ key: "DATA_KEY", get: function () { return "bs.tab" } }]), i }(N); $.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', (function (e) { e.preventDefault(), (x(this, "bs.tab") || new qt(this)).show() })), b((function () { var e = y(); if (e) { var t = e.fn.tab; e.fn.tab = qt.jQueryInterface, e.fn.tab.Constructor = qt, e.fn.tab.noConflict = function () { return e.fn.tab = t, qt.jQueryInterface } } })); var Yt = { animation: "boolean", autohide: "boolean", delay: "number" }, Gt = { animation: !0, autohide: !0, delay: 5e3 }, Xt = function (e) { function s(t, i) { var n; return (n = e.call(this, t) || this)._config = n._getConfig(i), n._timeout = null, n._setListeners(), n } n(s, e); var r = s.prototype; return r.show = function () { var e = this; if (!$.trigger(this._element, "show.bs.toast").defaultPrevented) { this._clearTimeout(), this._config.animation && this._element.classList.add("fade"); var t = function () { e._element.classList.remove("showing"), e._element.classList.add("show"), $.trigger(e._element, "shown.bs.toast"), e._config.autohide && (e._timeout = setTimeout((function () { e.hide() }), e._config.delay)) }; if (this._element.classList.remove("hide"), v(this._element), this._element.classList.add("showing"), this._config.animation) { var i = d(this._element); $.one(this._element, "transitionend", t), f(this._element, i) } else t() } }, r.hide = function () { var e = this; if (this._element.classList.contains("show") && !$.trigger(this._element, "hide.bs.toast").defaultPrevented) { var t = function () { e._element.classList.add("hide"), $.trigger(e._element, "hidden.bs.toast") }; if (this._element.classList.remove("show"), this._config.animation) { var i = d(this._element); $.one(this._element, "transitionend", t), f(this._element, i) } else t() } }, r.dispose = function () { this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), $.off(this._element, "click.dismiss.bs.toast"), e.prototype.dispose.call(this), this._config = null }, r._getConfig = function (e) { return e = i({}, Gt, q.getDataAttributes(this._element), "object" == typeof e && e ? e : {}), h("toast", e, this.constructor.DefaultType), e }, r._setListeners = function () { var e = this; $.on(this._element, "click.dismiss.bs.toast", '[data-bs-dismiss="toast"]', (function () { return e.hide() })) }, r._clearTimeout = function () { clearTimeout(this._timeout), this._timeout = null }, s.jQueryInterface = function (e) { return this.each((function () { var t = x(this, "bs.toast"); if (t || (t = new s(this, "object" == typeof e && e)), "string" == typeof e) { if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"'); t[e](this) } })) }, t(s, null, [{ key: "DefaultType", get: function () { return Yt } }, { key: "Default", get: function () { return Gt } }, { key: "DATA_KEY", get: function () { return "bs.toast" } }]), s }(N); return b((function () { var e = y(); if (e) { var t = e.fn.toast; e.fn.toast = Xt.jQueryInterface, e.fn.toast.Constructor = Xt, e.fn.toast.noConflict = function () { return e.fn.toast = t, Xt.jQueryInterface } } })), { Alert: B, Button: W, Carousel: Q, Collapse: ee, Dropdown: yt, Modal: Et, Popover: Ht, ScrollSpy: Ft, Tab: qt, Toast: Xt, Tooltip: kt } })), function (e, t) { "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t() }("undefined" != typeof window ? window : this, (function () { function e() { } var t = e.prototype; return t.on = function (e, t) { if (e && t) { var i = this._events = this._events || {}, n = i[e] = i[e] || []; return -1 == n.indexOf(t) && n.push(t), this } }, t.once = function (e, t) { if (e && t) { this.on(e, t); var i = this._onceEvents = this._onceEvents || {}; return (i[e] = i[e] || {})[t] = !0, this } }, t.off = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { var n = i.indexOf(t); return -1 != n && i.splice(n, 1), this } }, t.emitEvent = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { i = i.slice(0), t = t || []; for (var n = this._onceEvents && this._onceEvents[e], s = 0; s < i.length; s++) { var r = i[s]; n && n[r] && (this.off(e, r), delete n[r]), r.apply(this, t) } return this } }, t.allOff = function () { delete this._events, delete this._onceEvents }, e })), function (e, t) { "use strict"; "function" == typeof define && define.amd ? define(["ev-emitter/ev-emitter"], (function (i) { return t(e, i) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter")) : e.imagesLoaded = t(e, e.EvEmitter) }("undefined" != typeof window ? window : this, (function (e, t) { function i(e, t) { for (var i in t) e[i] = t[i]; return e } function n(e, t, s) { if (!(this instanceof n)) return new n(e, t, s); var r, c = e; return "string" == typeof e && (c = document.querySelectorAll(e)), c ? (this.elements = (r = c, Array.isArray(r) ? r : "object" == typeof r && "number" == typeof r.length ? l.call(r) : [r]), this.options = i({}, this.options), "function" == typeof t ? s = t : i(this.options, t), s && this.on("always", s), this.getImages(), o && (this.jqDeferred = new o.Deferred), void setTimeout(this.check.bind(this))) : void a.error("Bad element for imagesLoaded " + (c || e)) } function s(e) { this.img = e } function r(e, t) { this.url = e, this.element = t, this.img = new Image } var o = e.jQuery, a = e.console, l = Array.prototype.slice; (n.prototype = Object.create(t.prototype)).options = {}, n.prototype.getImages = function () { this.images = [], this.elements.forEach(this.addElementImages, this) }, n.prototype.addElementImages = function (e) { "IMG" == e.nodeName && this.addImage(e), !0 === this.options.background && this.addElementBackgroundImages(e); var t = e.nodeType; if (t && c[t]) { for (var i = e.querySelectorAll("img"), n = 0; n < i.length; n++) { var s = i[n]; this.addImage(s) } if ("string" == typeof this.options.background) { var r = e.querySelectorAll(this.options.background); for (n = 0; n < r.length; n++) { var o = r[n]; this.addElementBackgroundImages(o) } } } }; var c = { 1: !0, 9: !0, 11: !0 }; return n.prototype.addElementBackgroundImages = function (e) { var t = getComputedStyle(e); if (t) for (var i = /url\((['"])?(.*?)\1\)/gi, n = i.exec(t.backgroundImage); null !== n;) { var s = n && n[2]; s && this.addBackground(s, e), n = i.exec(t.backgroundImage) } }, n.prototype.addImage = function (e) { var t = new s(e); this.images.push(t) }, n.prototype.addBackground = function (e, t) { var i = new r(e, t); this.images.push(i) }, n.prototype.check = function () { function e(e, i, n) { setTimeout((function () { t.progress(e, i, n) })) } var t = this; return this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? void this.images.forEach((function (t) { t.once("progress", e), t.check() })) : void this.complete() }, n.prototype.progress = function (e, t, i) { this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !e.isLoaded, this.emitEvent("progress", [this, e, t]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, e), this.progressedCount == this.images.length && this.complete(), this.options.debug && a && a.log("progress: " + i, e, t) }, n.prototype.complete = function () { var e = this.hasAnyBroken ? "fail" : "done"; if (this.isComplete = !0, this.emitEvent(e, [this]), this.emitEvent("always", [this]), this.jqDeferred) { var t = this.hasAnyBroken ? "reject" : "resolve"; this.jqDeferred[t](this) } }, (s.prototype = Object.create(t.prototype)).check = function () { return this.getIsImageComplete() ? void this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), void (this.proxyImage.src = this.img.src)) }, s.prototype.getIsImageComplete = function () { return this.img.complete && this.img.naturalWidth }, s.prototype.confirm = function (e, t) { this.isLoaded = e, this.emitEvent("progress", [this, this.img, t]) }, s.prototype.handleEvent = function (e) { var t = "on" + e.type; this[t] && this[t](e) }, s.prototype.onload = function () { this.confirm(!0, "onload"), this.unbindEvents() }, s.prototype.onerror = function () { this.confirm(!1, "onerror"), this.unbindEvents() }, s.prototype.unbindEvents = function () { this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, (r.prototype = Object.create(s.prototype)).check = function () { this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents()) }, r.prototype.unbindEvents = function () { this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, r.prototype.confirm = function (e, t) { this.isLoaded = e, this.emitEvent("progress", [this, this.element, t]) }, n.makeJQueryPlugin = function (t) { (t = t || e.jQuery) && ((o = t).fn.imagesLoaded = function (e, t) { return new n(this, e, t).jqDeferred.promise(o(this)) }) }, n.makeJQueryPlugin(), n })), function (e, t) { "function" == typeof define && define.amd ? define("jquery-bridget/jquery-bridget", ["jquery"], (function (i) { return t(e, i) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("jquery")) : e.jQueryBridget = t(e, e.jQuery) }(window, (function (e, t) { "use strict"; function i(i, r, a) { (a = a || t || e.jQuery) && (r.prototype.option || (r.prototype.option = function (e) { a.isPlainObject(e) && (this.options = a.extend(!0, this.options, e)) }), a.fn[i] = function (e) { if ("string" != typeof e) return u = e, this.each((function (e, t) { var n = a.data(t, i); n ? (n.option(u), n._init()) : (n = new r(t, u), a.data(t, i, n)) })), this; var t, n, l, c, d, u, p = s.call(arguments, 1); return l = p, d = "$()." + i + '("' + (n = e) + '")', (t = this).each((function (e, t) { var s = a.data(t, i); if (s) { var r = s[n]; if (r && "_" != n.charAt(0)) { var u = r.apply(s, l); c = void 0 === c ? u : c } else o(d + " is not a valid method") } else o(i + " not initialized. Cannot call methods, i.e. " + d) })), void 0 !== c ? c : t }, n(a)) } function n(e) { !e || e && e.bridget || (e.bridget = i) } var s = Array.prototype.slice, r = e.console, o = void 0 === r ? function () { } : function (e) { r.error(e) }; return n(t || e.jQuery), i })), function (e, t) { "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t() }("undefined" != typeof window ? window : this, (function () { function e() { } var t = e.prototype; return t.on = function (e, t) { if (e && t) { var i = this._events = this._events || {}, n = i[e] = i[e] || []; return -1 == n.indexOf(t) && n.push(t), this } }, t.once = function (e, t) { if (e && t) { this.on(e, t); var i = this._onceEvents = this._onceEvents || {}; return (i[e] = i[e] || {})[t] = !0, this } }, t.off = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { var n = i.indexOf(t); return -1 != n && i.splice(n, 1), this } }, t.emitEvent = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { i = i.slice(0), t = t || []; for (var n = this._onceEvents && this._onceEvents[e], s = 0; s < i.length; s++) { var r = i[s]; n && n[r] && (this.off(e, r), delete n[r]), r.apply(this, t) } return this } }, t.allOff = function () { delete this._events, delete this._onceEvents }, e })), function (e, t) { "function" == typeof define && define.amd ? define("get-size/get-size", t) : "object" == typeof module && module.exports ? module.exports = t() : e.getSize = t() }(window, (function () { "use strict"; function e(e) { var t = parseFloat(e); return -1 == e.indexOf("%") && !isNaN(t) && t } function t(e) { var t = getComputedStyle(e); return t || n("Style returned " + t + ". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1"), t } var i, n = "undefined" == typeof console ? function () { } : function (e) { console.error(e) }, s = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"], r = s.length, o = !1; return function n(a) { if (function () { if (!o) { o = !0; var s = document.createElement("div"); s.style.width = "200px", s.style.padding = "1px 2px 3px 4px", s.style.borderStyle = "solid", s.style.borderWidth = "1px 2px 3px 4px", s.style.boxSizing = "border-box"; var r = document.body || document.documentElement; r.appendChild(s); var a = t(s); i = 200 == Math.round(e(a.width)), n.isBoxSizeOuter = i, r.removeChild(s) } }(), "string" == typeof a && (a = document.querySelector(a)), a && "object" == typeof a && a.nodeType) { var l = t(a); if ("none" == l.display) return function () { for (var e = { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 }, t = 0; t < r; t++)e[s[t]] = 0; return e }(); var c = {}; c.width = a.offsetWidth, c.height = a.offsetHeight; for (var d = c.isBorderBox = "border-box" == l.boxSizing, u = 0; u < r; u++) { var p = s[u], f = l[p], h = parseFloat(f); c[p] = isNaN(h) ? 0 : h } var m = c.paddingLeft + c.paddingRight, g = c.paddingTop + c.paddingBottom, v = c.marginLeft + c.marginRight, y = c.marginTop + c.marginBottom, b = c.borderLeftWidth + c.borderRightWidth, w = c.borderTopWidth + c.borderBottomWidth, E = d && i, _ = e(l.width); !1 !== _ && (c.width = _ + (E ? 0 : m + b)); var x = e(l.height); return !1 !== x && (c.height = x + (E ? 0 : g + w)), c.innerWidth = c.width - (m + b), c.innerHeight = c.height - (g + w), c.outerWidth = c.width + v, c.outerHeight = c.height + y, c } } })), function (e, t) { "use strict"; "function" == typeof define && define.amd ? define("desandro-matches-selector/matches-selector", t) : "object" == typeof module && module.exports ? module.exports = t() : e.matchesSelector = t() }(window, (function () { "use strict"; var e = function () { var e = window.Element.prototype; if (e.matches) return "matches"; if (e.matchesSelector) return "matchesSelector"; for (var t = ["webkit", "moz", "ms", "o"], i = 0; i < t.length; i++) { var n = t[i] + "MatchesSelector"; if (e[n]) return n } }(); return function (t, i) { return t[e](i) } })), function (e, t) { "function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], (function (i) { return t(e, i) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("desandro-matches-selector")) : e.fizzyUIUtils = t(e, e.matchesSelector) }(window, (function (e, t) { var i = { extend: function (e, t) { for (var i in t) e[i] = t[i]; return e }, modulo: function (e, t) { return (e % t + t) % t } }, n = Array.prototype.slice; i.makeArray = function (e) { return Array.isArray(e) ? e : null == e ? [] : "object" == typeof e && "number" == typeof e.length ? n.call(e) : [e] }, i.removeFrom = function (e, t) { var i = e.indexOf(t); -1 != i && e.splice(i, 1) }, i.getParent = function (e, i) { for (; e.parentNode && e != document.body;)if (e = e.parentNode, t(e, i)) return e }, i.getQueryElement = function (e) { return "string" == typeof e ? document.querySelector(e) : e }, i.handleEvent = function (e) { var t = "on" + e.type; this[t] && this[t](e) }, i.filterFindElements = function (e, n) { e = i.makeArray(e); var s = []; return e.forEach((function (e) { if (e instanceof HTMLElement) { if (!n) return void s.push(e); t(e, n) && s.push(e); for (var i = e.querySelectorAll(n), r = 0; r < i.length; r++)s.push(i[r]) } })), s }, i.debounceMethod = function (e, t, i) { i = i || 100; var n = e.prototype[t], s = t + "Timeout"; e.prototype[t] = function () { var e = this[s]; clearTimeout(e); var t = arguments, r = this; this[s] = setTimeout((function () { n.apply(r, t), delete r[s] }), i) } }, i.docReady = function (e) { var t = document.readyState; "complete" == t || "interactive" == t ? setTimeout(e) : document.addEventListener("DOMContentLoaded", e) }, i.toDashed = function (e) { return e.replace(/(.)([A-Z])/g, (function (e, t, i) { return t + "-" + i })).toLowerCase() }; var s = e.console; return i.htmlInit = function (t, n) { i.docReady((function () { var r = i.toDashed(n), o = "data-" + r, a = document.querySelectorAll("[" + o + "]"), l = document.querySelectorAll(".js-" + r), c = i.makeArray(a).concat(i.makeArray(l)), d = o + "-options", u = e.jQuery; c.forEach((function (e) { var i, r = e.getAttribute(o) || e.getAttribute(d); try { i = r && JSON.parse(r) } catch (i) { return void (s && s.error("Error parsing " + o + " on " + e.className + ": " + i)) } var a = new t(e, i); u && u.data(e, n, a) })) })) }, i })), function (e, t) { "function" == typeof define && define.amd ? define("outlayer/item", ["ev-emitter/ev-emitter", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("ev-emitter"), require("get-size")) : (e.Outlayer = {}, e.Outlayer.Item = t(e.EvEmitter, e.getSize)) }(window, (function (e, t) { "use strict"; function i(e, t) { e && (this.element = e, this.layout = t, this.position = { x: 0, y: 0 }, this._create()) } var n = document.documentElement.style, s = "string" == typeof n.transition ? "transition" : "WebkitTransition", r = "string" == typeof n.transform ? "transform" : "WebkitTransform", o = { WebkitTransition: "webkitTransitionEnd", transition: "transitionend" }[s], a = { transform: r, transition: s, transitionDuration: s + "Duration", transitionProperty: s + "Property", transitionDelay: s + "Delay" }, l = i.prototype = Object.create(e.prototype); l.constructor = i, l._create = function () { this._transn = { ingProperties: {}, clean: {}, onEnd: {} }, this.css({ position: "absolute" }) }, l.handleEvent = function (e) { var t = "on" + e.type; this[t] && this[t](e) }, l.getSize = function () { this.size = t(this.element) }, l.css = function (e) { var t = this.element.style; for (var i in e) t[a[i] || i] = e[i] }, l.getPosition = function () { var e = getComputedStyle(this.element), t = this.layout._getOption("originLeft"), i = this.layout._getOption("originTop"), n = e[t ? "left" : "right"], s = e[i ? "top" : "bottom"], r = parseFloat(n), o = parseFloat(s), a = this.layout.size; -1 != n.indexOf("%") && (r = r / 100 * a.width), -1 != s.indexOf("%") && (o = o / 100 * a.height), r = isNaN(r) ? 0 : r, o = isNaN(o) ? 0 : o, r -= t ? a.paddingLeft : a.paddingRight, o -= i ? a.paddingTop : a.paddingBottom, this.position.x = r, this.position.y = o }, l.layoutPosition = function () { var e = this.layout.size, t = {}, i = this.layout._getOption("originLeft"), n = this.layout._getOption("originTop"), s = i ? "paddingLeft" : "paddingRight", r = i ? "left" : "right", o = i ? "right" : "left", a = this.position.x + e[s]; t[r] = this.getXValue(a), t[o] = ""; var l = n ? "paddingTop" : "paddingBottom", c = n ? "top" : "bottom", d = n ? "bottom" : "top", u = this.position.y + e[l]; t[c] = this.getYValue(u), t[d] = "", this.css(t), this.emitEvent("layout", [this]) }, l.getXValue = function (e) { var t = this.layout._getOption("horizontal"); return this.layout.options.percentPosition && !t ? e / this.layout.size.width * 100 + "%" : e + "px" }, l.getYValue = function (e) { var t = this.layout._getOption("horizontal"); return this.layout.options.percentPosition && t ? e / this.layout.size.height * 100 + "%" : e + "px" }, l._transitionTo = function (e, t) { this.getPosition(); var i = this.position.x, n = this.position.y, s = e == this.position.x && t == this.position.y; if (this.setPosition(e, t), !s || this.isTransitioning) { var r = e - i, o = t - n, a = {}; a.transform = this.getTranslate(r, o), this.transition({ to: a, onTransitionEnd: { transform: this.layoutPosition }, isCleaning: !0 }) } else this.layoutPosition() }, l.getTranslate = function (e, t) { return "translate3d(" + (e = this.layout._getOption("originLeft") ? e : -e) + "px, " + (t = this.layout._getOption("originTop") ? t : -t) + "px, 0)" }, l.goTo = function (e, t) { this.setPosition(e, t), this.layoutPosition() }, l.moveTo = l._transitionTo, l.setPosition = function (e, t) { this.position.x = parseFloat(e), this.position.y = parseFloat(t) }, l._nonTransition = function (e) { for (var t in this.css(e.to), e.isCleaning && this._removeStyles(e.to), e.onTransitionEnd) e.onTransitionEnd[t].call(this) }, l.transition = function (e) { if (parseFloat(this.layout.options.transitionDuration)) { var t = this._transn; for (var i in e.onTransitionEnd) t.onEnd[i] = e.onTransitionEnd[i]; for (i in e.to) t.ingProperties[i] = !0, e.isCleaning && (t.clean[i] = !0); e.from && (this.css(e.from), this.element.offsetHeight), this.enableTransition(e.to), this.css(e.to), this.isTransitioning = !0 } else this._nonTransition(e) }; var c = "opacity," + r.replace(/([A-Z])/g, (function (e) { return "-" + e.toLowerCase() })); l.enableTransition = function () { if (!this.isTransitioning) { var e = this.layout.options.transitionDuration; e = "number" == typeof e ? e + "ms" : e, this.css({ transitionProperty: c, transitionDuration: e, transitionDelay: this.staggerDelay || 0 }), this.element.addEventListener(o, this, !1) } }, l.onwebkitTransitionEnd = function (e) { this.ontransitionend(e) }, l.onotransitionend = function (e) { this.ontransitionend(e) }; var d = { "-webkit-transform": "transform" }; l.ontransitionend = function (e) { if (e.target === this.element) { var t = this._transn, i = d[e.propertyName] || e.propertyName; delete t.ingProperties[i], function (e) { for (var t in e) return !1; return !0 }(t.ingProperties) && this.disableTransition(), i in t.clean && (this.element.style[e.propertyName] = "", delete t.clean[i]), i in t.onEnd && (t.onEnd[i].call(this), delete t.onEnd[i]), this.emitEvent("transitionEnd", [this]) } }, l.disableTransition = function () { this.removeTransitionStyles(), this.element.removeEventListener(o, this, !1), this.isTransitioning = !1 }, l._removeStyles = function (e) { var t = {}; for (var i in e) t[i] = ""; this.css(t) }; var u = { transitionProperty: "", transitionDuration: "", transitionDelay: "" }; return l.removeTransitionStyles = function () { this.css(u) }, l.stagger = function (e) { e = isNaN(e) ? 0 : e, this.staggerDelay = e + "ms" }, l.removeElem = function () { this.element.parentNode.removeChild(this.element), this.css({ display: "" }), this.emitEvent("remove", [this]) }, l.remove = function () { return s && parseFloat(this.layout.options.transitionDuration) ? (this.once("transitionEnd", (function () { this.removeElem() })), void this.hide()) : void this.removeElem() }, l.reveal = function () { delete this.isHidden, this.css({ display: "" }); var e = this.layout.options, t = {}; t[this.getHideRevealTransitionEndProperty("visibleStyle")] = this.onRevealTransitionEnd, this.transition({ from: e.hiddenStyle, to: e.visibleStyle, isCleaning: !0, onTransitionEnd: t }) }, l.onRevealTransitionEnd = function () { this.isHidden || this.emitEvent("reveal") }, l.getHideRevealTransitionEndProperty = function (e) { var t = this.layout.options[e]; if (t.opacity) return "opacity"; for (var i in t) return i }, l.hide = function () { this.isHidden = !0, this.css({ display: "" }); var e = this.layout.options, t = {}; t[this.getHideRevealTransitionEndProperty("hiddenStyle")] = this.onHideTransitionEnd, this.transition({ from: e.visibleStyle, to: e.hiddenStyle, isCleaning: !0, onTransitionEnd: t }) }, l.onHideTransitionEnd = function () { this.isHidden && (this.css({ display: "none" }), this.emitEvent("hide")) }, l.destroy = function () { this.css({ position: "", left: "", right: "", top: "", bottom: "", transition: "", transform: "" }) }, i })), function (e, t) { "use strict"; "function" == typeof define && define.amd ? define("outlayer/outlayer", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item"], (function (i, n, s, r) { return t(e, i, n, s, r) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./item")) : e.Outlayer = t(e, e.EvEmitter, e.getSize, e.fizzyUIUtils, e.Outlayer.Item) }(window, (function (e, t, i, n, s) { "use strict"; function r(e, t) { var i = n.getQueryElement(e); if (i) { this.element = i, l && (this.$element = l(this.element)), this.options = n.extend({}, this.constructor.defaults), this.option(t); var s = ++d; this.element.outlayerGUID = s, (u[s] = this)._create(), this._getOption("initLayout") && this.layout() } else a && a.error("Bad element for " + this.constructor.namespace + ": " + (i || e)) } function o(e) { function t() { e.apply(this, arguments) } return (t.prototype = Object.create(e.prototype)).constructor = t } var a = e.console, l = e.jQuery, c = function () { }, d = 0, u = {}; r.namespace = "outlayer", r.Item = s, r.defaults = { containerStyle: { position: "relative" }, initLayout: !0, originLeft: !0, originTop: !0, resize: !0, resizeContainer: !0, transitionDuration: "0.4s", hiddenStyle: { opacity: 0, transform: "scale(0.001)" }, visibleStyle: { opacity: 1, transform: "scale(1)" } }; var p = r.prototype; n.extend(p, t.prototype), p.option = function (e) { n.extend(this.options, e) }, p._getOption = function (e) { var t = this.constructor.compatOptions[e]; return t && void 0 !== this.options[t] ? this.options[t] : this.options[e] }, r.compatOptions = { initLayout: "isInitLayout", horizontal: "isHorizontal", layoutInstant: "isLayoutInstant", originLeft: "isOriginLeft", originTop: "isOriginTop", resize: "isResizeBound", resizeContainer: "isResizingContainer" }, p._create = function () { this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this.element.style, this.options.containerStyle), this._getOption("resize") && this.bindResize() }, p.reloadItems = function () { this.items = this._itemize(this.element.children) }, p._itemize = function (e) { for (var t = this._filterFindItemElements(e), i = this.constructor.Item, n = [], s = 0; s < t.length; s++) { var r = new i(t[s], this); n.push(r) } return n }, p._filterFindItemElements = function (e) { return n.filterFindElements(e, this.options.itemSelector) }, p.getItemElements = function () { return this.items.map((function (e) { return e.element })) }, p.layout = function () { this._resetLayout(), this._manageStamps(); var e = this._getOption("layoutInstant"), t = void 0 !== e ? e : !this._isLayoutInited; this.layoutItems(this.items, t), this._isLayoutInited = !0 }, p._init = p.layout, p._resetLayout = function () { this.getSize() }, p.getSize = function () { this.size = i(this.element) }, p._getMeasurement = function (e, t) { var n, s = this.options[e]; s ? ("string" == typeof s ? n = this.element.querySelector(s) : s instanceof HTMLElement && (n = s), this[e] = n ? i(n)[t] : s) : this[e] = 0 }, p.layoutItems = function (e, t) { e = this._getItemsForLayout(e), this._layoutItems(e, t), this._postLayout() }, p._getItemsForLayout = function (e) { return e.filter((function (e) { return !e.isIgnored })) }, p._layoutItems = function (e, t) { if (this._emitCompleteOnItems("layout", e), e && e.length) { var i = []; e.forEach((function (e) { var n = this._getItemLayoutPosition(e); n.item = e, n.isInstant = t || e.isLayoutInstant, i.push(n) }), this), this._processLayoutQueue(i) } }, p._getItemLayoutPosition = function () { return { x: 0, y: 0 } }, p._processLayoutQueue = function (e) { this.updateStagger(), e.forEach((function (e, t) { this._positionItem(e.item, e.x, e.y, e.isInstant, t) }), this) }, p.updateStagger = function () { var e = this.options.stagger; return null == e ? void (this.stagger = 0) : (this.stagger = function (e) { if ("number" == typeof e) return e; var t = e.match(/(^\d*\.?\d*)(\w*)/), i = t && t[1], n = t && t[2]; return i.length ? (i = parseFloat(i)) * (f[n] || 1) : 0 }(e), this.stagger) }, p._positionItem = function (e, t, i, n, s) { n ? e.goTo(t, i) : (e.stagger(s * this.stagger), e.moveTo(t, i)) }, p._postLayout = function () { this.resizeContainer() }, p.resizeContainer = function () { if (this._getOption("resizeContainer")) { var e = this._getContainerSize(); e && (this._setContainerMeasure(e.width, !0), this._setContainerMeasure(e.height, !1)) } }, p._getContainerSize = c, p._setContainerMeasure = function (e, t) { if (void 0 !== e) { var i = this.size; i.isBorderBox && (e += t ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), e = Math.max(e, 0), this.element.style[t ? "width" : "height"] = e + "px" } }, p._emitCompleteOnItems = function (e, t) { function i() { s.dispatchEvent(e + "Complete", null, [t]) } function n() { ++o == r && i() } var s = this, r = t.length; if (t && r) { var o = 0; t.forEach((function (t) { t.once(e, n) })) } else i() }, p.dispatchEvent = function (e, t, i) { var n = t ? [t].concat(i) : i; if (this.emitEvent(e, n), l) if (this.$element = this.$element || l(this.element), t) { var s = l.Event(t); s.type = e, this.$element.trigger(s, i) } else this.$element.trigger(e, i) }, p.ignore = function (e) { var t = this.getItem(e); t && (t.isIgnored = !0) }, p.unignore = function (e) { var t = this.getItem(e); t && delete t.isIgnored }, p.stamp = function (e) { (e = this._find(e)) && (this.stamps = this.stamps.concat(e), e.forEach(this.ignore, this)) }, p.unstamp = function (e) { (e = this._find(e)) && e.forEach((function (e) { n.removeFrom(this.stamps, e), this.unignore(e) }), this) }, p._find = function (e) { if (e) return "string" == typeof e && (e = this.element.querySelectorAll(e)), n.makeArray(e) }, p._manageStamps = function () { this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this)) }, p._getBoundingRect = function () { var e = this.element.getBoundingClientRect(), t = this.size; this._boundingRect = { left: e.left + t.paddingLeft + t.borderLeftWidth, top: e.top + t.paddingTop + t.borderTopWidth, right: e.right - (t.paddingRight + t.borderRightWidth), bottom: e.bottom - (t.paddingBottom + t.borderBottomWidth) } }, p._manageStamp = c, p._getElementOffset = function (e) { var t = e.getBoundingClientRect(), n = this._boundingRect, s = i(e); return { left: t.left - n.left - s.marginLeft, top: t.top - n.top - s.marginTop, right: n.right - t.right - s.marginRight, bottom: n.bottom - t.bottom - s.marginBottom } }, p.handleEvent = n.handleEvent, p.bindResize = function () { e.addEventListener("resize", this), this.isResizeBound = !0 }, p.unbindResize = function () { e.removeEventListener("resize", this), this.isResizeBound = !1 }, p.onresize = function () { this.resize() }, n.debounceMethod(r, "onresize", 100), p.resize = function () { this.isResizeBound && this.needsResizeLayout() && this.layout() }, p.needsResizeLayout = function () { var e = i(this.element); return this.size && e && e.innerWidth !== this.size.innerWidth }, p.addItems = function (e) { var t = this._itemize(e); return t.length && (this.items = this.items.concat(t)), t }, p.appended = function (e) { var t = this.addItems(e); t.length && (this.layoutItems(t, !0), this.reveal(t)) }, p.prepended = function (e) { var t = this._itemize(e); if (t.length) { var i = this.items.slice(0); this.items = t.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(t, !0), this.reveal(t), this.layoutItems(i) } }, p.reveal = function (e) { if (this._emitCompleteOnItems("reveal", e), e && e.length) { var t = this.updateStagger(); e.forEach((function (e, i) { e.stagger(i * t), e.reveal() })) } }, p.hide = function (e) { if (this._emitCompleteOnItems("hide", e), e && e.length) { var t = this.updateStagger(); e.forEach((function (e, i) { e.stagger(i * t), e.hide() })) } }, p.revealItemElements = function (e) { var t = this.getItems(e); this.reveal(t) }, p.hideItemElements = function (e) { var t = this.getItems(e); this.hide(t) }, p.getItem = function (e) { for (var t = 0; t < this.items.length; t++) { var i = this.items[t]; if (i.element == e) return i } }, p.getItems = function (e) { e = n.makeArray(e); var t = []; return e.forEach((function (e) { var i = this.getItem(e); i && t.push(i) }), this), t }, p.remove = function (e) { var t = this.getItems(e); this._emitCompleteOnItems("remove", t), t && t.length && t.forEach((function (e) { e.remove(), n.removeFrom(this.items, e) }), this) }, p.destroy = function () { var e = this.element.style; e.height = "", e.position = "", e.width = "", this.items.forEach((function (e) { e.destroy() })), this.unbindResize(); var t = this.element.outlayerGUID; delete u[t], delete this.element.outlayerGUID, l && l.removeData(this.element, this.constructor.namespace) }, r.data = function (e) { var t = (e = n.getQueryElement(e)) && e.outlayerGUID; return t && u[t] }, r.create = function (e, t) { var i = o(r); return i.defaults = n.extend({}, r.defaults), n.extend(i.defaults, t), i.compatOptions = n.extend({}, r.compatOptions), i.namespace = e, i.data = r.data, i.Item = o(s), n.htmlInit(i, e), l && l.bridget && l.bridget(e, i), i }; var f = { ms: 1, s: 1e3 }; return r.Item = s, r })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/item", ["outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.Item = t(e.Outlayer)) }(window, (function (e) { "use strict"; function t() { e.Item.apply(this, arguments) } var i = t.prototype = Object.create(e.Item.prototype), n = i._create; i._create = function () { this.id = this.layout.itemGUID++, n.call(this), this.sortData = {} }, i.updateSortData = function () { if (!this.isIgnored) { this.sortData.id = this.id, this.sortData["original-order"] = this.id, this.sortData.random = Math.random(); var e = this.layout.options.getSortData, t = this.layout._sorters; for (var i in e) { var n = t[i]; this.sortData[i] = n(this.element, this) } } }; var s = i.destroy; return i.destroy = function () { s.apply(this, arguments), this.css({ display: "" }) }, t })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/layout-mode", ["get-size/get-size", "outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("get-size"), require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.LayoutMode = t(e.getSize, e.Outlayer)) }(window, (function (e, t) { "use strict"; function i(e) { (this.isotope = e) && (this.options = e.options[this.namespace], this.element = e.element, this.items = e.filteredItems, this.size = e.size) } var n = i.prototype; return ["_resetLayout", "_getItemLayoutPosition", "_manageStamp", "_getContainerSize", "_getElementOffset", "needsResizeLayout", "_getOption"].forEach((function (e) { n[e] = function () { return t.prototype[e].apply(this.isotope, arguments) } })), n.needsVerticalResizeLayout = function () { var t = e(this.isotope.element); return this.isotope.size && t && t.innerHeight != this.isotope.size.innerHeight }, n._getMeasurement = function () { this.isotope._getMeasurement.apply(this, arguments) }, n.getColumnWidth = function () { this.getSegmentSize("column", "Width") }, n.getRowHeight = function () { this.getSegmentSize("row", "Height") }, n.getSegmentSize = function (e, t) { var i = e + t, n = "outer" + t; if (this._getMeasurement(i, n), !this[i]) { var s = this.getFirstItemSize(); this[i] = s && s[n] || this.isotope.size["inner" + t] } }, n.getFirstItemSize = function () { var t = this.isotope.filteredItems[0]; return t && t.element && e(t.element) }, n.layout = function () { this.isotope.layout.apply(this.isotope, arguments) }, n.getSize = function () { this.isotope.getSize(), this.size = this.isotope.size }, i.modes = {}, i.create = function (e, t) { function s() { i.apply(this, arguments) } return (s.prototype = Object.create(n)).constructor = s, t && (s.options = t), i.modes[s.prototype.namespace = e] = s }, i })), function (e, t) { "function" == typeof define && define.amd ? define("masonry-layout/masonry", ["outlayer/outlayer", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer"), require("get-size")) : e.Masonry = t(e.Outlayer, e.getSize) }(window, (function (e, t) { var i = e.create("masonry"); i.compatOptions.fitWidth = "isFitWidth"; var n = i.prototype; return n._resetLayout = function () { this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), this.measureColumns(), this.colYs = []; for (var e = 0; e < this.cols; e++)this.colYs.push(0); this.maxY = 0, this.horizontalColIndex = 0 }, n.measureColumns = function () { if (this.getContainerWidth(), !this.columnWidth) { var e = this.items[0], i = e && e.element; this.columnWidth = i && t(i).outerWidth || this.containerWidth } var n = this.columnWidth += this.gutter, s = this.containerWidth + this.gutter, r = s / n, o = n - s % n; r = Math[o && o < 1 ? "round" : "floor"](r), this.cols = Math.max(r, 1) }, n.getContainerWidth = function () { var e = this._getOption("fitWidth") ? this.element.parentNode : this.element, i = t(e); this.containerWidth = i && i.innerWidth }, n._getItemLayoutPosition = function (e) { e.getSize(); var t = e.size.outerWidth % this.columnWidth, i = Math[t && t < 1 ? "round" : "ceil"](e.size.outerWidth / this.columnWidth); i = Math.min(i, this.cols); for (var n = this[this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition"](i, e), s = { x: this.columnWidth * n.col, y: n.y }, r = n.y + e.size.outerHeight, o = i + n.col, a = n.col; a < o; a++)this.colYs[a] = r; return s }, n._getTopColPosition = function (e) { var t = this._getTopColGroup(e), i = Math.min.apply(Math, t); return { col: t.indexOf(i), y: i } }, n._getTopColGroup = function (e) { if (e < 2) return this.colYs; for (var t = [], i = this.cols + 1 - e, n = 0; n < i; n++)t[n] = this._getColGroupY(n, e); return t }, n._getColGroupY = function (e, t) { if (t < 2) return this.colYs[e]; var i = this.colYs.slice(e, e + t); return Math.max.apply(Math, i) }, n._getHorizontalColPosition = function (e, t) { var i = this.horizontalColIndex % this.cols; i = 1 < e && i + e > this.cols ? 0 : i; var n = t.size.outerWidth && t.size.outerHeight; return this.horizontalColIndex = n ? i + e : this.horizontalColIndex, { col: i, y: this._getColGroupY(i, e) } }, n._manageStamp = function (e) { var i = t(e), n = this._getElementOffset(e), s = this._getOption("originLeft") ? n.left : n.right, r = s + i.outerWidth, o = Math.floor(s / this.columnWidth); o = Math.max(0, o); var a = Math.floor(r / this.columnWidth); a -= r % this.columnWidth ? 0 : 1, a = Math.min(this.cols - 1, a); for (var l = (this._getOption("originTop") ? n.top : n.bottom) + i.outerHeight, c = o; c <= a; c++)this.colYs[c] = Math.max(l, this.colYs[c]) }, n._getContainerSize = function () { this.maxY = Math.max.apply(Math, this.colYs); var e = { height: this.maxY }; return this._getOption("fitWidth") && (e.width = this._getContainerFitWidth()), e }, n._getContainerFitWidth = function () { for (var e = 0, t = this.cols; --t && 0 === this.colYs[t];)e++; return (this.cols - e) * this.columnWidth - this.gutter }, n.needsResizeLayout = function () { var e = this.containerWidth; return this.getContainerWidth(), e != this.containerWidth }, i })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/masonry", ["../layout-mode", "masonry-layout/masonry"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode"), require("masonry-layout")) : t(e.Isotope.LayoutMode, e.Masonry) }(window, (function (e, t) { "use strict"; var i = e.create("masonry"), n = i.prototype, s = { _getElementOffset: !0, layout: !0, _getMeasurement: !0 }; for (var r in t.prototype) s[r] || (n[r] = t.prototype[r]); var o = n.measureColumns; n.measureColumns = function () { this.items = this.isotope.filteredItems, o.call(this) }; var a = n._getOption; return n._getOption = function (e) { return "fitWidth" == e ? void 0 !== this.options.isFitWidth ? this.options.isFitWidth : this.options.fitWidth : a.apply(this.isotope, arguments) }, i })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/fit-rows", ["../layout-mode"], t) : "object" == typeof exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode) }(window, (function (e) { "use strict"; var t = e.create("fitRows"), i = t.prototype; return i._resetLayout = function () { this.x = 0, this.y = 0, this.maxY = 0, this._getMeasurement("gutter", "outerWidth") }, i._getItemLayoutPosition = function (e) { e.getSize(); var t = e.size.outerWidth + this.gutter, i = this.isotope.size.innerWidth + this.gutter; 0 !== this.x && t + this.x > i && (this.x = 0, this.y = this.maxY); var n = { x: this.x, y: this.y }; return this.maxY = Math.max(this.maxY, this.y + e.size.outerHeight), this.x += t, n }, i._getContainerSize = function () { return { height: this.maxY } }, t })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/vertical", ["../layout-mode"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode) }(window, (function (e) { "use strict"; var t = e.create("vertical", { horizontalAlignment: 0 }), i = t.prototype; return i._resetLayout = function () { this.y = 0 }, i._getItemLayoutPosition = function (e) { e.getSize(); var t = (this.isotope.size.innerWidth - e.size.outerWidth) * this.options.horizontalAlignment, i = this.y; return this.y += e.size.outerHeight, { x: t, y: i } }, i._getContainerSize = function () { return { height: this.y } }, t })), function (e, t) { "function" == typeof define && define.amd ? define(["outlayer/outlayer", "get-size/get-size", "desandro-matches-selector/matches-selector", "fizzy-ui-utils/utils", "isotope-layout/js/item", "isotope-layout/js/layout-mode", "isotope-layout/js/layout-modes/masonry", "isotope-layout/js/layout-modes/fit-rows", "isotope-layout/js/layout-modes/vertical"], (function (i, n, s, r, o, a) { return t(e, i, n, s, r, o, a) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("outlayer"), require("get-size"), require("desandro-matches-selector"), require("fizzy-ui-utils"), require("isotope-layout/js/item"), require("isotope-layout/js/layout-mode"), require("isotope-layout/js/layout-modes/masonry"), require("isotope-layout/js/layout-modes/fit-rows"), require("isotope-layout/js/layout-modes/vertical")) : e.Isotope = t(e, e.Outlayer, e.getSize, e.matchesSelector, e.fizzyUIUtils, e.Isotope.Item, e.Isotope.LayoutMode) }(window, (function (e, t, i, n, s, r, o) { var a = e.jQuery, l = String.prototype.trim ? function (e) { return e.trim() } : function (e) { return e.replace(/^\s+|\s+$/g, "") }, c = t.create("isotope", { layoutMode: "masonry", isJQueryFiltering: !0, sortAscending: !0 }); c.Item = r, c.LayoutMode = o; var d = c.prototype; d._create = function () { for (var e in this.itemGUID = 0, this._sorters = {}, this._getSorters(), t.prototype._create.call(this), this.modes = {}, this.filteredItems = this.items, this.sortHistory = ["original-order"], o.modes) this._initLayoutMode(e) }, d.reloadItems = function () { this.itemGUID = 0, t.prototype.reloadItems.call(this) }, d._itemize = function () { for (var e = t.prototype._itemize.apply(this, arguments), i = 0; i < e.length; i++)e[i].id = this.itemGUID++; return this._updateItemsSortData(e), e }, d._initLayoutMode = function (e) { var t = o.modes[e], i = this.options[e] || {}; this.options[e] = t.options ? s.extend(t.options, i) : i, this.modes[e] = new t(this) }, d.layout = function () { return !this._isLayoutInited && this._getOption("initLayout") ? void this.arrange() : void this._layout() }, d._layout = function () { var e = this._getIsInstant(); this._resetLayout(), this._manageStamps(), this.layoutItems(this.filteredItems, e), this._isLayoutInited = !0 }, d.arrange = function (e) { this.option(e), this._getIsInstant(); var t = this._filter(this.items); this.filteredItems = t.matches, this._bindArrangeComplete(), this._isInstant ? this._noTransition(this._hideReveal, [t]) : this._hideReveal(t), this._sort(), this._layout() }, d._init = d.arrange, d._hideReveal = function (e) { this.reveal(e.needReveal), this.hide(e.needHide) }, d._getIsInstant = function () { var e = this._getOption("layoutInstant"), t = void 0 !== e ? e : !this._isLayoutInited; return this._isInstant = t }, d._bindArrangeComplete = function () { function e() { t && i && n && s.dispatchEvent("arrangeComplete", null, [s.filteredItems]) } var t, i, n, s = this; this.once("layoutComplete", (function () { t = !0, e() })), this.once("hideComplete", (function () { i = !0, e() })), this.once("revealComplete", (function () { n = !0, e() })) }, d._filter = function (e) { var t = this.options.filter; t = t || "*"; for (var i = [], n = [], s = [], r = this._getFilterTest(t), o = 0; o < e.length; o++) { var a = e[o]; if (!a.isIgnored) { var l = r(a); l && i.push(a), l && a.isHidden ? n.push(a) : l || a.isHidden || s.push(a) } } return { matches: i, needReveal: n, needHide: s } }, d._getFilterTest = function (e) { return a && this.options.isJQueryFiltering ? function (t) { return a(t.element).is(e) } : "function" == typeof e ? function (t) { return e(t.element) } : function (t) { return n(t.element, e) } }, d.updateSortData = function (e) { var t; t = e ? (e = s.makeArray(e), this.getItems(e)) : this.items, this._getSorters(), this._updateItemsSortData(t) }, d._getSorters = function () { var e = this.options.getSortData; for (var t in e) { var i = e[t]; this._sorters[t] = u(i) } }, d._updateItemsSortData = function (e) { for (var t = e && e.length, i = 0; t && i < t; i++)e[i].updateSortData() }; var u = function (e) { if ("string" != typeof e) return e; var t, i, n = l(e).split(" "), s = n[0], r = s.match(/^\[(.+)\]$/), o = r && r[1], a = (i = s, (t = o) ? function (e) { return e.getAttribute(t) } : function (e) { var t = e.querySelector(i); return t && t.textContent }), d = c.sortDataParsers[n[1]]; return d ? function (e) { return e && d(a(e)) } : function (e) { return e && a(e) } }; c.sortDataParsers = { parseInt: function (e) { return parseInt(e, 10) }, parseFloat: function (e) { return parseFloat(e) } }, d._sort = function () { if (this.options.sortBy) { var e = s.makeArray(this.options.sortBy); this._getIsSameSortBy(e) || (this.sortHistory = e.concat(this.sortHistory)); var t = (i = this.sortHistory, n = this.options.sortAscending, function (e, t) { for (var s = 0; s < i.length; s++) { var r = i[s], o = e.sortData[r], a = t.sortData[r]; if (a < o || o < a) return (a < o ? 1 : -1) * ((void 0 !== n[r] ? n[r] : n) ? 1 : -1) } return 0 }); this.filteredItems.sort(t) } var i, n }, d._getIsSameSortBy = function (e) { for (var t = 0; t < e.length; t++)if (e[t] != this.sortHistory[t]) return !1; return !0 }, d._mode = function () { var e = this.options.layoutMode, t = this.modes[e]; if (!t) throw new Error("No layout mode: " + e); return t.options = this.options[e], t }, d._resetLayout = function () { t.prototype._resetLayout.call(this), this._mode()._resetLayout() }, d._getItemLayoutPosition = function (e) { return this._mode()._getItemLayoutPosition(e) }, d._manageStamp = function (e) { this._mode()._manageStamp(e) }, d._getContainerSize = function () { return this._mode()._getContainerSize() }, d.needsResizeLayout = function () { return this._mode().needsResizeLayout() }, d.appended = function (e) { var t = this.addItems(e); if (t.length) { var i = this._filterRevealAdded(t); this.filteredItems = this.filteredItems.concat(i) } }, d.prepended = function (e) { var t = this._itemize(e); if (t.length) { this._resetLayout(), this._manageStamps(); var i = this._filterRevealAdded(t); this.layoutItems(this.filteredItems), this.filteredItems = i.concat(this.filteredItems), this.items = t.concat(this.items) } }, d._filterRevealAdded = function (e) { var t = this._filter(e); return this.hide(t.needHide), this.reveal(t.matches), this.layoutItems(t.matches, !0), t.matches }, d.insert = function (e) { var t = this.addItems(e); if (t.length) { var i, n, s = t.length; for (i = 0; i < s; i++)n = t[i], this.element.appendChild(n.element); var r = this._filter(t).matches; for (i = 0; i < s; i++)t[i].isLayoutInstant = !0; for (this.arrange(), i = 0; i < s; i++)delete t[i].isLayoutInstant; this.reveal(r) } }; var p = d.remove; return d.remove = function (e) { e = s.makeArray(e); var t = this.getItems(e); p.call(this, e); for (var i = t && t.length, n = 0; i && n < i; n++) { var r = t[n]; s.removeFrom(this.filteredItems, r) } }, d.shuffle = function () { for (var e = 0; e < this.items.length; e++)this.items[e].sortData.random = Math.random(); this.options.sortBy = "random", this._sort(), this._layout() }, d._noTransition = function (e, t) { var i = this.options.transitionDuration; this.options.transitionDuration = 0; var n = e.apply(this, t); return this.options.transitionDuration = i, n }, d.getFilteredItemElements = function () { return this.filteredItems.map((function (e) { return e.element })) }, c })), function () { "use strict"; function e(n) { if (!n) throw new Error("No options passed to Waypoint constructor"); if (!n.element) throw new Error("No element option passed to Waypoint constructor"); if (!n.handler) throw new Error("No handler option passed to Waypoint constructor"); this.key = "waypoint-" + t, this.options = e.Adapter.extend({}, e.defaults, n), this.element = this.options.element, this.adapter = new e.Adapter(this.element), this.callback = n.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = e.Group.findOrCreate({ name: this.options.group, axis: this.axis }), this.context = e.Context.findOrCreateByElement(this.options.context), e.offsetAliases[this.options.offset] && (this.options.offset = e.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, t += 1 } var t = 0, i = {}; e.prototype.queueTrigger = function (e) { this.group.queueTrigger(this, e) }, e.prototype.trigger = function (e) { this.enabled && this.callback && this.callback.apply(this, e) }, e.prototype.destroy = function () { this.context.remove(this), this.group.remove(this), delete i[this.key] }, e.prototype.disable = function () { return this.enabled = !1, this }, e.prototype.enable = function () { return this.context.refresh(), this.enabled = !0, this }, e.prototype.next = function () { return this.group.next(this) }, e.prototype.previous = function () { return this.group.previous(this) }, e.invokeAll = function (e) { var t = []; for (var n in i) t.push(i[n]); for (var s = 0, r = t.length; r > s; s++)t[s][e]() }, e.destroyAll = function () { e.invokeAll("destroy") }, e.disableAll = function () { e.invokeAll("disable") }, e.enableAll = function () { e.invokeAll("enable") }, e.refreshAll = function () { e.Context.refreshAll() }, e.viewportHeight = function () { return window.innerHeight || document.documentElement.clientHeight }, e.viewportWidth = function () { return document.documentElement.clientWidth }, e.adapters = [], e.defaults = { context: window, continuous: !0, enabled: !0, group: "default", horizontal: !1, offset: 0 }, e.offsetAliases = { "bottom-in-view": function () { return this.context.innerHeight() - this.adapter.outerHeight() }, "right-in-view": function () { return this.context.innerWidth() - this.adapter.outerWidth() } }, window.Waypoint = e }(), function () { "use strict"; function e(e) { window.setTimeout(e, 1e3 / 60) } function t(e) { this.element = e, this.Adapter = s.Adapter, this.adapter = new this.Adapter(e), this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = { x: this.adapter.scrollLeft(), y: this.adapter.scrollTop() }, this.waypoints = { vertical: {}, horizontal: {} }, e.waypointContextKey = this.key, n[e.waypointContextKey] = this, i += 1, this.createThrottledScrollHandler(), this.createThrottledResizeHandler() } var i = 0, n = {}, s = window.Waypoint, r = window.onload; t.prototype.add = function (e) { var t = e.options.horizontal ? "horizontal" : "vertical"; this.waypoints[t][e.key] = e, this.refresh() }, t.prototype.checkEmpty = function () { var e = this.Adapter.isEmptyObject(this.waypoints.horizontal), t = this.Adapter.isEmptyObject(this.waypoints.vertical); e && t && (this.adapter.off(".waypoints"), delete n[this.key]) }, t.prototype.createThrottledResizeHandler = function () { function e() { t.handleResize(), t.didResize = !1 } var t = this; this.adapter.on("resize.waypoints", (function () { t.didResize || (t.didResize = !0, s.requestAnimationFrame(e)) })) }, t.prototype.createThrottledScrollHandler = function () { function e() { t.handleScroll(), t.didScroll = !1 } var t = this; this.adapter.on("scroll.waypoints", (function () { (!t.didScroll || s.isTouch) && (t.didScroll = !0, s.requestAnimationFrame(e)) })) }, t.prototype.handleResize = function () { s.Context.refreshAll() }, t.prototype.handleScroll = function () { var e = {}, t = { horizontal: { newScroll: this.adapter.scrollLeft(), oldScroll: this.oldScroll.x, forward: "right", backward: "left" }, vertical: { newScroll: this.adapter.scrollTop(), oldScroll: this.oldScroll.y, forward: "down", backward: "up" } }; for (var i in t) { var n = t[i], s = n.newScroll > n.oldScroll ? n.forward : n.backward; for (var r in this.waypoints[i]) { var o = this.waypoints[i][r], a = n.oldScroll < o.triggerPoint, l = n.newScroll >= o.triggerPoint; (a && l || !a && !l) && (o.queueTrigger(s), e[o.group.id] = o.group) } } for (var c in e) e[c].flushTriggers(); this.oldScroll = { x: t.horizontal.newScroll, y: t.vertical.newScroll } }, t.prototype.innerHeight = function () { return this.element == this.element.window ? s.viewportHeight() : this.adapter.innerHeight() }, t.prototype.remove = function (e) { delete this.waypoints[e.axis][e.key], this.checkEmpty() }, t.prototype.innerWidth = function () { return this.element == this.element.window ? s.viewportWidth() : this.adapter.innerWidth() }, t.prototype.destroy = function () { var e = []; for (var t in this.waypoints) for (var i in this.waypoints[t]) e.push(this.waypoints[t][i]); for (var n = 0, s = e.length; s > n; n++)e[n].destroy() }, t.prototype.refresh = function () { var e, t = this.element == this.element.window, i = t ? void 0 : this.adapter.offset(), n = {}; for (var r in this.handleScroll(), e = { horizontal: { contextOffset: t ? 0 : i.left, contextScroll: t ? 0 : this.oldScroll.x, contextDimension: this.innerWidth(), oldScroll: this.oldScroll.x, forward: "right", backward: "left", offsetProp: "left" }, vertical: { contextOffset: t ? 0 : i.top, contextScroll: t ? 0 : this.oldScroll.y, contextDimension: this.innerHeight(), oldScroll: this.oldScroll.y, forward: "down", backward: "up", offsetProp: "top" } }) { var o = e[r]; for (var a in this.waypoints[r]) { var l, c, d, u, p = this.waypoints[r][a], f = p.options.offset, h = p.triggerPoint, m = 0, g = null == h; p.element !== p.element.window && (m = p.adapter.offset()[o.offsetProp]), "function" == typeof f ? f = f.apply(p) : "string" == typeof f && (f = parseFloat(f), p.options.offset.indexOf("%") > -1 && (f = Math.ceil(o.contextDimension * f / 100))), l = o.contextScroll - o.contextOffset, p.triggerPoint = m + l - f, c = h < o.oldScroll, d = p.triggerPoint >= o.oldScroll, u = !c && !d, !g && (c && d) ? (p.queueTrigger(o.backward), n[p.group.id] = p.group) : (!g && u || g && o.oldScroll >= p.triggerPoint) && (p.queueTrigger(o.forward), n[p.group.id] = p.group) } } return s.requestAnimationFrame((function () { for (var e in n) n[e].flushTriggers() })), this }, t.findOrCreateByElement = function (e) { return t.findByElement(e) || new t(e) }, t.refreshAll = function () { for (var e in n) n[e].refresh() }, t.findByElement = function (e) { return n[e.waypointContextKey] }, window.onload = function () { r && r(), t.refreshAll() }, s.requestAnimationFrame = function (t) { (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || e).call(window, t) }, s.Context = t }(), function () { "use strict"; function e(e, t) { return e.triggerPoint - t.triggerPoint } function t(e, t) { return t.triggerPoint - e.triggerPoint } function i(e) { this.name = e.name, this.axis = e.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), n[this.axis][this.name] = this } var n = { vertical: {}, horizontal: {} }, s = window.Waypoint; i.prototype.add = function (e) { this.waypoints.push(e) }, i.prototype.clearTriggerQueues = function () { this.triggerQueues = { up: [], down: [], left: [], right: [] } }, i.prototype.flushTriggers = function () { for (var i in this.triggerQueues) { var n = this.triggerQueues[i], s = "up" === i || "left" === i; n.sort(s ? t : e); for (var r = 0, o = n.length; o > r; r += 1) { var a = n[r]; (a.options.continuous || r === n.length - 1) && a.trigger([i]) } } this.clearTriggerQueues() }, i.prototype.next = function (t) { this.waypoints.sort(e); var i = s.Adapter.inArray(t, this.waypoints); return i === this.waypoints.length - 1 ? null : this.waypoints[i + 1] }, i.prototype.previous = function (t) { this.waypoints.sort(e); var i = s.Adapter.inArray(t, this.waypoints); return i ? this.waypoints[i - 1] : null }, i.prototype.queueTrigger = function (e, t) { this.triggerQueues[t].push(e) }, i.prototype.remove = function (e) { var t = s.Adapter.inArray(e, this.waypoints); t > -1 && this.waypoints.splice(t, 1) }, i.prototype.first = function () { return this.waypoints[0] }, i.prototype.last = function () { return this.waypoints[this.waypoints.length - 1] }, i.findOrCreate = function (e) { return n[e.axis][e.name] || new i(e) }, s.Group = i }(), function () { "use strict"; function e(e) { this.$element = t(e) } var t = window.jQuery, i = window.Waypoint; t.each(["innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop"], (function (t, i) { e.prototype[i] = function () { var e = Array.prototype.slice.call(arguments); return this.$element[i].apply(this.$element, e) } })), t.each(["extend", "inArray", "isEmptyObject"], (function (i, n) { e[n] = t[n] })), i.adapters.push({ name: "jquery", Adapter: e }), i.Adapter = e }(), function () { "use strict"; function e(e) { return function () { var i = [], n = arguments[0]; return e.isFunction(arguments[0]) && ((n = e.extend({}, arguments[1])).handler = arguments[0]), this.each((function () { var s = e.extend({}, n, { element: this }); "string" == typeof s.context && (s.context = e(this).closest(s.context)[0]), i.push(new t(s)) })), i } } var t = window.Waypoint; window.jQuery && (window.jQuery.fn.waypoint = e(window.jQuery)), window.Zepto && (window.Zepto.fn.waypoint = e(window.Zepto)) }(),
  /*!
  * jquery.counterup.js 1.0
  *
  * Copyright 2013, Benjamin Intal http://gambit.ph @bfintal
  * Released under the GPL v2 License
  *
  * Date: Nov 26, 2013
  */
  function (e) { "use strict"; e.fn.counterUp = function (t) { var i, n = e.extend({ time: 400, delay: 10, offset: 100, beginAt: 0, formatter: !1, context: "window", callback: function () { } }, t); return this.each((function () { var t = e(this), s = { time: e(this).data("counterup-time") || n.time, delay: e(this).data("counterup-delay") || n.delay, offset: e(this).data("counterup-offset") || n.offset, beginAt: e(this).data("counterup-beginat") || n.beginAt, context: e(this).data("counterup-context") || n.context }; t.waypoint((function (r) { !function () { var r = [], o = s.time / s.delay, a = e(this).attr("data-num") ? e(this).attr("data-num") : t.text(), l = /[0-9]+,[0-9]+/.test(a), c = ((a = a.replace(/,/g, "")).split(".")[1] || []).length; s.beginAt > a && (s.beginAt = a); var d = /[0-9]+:[0-9]+:[0-9]+/.test(a); if (d) { var u = a.split(":"), p = 1; for (i = 0; u.length > 0;)i += p * parseInt(u.pop(), 10), p *= 60 } for (var f = o; f >= s.beginAt / a * o; f--) { var h = parseFloat(a / o * f).toFixed(c); if (d) { h = parseInt(i / o * f); var m = parseInt(h / 3600) % 24, g = parseInt(h / 60) % 60, v = parseInt(h % 60, 10); h = (m < 10 ? "0" + m : m) + ":" + (g < 10 ? "0" + g : g) + ":" + (v < 10 ? "0" + v : v) } if (l) for (; /(\d+)(\d{3})/.test(h.toString());)h = h.toString().replace(/(\d+)(\d{3})/, "$1,$2"); n.formatter && (h = n.formatter.call(this, h)), r.unshift(h) } t.data("counterup-nums", r), t.text(s.beginAt); t.data("counterup-func", (function () { t.data("counterup-nums") ? (t.html(t.data("counterup-nums").shift()), t.data("counterup-nums").length ? setTimeout(t.data("counterup-func"), s.delay) : (t.data("counterup-nums", null), t.data("counterup-func", null), n.callback.call(this))) : n.callback.call(this) })), setTimeout(t.data("counterup-func"), s.delay) }(), this.destroy() }), { offset: s.offset + "%", context: s.context }) })) } }(jQuery), function (e) { "function" == typeof define && define.amd ? define(["jquery"], e) : e("object" == typeof exports ? require("jquery") : window.jQuery || window.Zepto) }((function (e) { var t, i, n, s, r, o, a = "Close", l = "BeforeClose", c = "MarkupParse", d = "Open", u = "Change", p = "mfp", f = ".mfp", h = "mfp-ready", m = "mfp-removing", g = "mfp-prevent-close", v = function () { }, y = !!window.jQuery, b = e(window), w = function (e, i) { t.ev.on(p + e + f, i) }, E = function (t, i, n, s) { var r = document.createElement("div"); return r.className = "mfp-" + t, n && (r.innerHTML = n), s ? i && i.appendChild(r) : (r = e(r), i && r.appendTo(i)), r }, _ = function (i, n) { t.ev.triggerHandler(p + i, n), t.st.callbacks && (i = i.charAt(0).toLowerCase() + i.slice(1), t.st.callbacks[i] && t.st.callbacks[i].apply(t, e.isArray(n) ? n : [n])) }, x = function (i) { return i === o && t.currTemplate.closeBtn || (t.currTemplate.closeBtn = e(t.st.closeMarkup.replace("%title%", t.st.tClose)), o = i), t.currTemplate.closeBtn }, S = function () { e.magnificPopup.instance || ((t = new v).init(), e.magnificPopup.instance = t) }; v.prototype = { constructor: v, init: function () { var i = navigator.appVersion; t.isLowIE = t.isIE8 = document.all && !document.addEventListener, t.isAndroid = /android/gi.test(i), t.isIOS = /iphone|ipad|ipod/gi.test(i), t.supportsTransition = function () { var e = document.createElement("p").style, t = ["ms", "O", "Moz", "Webkit"]; if (void 0 !== e.transition) return !0; for (; t.length;)if (t.pop() + "Transition" in e) return !0; return !1 }(), t.probablyMobile = t.isAndroid || t.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent), n = e(document), t.popupsCache = {} }, open: function (i) { var s; if (!1 === i.isObj) { t.items = i.items.toArray(), t.index = 0; var o, a = i.items; for (s = 0; s < a.length; s++)if ((o = a[s]).parsed && (o = o.el[0]), o === i.el[0]) { t.index = s; break } } else t.items = e.isArray(i.items) ? i.items : [i.items], t.index = i.index || 0; if (!t.isOpen) { t.types = [], r = "", i.mainEl && i.mainEl.length ? t.ev = i.mainEl.eq(0) : t.ev = n, i.key ? (t.popupsCache[i.key] || (t.popupsCache[i.key] = {}), t.currTemplate = t.popupsCache[i.key]) : t.currTemplate = {}, t.st = e.extend(!0, {}, e.magnificPopup.defaults, i), t.fixedContentPos = "auto" === t.st.fixedContentPos ? !t.probablyMobile : t.st.fixedContentPos, t.st.modal && (t.st.closeOnContentClick = !1, t.st.closeOnBgClick = !1, t.st.showCloseBtn = !1, t.st.enableEscapeKey = !1), t.bgOverlay || (t.bgOverlay = E("bg").on("click" + f, (function () { t.close() })), t.wrap = E("wrap").attr("tabindex", -1).on("click" + f, (function (e) { t._checkIfClose(e.target) && t.close() })), t.container = E("container", t.wrap)), t.contentContainer = E("content"), t.st.preloader && (t.preloader = E("preloader", t.container, t.st.tLoading)); var l = e.magnificPopup.modules; for (s = 0; s < l.length; s++) { var u = l[s]; u = u.charAt(0).toUpperCase() + u.slice(1), t["init" + u].call(t) } _("BeforeOpen"), t.st.showCloseBtn && (t.st.closeBtnInside ? (w(c, (function (e, t, i, n) { i.close_replaceWith = x(n.type) })), r += " mfp-close-btn-in") : t.wrap.append(x())), t.st.alignTop && (r += " mfp-align-top"), t.fixedContentPos ? t.wrap.css({ overflow: t.st.overflowY, overflowX: "hidden", overflowY: t.st.overflowY }) : t.wrap.css({ top: b.scrollTop(), position: "absolute" }), (!1 === t.st.fixedBgPos || "auto" === t.st.fixedBgPos && !t.fixedContentPos) && t.bgOverlay.css({ height: n.height(), position: "absolute" }), t.st.enableEscapeKey && n.on("keyup" + f, (function (e) { 27 === e.keyCode && t.close() })), b.on("resize" + f, (function () { t.updateSize() })), t.st.closeOnContentClick || (r += " mfp-auto-cursor"), r && t.wrap.addClass(r); var p = t.wH = b.height(), m = {}; if (t.fixedContentPos && t._hasScrollBar(p)) { var g = t._getScrollbarSize(); g && (m.marginRight = g) } t.fixedContentPos && (t.isIE7 ? e("body, html").css("overflow", "hidden") : m.overflow = "hidden"); var v = t.st.mainClass; return t.isIE7 && (v += " mfp-ie7"), v && t._addClassToMFP(v), t.updateItemHTML(), _("BuildControls"), e("html").css(m), t.bgOverlay.add(t.wrap).prependTo(t.st.prependTo || e(document.body)), t._lastFocusedEl = document.activeElement, setTimeout((function () { t.content ? (t._addClassToMFP(h), t._setFocus()) : t.bgOverlay.addClass(h), n.on("focusin" + f, t._onFocusIn) }), 16), t.isOpen = !0, t.updateSize(p), _(d), i } t.updateItemHTML() }, close: function () { t.isOpen && (_(l), t.isOpen = !1, t.st.removalDelay && !t.isLowIE && t.supportsTransition ? (t._addClassToMFP(m), setTimeout((function () { t._close() }), t.st.removalDelay)) : t._close()) }, _close: function () { _(a); var i = m + " " + h + " "; if (t.bgOverlay.detach(), t.wrap.detach(), t.container.empty(), t.st.mainClass && (i += t.st.mainClass + " "), t._removeClassFromMFP(i), t.fixedContentPos) { var s = { marginRight: "" }; t.isIE7 ? e("body, html").css("overflow", "") : s.overflow = "", e("html").css(s) } n.off("keyup.mfp focusin" + f), t.ev.off(f), t.wrap.attr("class", "mfp-wrap").removeAttr("style"), t.bgOverlay.attr("class", "mfp-bg"), t.container.attr("class", "mfp-container"), !t.st.showCloseBtn || t.st.closeBtnInside && !0 !== t.currTemplate[t.currItem.type] || t.currTemplate.closeBtn && t.currTemplate.closeBtn.detach(), t.st.autoFocusLast && t._lastFocusedEl && e(t._lastFocusedEl).focus(), t.currItem = null, t.content = null, t.currTemplate = null, t.prevHeight = 0, _("AfterClose") }, updateSize: function (e) { if (t.isIOS) { var i = document.documentElement.clientWidth / window.innerWidth, n = window.innerHeight * i; t.wrap.css("height", n), t.wH = n } else t.wH = e || b.height(); t.fixedContentPos || t.wrap.css("height", t.wH), _("Resize") }, updateItemHTML: function () { var i = t.items[t.index]; t.contentContainer.detach(), t.content && t.content.detach(), i.parsed || (i = t.parseEl(t.index)); var n = i.type; if (_("BeforeChange", [t.currItem ? t.currItem.type : "", n]), t.currItem = i, !t.currTemplate[n]) { var r = !!t.st[n] && t.st[n].markup; _("FirstMarkupParse", r), t.currTemplate[n] = !r || e(r) } s && s !== i.type && t.container.removeClass("mfp-" + s + "-holder"); var o = t["get" + n.charAt(0).toUpperCase() + n.slice(1)](i, t.currTemplate[n]); t.appendContent(o, n), i.preloaded = !0, _(u, i), s = i.type, t.container.prepend(t.contentContainer), _("AfterChange") }, appendContent: function (e, i) { t.content = e, e ? t.st.showCloseBtn && t.st.closeBtnInside && !0 === t.currTemplate[i] ? t.content.find(".mfp-close").length || t.content.append(x()) : t.content = e : t.content = "", _("BeforeAppend"), t.container.addClass("mfp-" + i + "-holder"), t.contentContainer.append(t.content) }, parseEl: function (i) { var n, s = t.items[i]; if (s.tagName ? s = { el: e(s) } : (n = s.type, s = { data: s, src: s.src }), s.el) { for (var r = t.types, o = 0; o < r.length; o++)if (s.el.hasClass("mfp-" + r[o])) { n = r[o]; break } s.src = s.el.attr("data-mfp-src"), s.src || (s.src = s.el.attr("href")) } return s.type = n || t.st.type || "inline", s.index = i, s.parsed = !0, t.items[i] = s, _("ElementParse", s), t.items[i] }, addGroup: function (e, i) { var n = function (n) { n.mfpEl = this, t._openClick(n, e, i) }; i || (i = {}); var s = "click.magnificPopup"; i.mainEl = e, i.items ? (i.isObj = !0, e.off(s).on(s, n)) : (i.isObj = !1, i.delegate ? e.off(s).on(s, i.delegate, n) : (i.items = e, e.off(s).on(s, n))) }, _openClick: function (i, n, s) { if ((void 0 !== s.midClick ? s.midClick : e.magnificPopup.defaults.midClick) || !(2 === i.which || i.ctrlKey || i.metaKey || i.altKey || i.shiftKey)) { var r = void 0 !== s.disableOn ? s.disableOn : e.magnificPopup.defaults.disableOn; if (r) if (e.isFunction(r)) { if (!r.call(t)) return !0 } else if (b.width() < r) return !0; i.type && (i.preventDefault(), t.isOpen && i.stopPropagation()), s.el = e(i.mfpEl), s.delegate && (s.items = n.find(s.delegate)), t.open(s) } }, updateStatus: function (e, n) { if (t.preloader) { i !== e && t.container.removeClass("mfp-s-" + i), n || "loading" !== e || (n = t.st.tLoading); var s = { status: e, text: n }; _("UpdateStatus", s), e = s.status, n = s.text, t.preloader.html(n), t.preloader.find("a").on("click", (function (e) { e.stopImmediatePropagation() })), t.container.addClass("mfp-s-" + e), i = e } }, _checkIfClose: function (i) { if (!e(i).hasClass(g)) { var n = t.st.closeOnContentClick, s = t.st.closeOnBgClick; if (n && s) return !0; if (!t.content || e(i).hasClass("mfp-close") || t.preloader && i === t.preloader[0]) return !0; if (i === t.content[0] || e.contains(t.content[0], i)) { if (n) return !0 } else if (s && e.contains(document, i)) return !0; return !1 } }, _addClassToMFP: function (e) { t.bgOverlay.addClass(e), t.wrap.addClass(e) }, _removeClassFromMFP: function (e) { this.bgOverlay.removeClass(e), t.wrap.removeClass(e) }, _hasScrollBar: function (e) { return (t.isIE7 ? n.height() : document.body.scrollHeight) > (e || b.height()) }, _setFocus: function () { (t.st.focus ? t.content.find(t.st.focus).eq(0) : t.wrap).focus() }, _onFocusIn: function (i) { return i.target === t.wrap[0] || e.contains(t.wrap[0], i.target) ? void 0 : (t._setFocus(), !1) }, _parseMarkup: function (t, i, n) { var s; n.data && (i = e.extend(n.data, i)), _(c, [t, i, n]), e.each(i, (function (i, n) { if (void 0 === n || !1 === n) return !0; if ((s = i.split("_")).length > 1) { var r = t.find(f + "-" + s[0]); if (r.length > 0) { var o = s[1]; "replaceWith" === o ? r[0] !== n[0] && r.replaceWith(n) : "img" === o ? r.is("img") ? r.attr("src", n) : r.replaceWith(e("<img>").attr("src", n).attr("class", r.attr("class"))) : r.attr(s[1], n) } } else t.find(f + "-" + i).html(n) })) }, _getScrollbarSize: function () { if (void 0 === t.scrollbarSize) { var e = document.createElement("div"); e.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;", document.body.appendChild(e), t.scrollbarSize = e.offsetWidth - e.clientWidth, document.body.removeChild(e) } return t.scrollbarSize } }, e.magnificPopup = { instance: null, proto: v.prototype, modules: [], open: function (t, i) { return S(), (t = t ? e.extend(!0, {}, t) : {}).isObj = !0, t.index = i || 0, this.instance.open(t) }, close: function () { return e.magnificPopup.instance && e.magnificPopup.instance.close() }, registerModule: function (t, i) { i.options && (e.magnificPopup.defaults[t] = i.options), e.extend(this.proto, i.proto), this.modules.push(t) }, defaults: { disableOn: 0, key: null, midClick: !1, mainClass: "", preloader: !0, focus: "", closeOnContentClick: !1, closeOnBgClick: !0, closeBtnInside: !0, showCloseBtn: !0, enableEscapeKey: !0, modal: !1, alignTop: !1, removalDelay: 0, prependTo: null, fixedContentPos: "auto", fixedBgPos: "auto", overflowY: "auto", closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>', tClose: "Close (Esc)", tLoading: "Loading...", autoFocusLast: !0 } }, e.fn.magnificPopup = function (i) { S(); var n = e(this); if ("string" == typeof i) if ("open" === i) { var s, r = y ? n.data("magnificPopup") : n[0].magnificPopup, o = parseInt(arguments[1], 10) || 0; r.items ? s = r.items[o] : (s = n, r.delegate && (s = s.find(r.delegate)), s = s.eq(o)), t._openClick({ mfpEl: s }, n, r) } else t.isOpen && t[i].apply(t, Array.prototype.slice.call(arguments, 1)); else i = e.extend(!0, {}, i), y ? n.data("magnificPopup", i) : n[0].magnificPopup = i, t.addGroup(n, i); return n }; var T, C, M, L = "inline", I = function () { M && (C.after(M.addClass(T)).detach(), M = null) }; e.magnificPopup.registerModule(L, { options: { hiddenClass: "hide", markup: "", tNotFound: "Content not found" }, proto: { initInline: function () { t.types.push(L), w(a + "." + L, (function () { I() })) }, getInline: function (i, n) { if (I(), i.src) { var s = t.st.inline, r = e(i.src); if (r.length) { var o = r[0].parentNode; o && o.tagName && (C || (T = s.hiddenClass, C = E(T), T = "mfp-" + T), M = r.after(C).detach().removeClass(T)), t.updateStatus("ready") } else t.updateStatus("error", s.tNotFound), r = e("<div>"); return i.inlineElement = r, r } return t.updateStatus("ready"), t._parseMarkup(n, {}, i), n } } }); var A, P = "ajax", O = function () { A && e(document.body).removeClass(A) }, k = function () { O(), t.req && t.req.abort() }; e.magnificPopup.registerModule(P, { options: { settings: null, cursor: "mfp-ajax-cur", tError: '<a href="%url%">The content</a> could not be loaded.' }, proto: { initAjax: function () { t.types.push(P), A = t.st.ajax.cursor, w(a + "." + P, k), w("BeforeChange." + P, k) }, getAjax: function (i) { A && e(document.body).addClass(A), t.updateStatus("loading"); var n = e.extend({ url: i.src, success: function (n, s, r) { var o = { data: n, xhr: r }; _("ParseAjax", o), t.appendContent(e(o.data), P), i.finished = !0, O(), t._setFocus(), setTimeout((function () { t.wrap.addClass(h) }), 16), t.updateStatus("ready"), _("AjaxContentAdded") }, error: function () { O(), i.finished = i.loadError = !0, t.updateStatus("error", t.st.ajax.tError.replace("%url%", i.src)) } }, t.st.ajax.settings); return t.req = e.ajax(n), "" } } }); var z, D = function (i) { if (i.data && void 0 !== i.data.title) return i.data.title; var n = t.st.image.titleSrc; if (n) { if (e.isFunction(n)) return n.call(t, i); if (i.el) return i.el.attr(n) || "" } return "" }; e.magnificPopup.registerModule("image", { options: { markup: '<div class="mfp-figure"><div class="mfp-close"></div><figure><div class="mfp-img"></div><figcaption><div class="mfp-bottom-bar"><div class="mfp-title"></div><div class="mfp-counter"></div></div></figcaption></figure></div>', cursor: "mfp-zoom-out-cur", titleSrc: "title", verticalFit: !0, tError: '<a href="%url%">The image</a> could not be loaded.' }, proto: { initImage: function () { var i = t.st.image, n = ".image"; t.types.push("image"), w(d + n, (function () { "image" === t.currItem.type && i.cursor && e(document.body).addClass(i.cursor) })), w(a + n, (function () { i.cursor && e(document.body).removeClass(i.cursor), b.off("resize" + f) })), w("Resize" + n, t.resizeImage), t.isLowIE && w("AfterChange", t.resizeImage) }, resizeImage: function () { var e = t.currItem; if (e && e.img && t.st.image.verticalFit) { var i = 0; t.isLowIE && (i = parseInt(e.img.css("padding-top"), 10) + parseInt(e.img.css("padding-bottom"), 10)), e.img.css("max-height", t.wH - i) } }, _onImageHasSize: function (e) { e.img && (e.hasSize = !0, z && clearInterval(z), e.isCheckingImgSize = !1, _("ImageHasSize", e), e.imgHidden && (t.content && t.content.removeClass("mfp-loading"), e.imgHidden = !1)) }, findImageSize: function (e) { var i = 0, n = e.img[0], s = function (r) { z && clearInterval(z), z = setInterval((function () { return n.naturalWidth > 0 ? void t._onImageHasSize(e) : (i > 200 && clearInterval(z), void (3 === ++i ? s(10) : 40 === i ? s(50) : 100 === i && s(500))) }), r) }; s(1) }, getImage: function (i, n) { var s = 0, r = function () { i && (i.img[0].complete ? (i.img.off(".mfploader"), i === t.currItem && (t._onImageHasSize(i), t.updateStatus("ready")), i.hasSize = !0, i.loaded = !0, _("ImageLoadComplete")) : 200 > ++s ? setTimeout(r, 100) : o()) }, o = function () { i && (i.img.off(".mfploader"), i === t.currItem && (t._onImageHasSize(i), t.updateStatus("error", a.tError.replace("%url%", i.src))), i.hasSize = !0, i.loaded = !0, i.loadError = !0) }, a = t.st.image, l = n.find(".mfp-img"); if (l.length) { var c = document.createElement("img"); c.className = "mfp-img", i.el && i.el.find("img").length && (c.alt = i.el.find("img").attr("alt")), i.img = e(c).on("load.mfploader", r).on("error.mfploader", o), c.src = i.src, l.is("img") && (i.img = i.img.clone()), (c = i.img[0]).naturalWidth > 0 ? i.hasSize = !0 : c.width || (i.hasSize = !1) } return t._parseMarkup(n, { title: D(i), img_replaceWith: i.img }, i), t.resizeImage(), i.hasSize ? (z && clearInterval(z), i.loadError ? (n.addClass("mfp-loading"), t.updateStatus("error", a.tError.replace("%url%", i.src))) : (n.removeClass("mfp-loading"), t.updateStatus("ready")), n) : (t.updateStatus("loading"), i.loading = !0, i.hasSize || (i.imgHidden = !0, n.addClass("mfp-loading"), t.findImageSize(i)), n) } } }); var j; e.magnificPopup.registerModule("zoom", { options: { enabled: !1, easing: "ease-in-out", duration: 300, opener: function (e) { return e.is("img") ? e : e.find("img") } }, proto: { initZoom: function () { var e, i = t.st.zoom, n = ".zoom"; if (i.enabled && t.supportsTransition) { var s, r, o = i.duration, c = function (e) { var t = e.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image"), n = "all " + i.duration / 1e3 + "s " + i.easing, s = { position: "fixed", zIndex: 9999, left: 0, top: 0, "-webkit-backface-visibility": "hidden" }, r = "transition"; return s["-webkit-" + r] = s["-moz-" + r] = s["-o-" + r] = s[r] = n, t.css(s), t }, d = function () { t.content.css("visibility", "visible") }; w("BuildControls" + n, (function () { if (t._allowZoom()) { if (clearTimeout(s), t.content.css("visibility", "hidden"), !(e = t._getItemToZoom())) return void d(); (r = c(e)).css(t._getOffset()), t.wrap.append(r), s = setTimeout((function () { r.css(t._getOffset(!0)), s = setTimeout((function () { d(), setTimeout((function () { r.remove(), e = r = null, _("ZoomAnimationEnded") }), 16) }), o) }), 16) } })), w(l + n, (function () { if (t._allowZoom()) { if (clearTimeout(s), t.st.removalDelay = o, !e) { if (!(e = t._getItemToZoom())) return; r = c(e) } r.css(t._getOffset(!0)), t.wrap.append(r), t.content.css("visibility", "hidden"), setTimeout((function () { r.css(t._getOffset()) }), 16) } })), w(a + n, (function () { t._allowZoom() && (d(), r && r.remove(), e = null) })) } }, _allowZoom: function () { return "image" === t.currItem.type }, _getItemToZoom: function () { return !!t.currItem.hasSize && t.currItem.img }, _getOffset: function (i) { var n, s = (n = i ? t.currItem.img : t.st.zoom.opener(t.currItem.el || t.currItem)).offset(), r = parseInt(n.css("padding-top"), 10), o = parseInt(n.css("padding-bottom"), 10); s.top -= e(window).scrollTop() - r; var a = { width: n.width(), height: (y ? n.innerHeight() : n[0].offsetHeight) - o - r }; return void 0 === j && (j = void 0 !== document.createElement("p").style.MozTransform), j ? a["-moz-transform"] = a.transform = "translate(" + s.left + "px," + s.top + "px)" : (a.left = s.left, a.top = s.top), a } } }); var $ = "iframe", N = function (e) { if (t.currTemplate[$]) { var i = t.currTemplate[$].find("iframe"); i.length && (e || (i[0].src = "//about:blank"), t.isIE8 && i.css("display", e ? "block" : "none")) } }; e.magnificPopup.registerModule($, { options: { markup: '<div class="mfp-iframe-scaler"><div class="mfp-close"></div><iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe></div>', srcAction: "iframe_src", patterns: { youtube: { index: "youtube.com", id: "v=", src: "//www.youtube.com/embed/%id%?autoplay=1" }, vimeo: { index: "vimeo.com/", id: "/", src: "//player.vimeo.com/video/%id%?autoplay=1" }, gmaps: { index: "//maps.google.", src: "%id%&output=embed" } } }, proto: { initIframe: function () { t.types.push($), w("BeforeChange", (function (e, t, i) { t !== i && (t === $ ? N() : i === $ && N(!0)) })), w(a + "." + $, (function () { N() })) }, getIframe: function (i, n) { var s = i.src, r = t.st.iframe; e.each(r.patterns, (function () { return s.indexOf(this.index) > -1 ? (this.id && (s = "string" == typeof this.id ? s.substr(s.lastIndexOf(this.id) + this.id.length, s.length) : this.id.call(this, s)), s = this.src.replace("%id%", s), !1) : void 0 })); var o = {}; return r.srcAction && (o[r.srcAction] = s), t._parseMarkup(n, o, i), t.updateStatus("ready"), n } } }); var H = function (e) { var i = t.items.length; return e > i - 1 ? e - i : 0 > e ? i + e : e }, B = function (e, t, i) { return e.replace(/%curr%/gi, t + 1).replace(/%total%/gi, i) }; e.magnificPopup.registerModule("gallery", { options: { enabled: !1, arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>', preload: [0, 2], navigateByImgClick: !0, arrows: !0, tPrev: "Previous (Left arrow key)", tNext: "Next (Right arrow key)", tCounter: "%curr% of %total%" }, proto: { initGallery: function () { var i = t.st.gallery, s = ".mfp-gallery"; return t.direction = !0, !(!i || !i.enabled) && (r += " mfp-gallery", w(d + s, (function () { i.navigateByImgClick && t.wrap.on("click" + s, ".mfp-img", (function () { return t.items.length > 1 ? (t.next(), !1) : void 0 })), n.on("keydown" + s, (function (e) { 37 === e.keyCode ? t.prev() : 39 === e.keyCode && t.next() })) })), w("UpdateStatus" + s, (function (e, i) { i.text && (i.text = B(i.text, t.currItem.index, t.items.length)) })), w(c + s, (function (e, n, s, r) { var o = t.items.length; s.counter = o > 1 ? B(i.tCounter, r.index, o) : "" })), w("BuildControls" + s, (function () { if (t.items.length > 1 && i.arrows && !t.arrowLeft) { var n = i.arrowMarkup, s = t.arrowLeft = e(n.replace(/%title%/gi, i.tPrev).replace(/%dir%/gi, "left")).addClass(g), r = t.arrowRight = e(n.replace(/%title%/gi, i.tNext).replace(/%dir%/gi, "right")).addClass(g); s.click((function () { t.prev() })), r.click((function () { t.next() })), t.container.append(s.add(r)) } })), w(u + s, (function () { t._preloadTimeout && clearTimeout(t._preloadTimeout), t._preloadTimeout = setTimeout((function () { t.preloadNearbyImages(), t._preloadTimeout = null }), 16) })), void w(a + s, (function () { n.off(s), t.wrap.off("click" + s), t.arrowRight = t.arrowLeft = null }))) }, next: function () { t.direction = !0, t.index = H(t.index + 1), t.updateItemHTML() }, prev: function () { t.direction = !1, t.index = H(t.index - 1), t.updateItemHTML() }, goTo: function (e) { t.direction = e >= t.index, t.index = e, t.updateItemHTML() }, preloadNearbyImages: function () { var e, i = t.st.gallery.preload, n = Math.min(i[0], t.items.length), s = Math.min(i[1], t.items.length); for (e = 1; e <= (t.direction ? s : n); e++)t._preloadItem(t.index + e); for (e = 1; e <= (t.direction ? n : s); e++)t._preloadItem(t.index - e) }, _preloadItem: function (i) { if (i = H(i), !t.items[i].preloaded) { var n = t.items[i]; n.parsed || (n = t.parseEl(i)), _("LazyLoad", n), "image" === n.type && (n.img = e('<img class="mfp-img" />').on("load.mfploader", (function () { n.hasSize = !0 })).on("error.mfploader", (function () { n.hasSize = !0, n.loadError = !0, _("LazyLoadError", n) })).attr("src", n.src)), n.preloaded = !0 } } } }); var W = "retina"; e.magnificPopup.registerModule(W, { options: { replaceSrc: function (e) { return e.src.replace(/\.\w+$/, (function (e) { return "@2x" + e })) }, ratio: 1 }, proto: { initRetina: function () { if (window.devicePixelRatio > 1) { var e = t.st.retina, i = e.ratio; (i = isNaN(i) ? i() : i) > 1 && (w("ImageHasSize." + W, (function (e, t) { t.img.css({ "max-width": t.img[0].naturalWidth / i, width: "100%" }) })), w("ElementParse." + W, (function (t, n) { n.src = e.replaceSrc(n, i) }))) } } } }), S() })); var $jscomp = $jscomp || {}; $jscomp.scope = {}, $jscomp.arrayIteratorImpl = function (e) { var t = 0; return function () { return t < e.length ? { done: !1, value: e[t++] } : { done: !0 } } }, $jscomp.arrayIterator = function (e) { return { next: $jscomp.arrayIteratorImpl(e) } }, $jscomp.ASSUME_ES5 = !1, $jscomp.ASSUME_NO_NATIVE_MAP = !1, $jscomp.ASSUME_NO_NATIVE_SET = !1, $jscomp.SIMPLE_FROUND_POLYFILL = !1, $jscomp.ISOLATE_POLYFILLS = !1, $jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function (e, t, i) { return e == Array.prototype || e == Object.prototype || (e[t] = i.value), e }, $jscomp.getGlobal = function (e) { e = ["object" == typeof globalThis && globalThis, e, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global]; for (var t = 0; t < e.length; ++t) { var i = e[t]; if (i && i.Math == Math) return i } throw Error("Cannot find global object") }, $jscomp.global = $jscomp.getGlobal(this), $jscomp.IS_SYMBOL_NATIVE = "function" == typeof Symbol && "symbol" == typeof Symbol("x"), $jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE, $jscomp.polyfills = {}, $jscomp.propertyToPolyfillSymbol = {}, $jscomp.POLYFILL_PREFIX = "$jscp$"; var $jscomp$lookupPolyfilledValue = function (e, t) { var i = $jscomp.propertyToPolyfillSymbol[t]; return null == i ? e[t] : void 0 !== (i = e[i]) ? i : e[t] }; $jscomp.polyfill = function (e, t, i, n) { t && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(e, t, i, n) : $jscomp.polyfillUnisolated(e, t, i, n)) }, $jscomp.polyfillUnisolated = function (e, t, i, n) { for (i = $jscomp.global, e = e.split("."), n = 0; n < e.length - 1; n++) { var s = e[n]; s in i || (i[s] = {}), i = i[s] } (t = t(n = i[e = e[e.length - 1]])) != n && null != t && $jscomp.defineProperty(i, e, { configurable: !0, writable: !0, value: t }) }, $jscomp.polyfillIsolated = function (e, t, i, n) { var s = e.split("."); e = 1 === s.length, n = s[0], n = !e && n in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global; for (var r = 0; r < s.length - 1; r++) { var o = s[r]; o in n || (n[o] = {}), n = n[o] } s = s[s.length - 1], null != (t = t(i = $jscomp.IS_SYMBOL_NATIVE && "es6" === i ? n[s] : null)) && (e ? $jscomp.defineProperty($jscomp.polyfills, s, { configurable: !0, writable: !0, value: t }) : t !== i && ($jscomp.propertyToPolyfillSymbol[s] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(s) : $jscomp.POLYFILL_PREFIX + s, s = $jscomp.propertyToPolyfillSymbol[s], $jscomp.defineProperty(n, s, { configurable: !0, writable: !0, value: t }))) }, $jscomp.initSymbol = function () { }, $jscomp.polyfill("Symbol", (function (e) { if (e) return e; var t = function (e, t) { this.$jscomp$symbol$id_ = e, $jscomp.defineProperty(this, "description", { configurable: !0, writable: !0, value: t }) }; t.prototype.toString = function () { return this.$jscomp$symbol$id_ }; var i = 0, n = function (e) { if (this instanceof n) throw new TypeError("Symbol is not a constructor"); return new t("jscomp_symbol_" + (e || "") + "_" + i++, e) }; return n }), "es6", "es3"), $jscomp.initSymbolIterator = function () { }, $jscomp.polyfill("Symbol.iterator", (function (e) { if (e) return e; e = Symbol("Symbol.iterator"); for (var t = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), i = 0; i < t.length; i++) { var n = $jscomp.global[t[i]]; "function" == typeof n && "function" != typeof n.prototype[e] && $jscomp.defineProperty(n.prototype, e, { configurable: !0, writable: !0, value: function () { return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this)) } }) } return e }), "es6", "es3"), $jscomp.initSymbolAsyncIterator = function () { }, $jscomp.iteratorPrototype = function (e) { return (e = { next: e })[Symbol.iterator] = function () { return this }, e }, $jscomp.iteratorFromArray = function (e, t) { e instanceof String && (e += ""); var i = 0, n = { next: function () { if (i < e.length) { var s = i++; return { value: t(s, e[s]), done: !1 } } return n.next = function () { return { done: !0, value: void 0 } }, n.next() } }; return n[Symbol.iterator] = function () { return n }, n }, $jscomp.polyfill("Array.prototype.keys", (function (e) { return e || function () { return $jscomp.iteratorFromArray(this, (function (e) { return e })) } }), "es6", "es3"); var scrollCue = function () { var e, t, i, n = {}, s = 0, r = !0, o = !0, a = !1, l = !1, c = { duration: 600, interval: -.7, percentage: .75, enable: !0, docSlider: !1, pageChangeReset: !1 }; return n = { setEvents: function (e) { var t = function () { r && (requestAnimationFrame((function () { r = !0, o && (n.setQuery(), n.runQuery()) })), r = !1) }; if (o && !e && window.addEventListener("load", n.runQuery), window.addEventListener("scroll", t), a) { e = docSlider.getElements().pages; for (var i = 0; i < e.length; i++)e[i].addEventListener("scroll", (function (e) { if (docSlider.getCurrentIndex() + "" !== (e = e.target.getAttribute("data-ds-index"))) return !1; docSlider._getWheelEnable() && t() })) } window.addEventListener("resize", (function () { 0 < s && clearTimeout(s), s = setTimeout((function () { o && (n.searchElements(), n.setQuery(), n.runQuery()) }), 200) })) }, setOptions: function (e, t) { var i = {}; if (void 0 !== e) return Object.keys(e).forEach((function (s) { "[object Object]" === Object.prototype.toString.call(e[s]) ? i[s] = n.setOptions(e[s], t[s]) : (i[s] = e[s], void 0 !== t && void 0 !== t[s] && (i[s] = t[s])) })), i }, searchElements: function () { e = []; for (var t = document.querySelectorAll("[data-cues]:not([data-disabled])"), s = 0; s < t.length; s++) { for (var r = t[s], o = 0; o < r.children.length; o++) { var l = r.children[o]; n.setAttrPtoC(l, "data-cue", r, "data-cues", ""), n.setAttrPtoC(l, "data-duration", r, "data-duration", !1), n.setAttrPtoC(l, "data-interval", r, "data-interval", !1), n.setAttrPtoC(l, "data-sort", r, "data-sort", !1), n.setAttrPtoC(l, "data-addClass", r, "data-addClass", !1), n.setAttrPtoC(l, "data-group", r, "data-group", !1), n.setAttrPtoC(l, "data-delay", r, "data-delay", !1) } r.setAttribute("data-disabled", "true") } for (t = document.querySelectorAll('[data-cue]:not([data-show="true"])'), s = 0; s < t.length; s++)r = t[s], e.push({ elm: r, cue: n.getAttr(r, "data-cue", "fadeIn"), duration: Number(n.getAttr(r, "data-duration", i.duration)), interval: Number(n.getAttr(r, "data-interval", i.interval)), order: n.getOrderNumber(r), sort: n.getAttr(r, "data-sort", null), addClass: n.getAttr(r, "data-addClass", null), group: n.getAttr(r, "data-group", null), delay: Number(n.getAttr(r, "data-delay", 0)) }); if (a) for (t = docSlider.getElements().pages.length, s = 0; s < t; s++)for (r = document.querySelectorAll('[data-ds-index="' + s + '"] [data-cue]:not([data-scpage])'), o = 0; o < r.length; o++)r[o].setAttribute("data-scpage", s) }, sortElements: function () { for (var e = arguments[0], t = [].slice.call(arguments).slice(1), i = { $jscomp$loop$prop$i$4: 0 }; i.$jscomp$loop$prop$i$4 < t.length; (i = { $jscomp$loop$prop$i$4: i.$jscomp$loop$prop$i$4 }).$jscomp$loop$prop$i$4++)e.sort(function (e) { return function (i, n) { var s = void 0 === t[e.$jscomp$loop$prop$i$4][1] || t[e.$jscomp$loop$prop$i$4][1], r = t[e.$jscomp$loop$prop$i$4][0]; return i[r] > n[r] ? s ? 1 : -1 : i[r] < n[r] ? s ? -1 : 1 : 0 } }(i)) }, randElements: function (e) { for (var t = e.length - 1; 0 < t; t--) { var i = Math.floor(Math.random() * (t + 1)), n = e[t]; e[t] = e[i], e[i] = n } return e }, setDurationValue: function (e, t, i) { return void 0 === t ? e : (t = t.duration, 0 > (e = -1 === (i + "").indexOf(".") ? e + t + i : e + t + t * i) ? 0 : e) }, getOrderNumber: function (e) { return e.hasAttribute("data-order") ? 0 <= (e = Number(e.getAttribute("data-order"))) ? e : Math.pow(2, 53) - 1 + e : Math.pow(2, 52) - 1 }, setAttrPtoC: function (e, t, i, n, s) { i.hasAttribute(n) ? e.hasAttribute(t) || e.setAttribute(t, i.getAttribute(n)) : !1 !== s && e.setAttribute(t, s) }, getAttr: function (e, t, i) { return e.hasAttribute(t) ? e.getAttribute(t) : i }, getOffsetTop: function (e) { return e.getBoundingClientRect().top + (window.pageYOffset || document.documentElement.scrollTop) }, setClassNames: function (e, t) { if (t) { t = t.split(" "); for (var i = 0; i < t.length; i++)e.classList.add(t[i]) } }, setQuery: function () { t = {}; for (var i = 0; i < e.length; i++) { var s = e[i], r = s.group ? s.group : "$" + n.getOffsetTop(s.elm); if (!s.elm.hasAttribute("data-show")) { if (a) { var o = s.elm.getAttribute("data-scpage"); if (o !== docSlider.getCurrentIndex() + "" && null !== o) continue } void 0 === t[r] && (t[r] = []), t[r].push(s) } } }, runQuery: function () { for (var e = Object.keys(t), i = {}, s = 0; s < e.length; i = { $jscomp$loop$prop$elms$6: i.$jscomp$loop$prop$elms$6, $jscomp$loop$prop$interval$7: i.$jscomp$loop$prop$interval$7 }, s++)if (i.$jscomp$loop$prop$elms$6 = t[e[s]], n.isElementIn(i.$jscomp$loop$prop$elms$6[0].elm)) { "reverse" === i.$jscomp$loop$prop$elms$6[0].sort ? i.$jscomp$loop$prop$elms$6.reverse() : "random" === i.$jscomp$loop$prop$elms$6[0].sort && n.randElements(i.$jscomp$loop$prop$elms$6), n.sortElements(i.$jscomp$loop$prop$elms$6, ["order"]); for (var r = i.$jscomp$loop$prop$interval$7 = 0; r < i.$jscomp$loop$prop$elms$6.length; r++)!function (e) { return function (t) { e.$jscomp$loop$prop$elms$6[t].elm.setAttribute("data-show", "true"), n.setClassNames(e.$jscomp$loop$prop$elms$6[t].elm, e.$jscomp$loop$prop$elms$6[t].addClass), e.$jscomp$loop$prop$interval$7 = n.setDurationValue(e.$jscomp$loop$prop$interval$7, e.$jscomp$loop$prop$elms$6[t - 1], e.$jscomp$loop$prop$elms$6[t].interval), e.$jscomp$loop$prop$elms$6[t].elm.style.animationName = e.$jscomp$loop$prop$elms$6[t].cue, e.$jscomp$loop$prop$elms$6[t].elm.style.animationDuration = e.$jscomp$loop$prop$elms$6[t].duration + "ms", e.$jscomp$loop$prop$elms$6[t].elm.style.animationTimingFunction = "ease", e.$jscomp$loop$prop$elms$6[t].elm.style.animationDelay = e.$jscomp$loop$prop$interval$7 + e.$jscomp$loop$prop$elms$6[t].delay + "ms", e.$jscomp$loop$prop$elms$6[t].elm.style.animationDirection = "normal", e.$jscomp$loop$prop$elms$6[t].elm.style.animationFillMode = "both" } }(i)(r); delete t[e[s]] } }, isElementIn: function (e) { var t = e.hasAttribute("data-scpage") ? n.isScrollEndWithDocSlider : n.isScrollEnd; return window.pageYOffset > n.getOffsetTop(e) - window.innerHeight * i.percentage || t() }, isScrollEnd: function () { var e = window.document.documentElement; return (window.document.body.scrollTop || e.scrollTop) >= e.scrollHeight - e.clientHeight }, isScrollEndWithDocSlider: function () { var e = docSlider.getCurrentPage(); return e.scrollTop >= e.scrollHeight - e.clientHeight } }, { init: function (e) { i = n.setOptions(c, e), o = i.enable, a = i.docSlider, l = i.pageChangeReset, a || (n.setEvents(), n.searchElements(), n.setQuery()) }, update: function () { o && (n.searchElements(), n.setQuery(), n.runQuery()) }, enable: function (e) { o = void 0 === e ? !o : e, scrollCue.update() }, _hasDocSlider: function () { return a }, _hasPageChangeReset: function () { return l }, _initWithDocSlider: function (e) { n.setEvents(e), n.searchElements(), n.setQuery() }, _updateWithDocSlider: function () { o && (n.setQuery(), n.runQuery()) }, _searchElements: function () { n.searchElements() } } }(), Swiper = function () { "use strict"; function e(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function t(i, n) { void 0 === i && (i = {}), void 0 === n && (n = {}); const s = ["__proto__", "constructor", "prototype"]; Object.keys(n).filter(e => s.indexOf(e) < 0).forEach(s => { void 0 === i[s] ? i[s] = n[s] : e(n[s]) && e(i[s]) && Object.keys(n[s]).length > 0 && t(i[s], n[s]) }) } const i = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function n() { const e = "undefined" != typeof document ? document : {}; return t(e, i), e } const s = { document: i, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function r() { const e = "undefined" != typeof window ? window : {}; return t(e, s), e } function o(e) { return void 0 === e && (e = ""), e.trim().split(" ").filter(e => !!e.trim()) } function a(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) } function l() { return Date.now() } function c(e, t) { void 0 === t && (t = "x"); const i = r(); let n, s, o; const a = function (e) { const t = r(); let i; return t.getComputedStyle && (i = t.getComputedStyle(e, null)), !i && e.currentStyle && (i = e.currentStyle), i || (i = e.style), i }(e); return i.WebKitCSSMatrix ? (s = a.transform || a.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map(e => e.replace(",", ".")).join(", ")), o = new i.WebKitCSSMatrix("none" === s ? "" : s)) : (o = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), n = o.toString().split(",")), "x" === t && (s = i.WebKitCSSMatrix ? o.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])), "y" === t && (s = i.WebKitCSSMatrix ? o.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])), s || 0 } function d(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function u() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"]; for (let n = 1; n < arguments.length; n += 1) { const s = n < 0 || arguments.length <= n ? void 0 : arguments[n]; if (null != s && (i = s, !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) { const i = Object.keys(Object(s)).filter(e => t.indexOf(e) < 0); for (let t = 0, n = i.length; t < n; t += 1) { const n = i[t], r = Object.getOwnPropertyDescriptor(s, n); void 0 !== r && r.enumerable && (d(e[n]) && d(s[n]) ? s[n].__swiper__ ? e[n] = s[n] : u(e[n], s[n]) : !d(e[n]) && d(s[n]) ? (e[n] = {}, s[n].__swiper__ ? e[n] = s[n] : u(e[n], s[n])) : e[n] = s[n]) } } } var i; return e } function p(e, t, i) { e.style.setProperty(t, i) } function f(e) { let { swiper: t, targetPosition: i, side: n } = e; const s = r(), o = -t.translate; let a, l = null; const c = t.params.speed; t.wrapperEl.style.scrollSnapType = "none", s.cancelAnimationFrame(t.cssModeFrameID); const d = i > o ? "next" : "prev", u = (e, t) => "next" === d && e >= t || "prev" === d && e <= t, p = () => { a = (new Date).getTime(), null === l && (l = a); const e = Math.max(Math.min((a - l) / c, 1), 0), r = .5 - Math.cos(e * Math.PI) / 2; let d = o + r * (i - o); if (u(d, i) && (d = i), t.wrapperEl.scrollTo({ [n]: d }), u(d, i)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout(() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({ [n]: d }) }), void s.cancelAnimationFrame(t.cssModeFrameID); t.cssModeFrameID = s.requestAnimationFrame(p) }; p() } function h(e) { return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e } function m(e, t) { void 0 === t && (t = ""); const i = r(), n = [...e.children]; return i.HTMLSlotElement && e instanceof HTMLSlotElement && n.push(...e.assignedElements()), t ? n.filter(e => e.matches(t)) : n } function g(e) { try { return void console.warn(e) } catch (e) { } } function v(e, t) { void 0 === t && (t = []); const i = document.createElement(e); return i.classList.add(...Array.isArray(t) ? t : o(t)), i } function y(e) { const t = r(), i = n(), s = e.getBoundingClientRect(), o = i.body, a = e.clientTop || o.clientTop || 0, l = e.clientLeft || o.clientLeft || 0, c = e === t ? t.scrollY : e.scrollTop, d = e === t ? t.scrollX : e.scrollLeft; return { top: s.top + c - a, left: s.left + d - l } } function b(e, t) { return r().getComputedStyle(e, null).getPropertyValue(t) } function w(e) { let t, i = e; if (i) { for (t = 0; null !== (i = i.previousSibling);)1 === i.nodeType && (t += 1); return t } } function E(e, t) { const i = []; let n = e.parentElement; for (; n;)t ? n.matches(t) && i.push(n) : i.push(n), n = n.parentElement; return i } function _(e, t) { t && e.addEventListener("transitionend", (function i(n) { n.target === e && (t.call(e, n), e.removeEventListener("transitionend", i)) })) } function x(e, t, i) { const n = r(); return i ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth } function S(e) { return (Array.isArray(e) ? e : [e]).filter(e => !!e) } function T(e) { return t => Math.abs(t) > 0 && e.browser && e.browser.need3dFix && Math.abs(t) % 90 == 0 ? t + .001 : t } let C, M, L; function I() { return C || (C = function () { const e = r(), t = n(); return { smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch) } }()), C } function A(e) { return void 0 === e && (e = {}), M || (M = function (e) { let { userAgent: t } = void 0 === e ? {} : e; const i = I(), n = r(), s = n.navigator.platform, o = t || n.navigator.userAgent, a = { ios: !1, android: !1 }, l = n.screen.width, c = n.screen.height, d = o.match(/(Android);?[\s\/]+([\d.]+)?/); let u = o.match(/(iPad).*OS\s([\d_]+)/); const p = o.match(/(iPod)(.*OS\s([\d_]+))?/), f = !u && o.match(/(iPhone\sOS|iOS)\s([\d_]+)/), h = "Win32" === s; let m = "MacIntel" === s; return !u && m && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${l}x${c}`) >= 0 && (u = o.match(/(Version)\/([\d.]+)/), u || (u = [0, 1, "13_0_0"]), m = !1), d && !h && (a.os = "android", a.android = !0), (u || f || p) && (a.os = "ios", a.ios = !0), a }(e)), M } function P() { return L || (L = function () { const e = r(), t = A(); let i = !1; function n() { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 } if (n()) { const t = String(e.navigator.userAgent); if (t.includes("Version/")) { const [e, n] = t.split("Version/")[1].split(" ")[0].split(".").map(e => Number(e)); i = e < 16 || 16 === e && n < 2 } } const s = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent), o = n(); return { isSafari: i || o, needPerspectiveFix: i, need3dFix: o || s && t.ios, isWebView: s } }()), L } const O = (e, t, i) => { t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i) }, k = (e, t, i) => { t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i) }, z = (e, t) => { if (!e || e.destroyed || !e.params) return; const i = t.closest(e.isElement ? "swiper-slide" : "." + e.params.slideClass); if (i) { let t = i.querySelector("." + e.params.lazyPreloaderClass); !t && e.isElement && (i.shadowRoot ? t = i.shadowRoot.querySelector("." + e.params.lazyPreloaderClass) : requestAnimationFrame(() => { i.shadowRoot && (t = i.shadowRoot.querySelector("." + e.params.lazyPreloaderClass), t && t.remove()) })), t && t.remove() } }, D = (e, t) => { if (!e.slides[t]) return; const i = e.slides[t].querySelector('[loading="lazy"]'); i && i.removeAttribute("loading") }, j = e => { if (!e || e.destroyed || !e.params) return; let t = e.params.lazyPreloadPrevNext; const i = e.slides.length; if (!i || !t || t < 0) return; t = Math.min(t, i); const n = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView), s = e.activeIndex; if (e.params.grid && e.params.grid.rows > 1) { const i = s, r = [i - t]; return r.push(...Array.from({ length: t }).map((e, t) => i + n + t)), void e.slides.forEach((t, i) => { r.includes(t.column) && D(e, i) }) } const r = s + n - 1; if (e.params.rewind || e.params.loop) for (let n = s - t; n <= r + t; n += 1) { const t = (n % i + i) % i; (t < s || t > r) && D(e, t) } else for (let n = Math.max(s - t, 0); n <= Math.min(r + t, i - 1); n += 1)n !== s && (n > r || n < s) && D(e, n) }; function $(e) { let { swiper: t, runCallbacks: i, direction: n, step: s } = e; const { activeIndex: r, previousIndex: o } = t; let a = n; if (a || (a = r > o ? "next" : r < o ? "prev" : "reset"), t.emit("transition" + s), i && r !== o) { if ("reset" === a) return void t.emit("slideResetTransition" + s); t.emit("slideChangeTransition" + s), "next" === a ? t.emit("slideNextTransition" + s) : t.emit("slidePrevTransition" + s) } } function N(e, t, i) { const n = r(), { params: s } = e, o = s.edgeSwipeDetection, a = s.edgeSwipeThreshold; return !o || !(i <= a || i >= n.innerWidth - a) || "prevent" === o && (t.preventDefault(), !0) } function H(e) { const t = this, i = n(); let s = e; s.originalEvent && (s = s.originalEvent); const o = t.touchEventsData; if ("pointerdown" === s.type) { if (null !== o.pointerId && o.pointerId !== s.pointerId) return; o.pointerId = s.pointerId } else "touchstart" === s.type && 1 === s.targetTouches.length && (o.touchId = s.targetTouches[0].identifier); if ("touchstart" === s.type) return void N(t, s, s.targetTouches[0].pageX); const { params: a, touches: c, enabled: d } = t; if (!d) return; if (!a.simulateTouch && "mouse" === s.pointerType) return; if (t.animating && a.preventInteractionOnTransition) return; !t.animating && a.cssMode && a.loop && t.loopFix(); let u = s.target; if ("wrapper" === a.touchEventsTarget && !function (e, t) { const i = r(); let n = t.contains(e); return !n && i.HTMLSlotElement && t instanceof HTMLSlotElement && (n = [...t.assignedElements()].includes(e), n || (n = function (e, t) { const i = [t]; for (; i.length > 0;) { const t = i.shift(); if (e === t) return !0; i.push(...t.children, ...t.shadowRoot ? t.shadowRoot.children : [], ...t.assignedElements ? t.assignedElements() : []) } }(e, t))), n }(u, t.wrapperEl)) return; if ("which" in s && 3 === s.which) return; if ("button" in s && s.button > 0) return; if (o.isTouched && o.isMoved) return; const p = !!a.noSwipingClass && "" !== a.noSwipingClass, f = s.composedPath ? s.composedPath() : s.path; p && s.target && s.target.shadowRoot && f && (u = f[0]); const h = a.noSwipingSelector ? a.noSwipingSelector : "." + a.noSwipingClass, m = !(!s.target || !s.target.shadowRoot); if (a.noSwiping && (m ? function (e, t) { return void 0 === t && (t = this), function t(i) { if (!i || i === n() || i === r()) return null; i.assignedSlot && (i = i.assignedSlot); const s = i.closest(e); return s || i.getRootNode ? s || t(i.getRootNode().host) : null }(t) }(h, u) : u.closest(h))) return void (t.allowClick = !0); if (a.swipeHandler && !u.closest(a.swipeHandler)) return; c.currentX = s.pageX, c.currentY = s.pageY; const g = c.currentX, v = c.currentY; if (!N(t, s, g)) return; Object.assign(o, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), c.startX = g, c.startY = v, o.touchStartTime = l(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, a.threshold > 0 && (o.allowThresholdMove = !1); let y = !0; u.matches(o.focusableElements) && (y = !1, "SELECT" === u.nodeName && (o.isTouched = !1)), i.activeElement && i.activeElement.matches(o.focusableElements) && i.activeElement !== u && ("mouse" === s.pointerType || "mouse" !== s.pointerType && !u.matches(o.focusableElements)) && i.activeElement.blur(); const b = y && t.allowTouchMove && a.touchStartPreventDefault; !a.touchStartForcePreventDefault && !b || u.isContentEditable || s.preventDefault(), a.freeMode && a.freeMode.enabled && t.freeMode && t.animating && !a.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", s) } function B(e) { const t = n(), i = this, s = i.touchEventsData, { params: r, touches: o, rtlTranslate: a, enabled: c } = i; if (!c) return; if (!r.simulateTouch && "mouse" === e.pointerType) return; let d, u = e; if (u.originalEvent && (u = u.originalEvent), "pointermove" === u.type) { if (null !== s.touchId) return; if (u.pointerId !== s.pointerId) return } if ("touchmove" === u.type) { if (d = [...u.changedTouches].find(e => e.identifier === s.touchId), !d || d.identifier !== s.touchId) return } else d = u; if (!s.isTouched) return void (s.startMoving && s.isScrolling && i.emit("touchMoveOpposite", u)); const p = d.pageX, f = d.pageY; if (u.preventedByNestedSwiper) return o.startX = p, void (o.startY = f); if (!i.allowTouchMove) return u.target.matches(s.focusableElements) || (i.allowClick = !1), void (s.isTouched && (Object.assign(o, { startX: p, startY: f, currentX: p, currentY: f }), s.touchStartTime = l())); if (r.touchReleaseOnEdges && !r.loop) if (i.isVertical()) { if (f < o.startY && i.translate <= i.maxTranslate() || f > o.startY && i.translate >= i.minTranslate()) return s.isTouched = !1, void (s.isMoved = !1) } else if (p < o.startX && i.translate <= i.maxTranslate() || p > o.startX && i.translate >= i.minTranslate()) return; if (t.activeElement && t.activeElement.matches(s.focusableElements) && t.activeElement !== u.target && "mouse" !== u.pointerType && t.activeElement.blur(), t.activeElement && u.target === t.activeElement && u.target.matches(s.focusableElements)) return s.isMoved = !0, void (i.allowClick = !1); s.allowTouchCallbacks && i.emit("touchMove", u), o.previousX = o.currentX, o.previousY = o.currentY, o.currentX = p, o.currentY = f; const h = o.currentX - o.startX, m = o.currentY - o.startY; if (i.params.threshold && Math.sqrt(h ** 2 + m ** 2) < i.params.threshold) return; if (void 0 === s.isScrolling) { let e; i.isHorizontal() && o.currentY === o.startY || i.isVertical() && o.currentX === o.startX ? s.isScrolling = !1 : h * h + m * m >= 25 && (e = 180 * Math.atan2(Math.abs(m), Math.abs(h)) / Math.PI, s.isScrolling = i.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle) } if (s.isScrolling && i.emit("touchMoveOpposite", u), void 0 === s.startMoving && (o.currentX === o.startX && o.currentY === o.startY || (s.startMoving = !0)), s.isScrolling || "touchmove" === u.type && s.preventTouchMoveFromPointerMove) return void (s.isTouched = !1); if (!s.startMoving) return; i.allowClick = !1, !r.cssMode && u.cancelable && u.preventDefault(), r.touchMoveStopPropagation && !r.nested && u.stopPropagation(); let g = i.isHorizontal() ? h : m, v = i.isHorizontal() ? o.currentX - o.previousX : o.currentY - o.previousY; r.oneWayMovement && (g = Math.abs(g) * (a ? 1 : -1), v = Math.abs(v) * (a ? 1 : -1)), o.diff = g, g *= r.touchRatio, a && (g = -g, v = -v); const y = i.touchesDirection; i.swipeDirection = g > 0 ? "prev" : "next", i.touchesDirection = v > 0 ? "prev" : "next"; const b = i.params.loop && !r.cssMode, w = "next" === i.touchesDirection && i.allowSlideNext || "prev" === i.touchesDirection && i.allowSlidePrev; if (!s.isMoved) { if (b && w && i.loopFix({ direction: i.swipeDirection }), s.startTranslate = i.getTranslate(), i.setTransition(0), i.animating) { const e = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0, detail: { bySwiperTouchMove: !0 } }); i.wrapperEl.dispatchEvent(e) } s.allowMomentumBounce = !1, !r.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", u) } if ((new Date).getTime(), !1 !== r._loopSwapReset && s.isMoved && s.allowThresholdMove && y !== i.touchesDirection && b && w && Math.abs(g) >= 1) return Object.assign(o, { startX: p, startY: f, currentX: p, currentY: f, startTranslate: s.currentTranslate }), s.loopSwapReset = !0, void (s.startTranslate = s.currentTranslate); i.emit("sliderMove", u), s.isMoved = !0, s.currentTranslate = g + s.startTranslate; let E = !0, _ = r.resistanceRatio; if (r.touchReleaseOnEdges && (_ = 0), g > 0 ? (b && w && s.allowThresholdMove && s.currentTranslate > (r.centeredSlides ? i.minTranslate() - i.slidesSizesGrid[i.activeIndex + 1] - ("auto" !== r.slidesPerView && i.slides.length - r.slidesPerView >= 2 ? i.slidesSizesGrid[i.activeIndex + 1] + i.params.spaceBetween : 0) - i.params.spaceBetween : i.minTranslate()) && i.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), s.currentTranslate > i.minTranslate() && (E = !1, r.resistance && (s.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + s.startTranslate + g) ** _))) : g < 0 && (b && w && s.allowThresholdMove && s.currentTranslate < (r.centeredSlides ? i.maxTranslate() + i.slidesSizesGrid[i.slidesSizesGrid.length - 1] + i.params.spaceBetween + ("auto" !== r.slidesPerView && i.slides.length - r.slidesPerView >= 2 ? i.slidesSizesGrid[i.slidesSizesGrid.length - 1] + i.params.spaceBetween : 0) : i.maxTranslate()) && i.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: i.slides.length - ("auto" === r.slidesPerView ? i.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10))) }), s.currentTranslate < i.maxTranslate() && (E = !1, r.resistance && (s.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - s.startTranslate - g) ** _))), E && (u.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && s.currentTranslate < s.startTranslate && (s.currentTranslate = s.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && s.currentTranslate > s.startTranslate && (s.currentTranslate = s.startTranslate), i.allowSlidePrev || i.allowSlideNext || (s.currentTranslate = s.startTranslate), r.threshold > 0) { if (!(Math.abs(g) > r.threshold || s.allowThresholdMove)) return void (s.currentTranslate = s.startTranslate); if (!s.allowThresholdMove) return s.allowThresholdMove = !0, o.startX = o.currentX, o.startY = o.currentY, s.currentTranslate = s.startTranslate, void (o.diff = i.isHorizontal() ? o.currentX - o.startX : o.currentY - o.startY) } r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && i.freeMode || r.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), r.freeMode && r.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(s.currentTranslate), i.setTranslate(s.currentTranslate)) } function W(e) { const t = this, i = t.touchEventsData; let n, s = e; if (s.originalEvent && (s = s.originalEvent), "touchend" === s.type || "touchcancel" === s.type) { if (n = [...s.changedTouches].find(e => e.identifier === i.touchId), !n || n.identifier !== i.touchId) return } else { if (null !== i.touchId) return; if (s.pointerId !== i.pointerId) return; n = s } if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(s.type) && (!["pointercancel", "contextmenu"].includes(s.type) || !t.browser.isSafari && !t.browser.isWebView)) return; i.pointerId = null, i.touchId = null; const { params: r, touches: o, rtlTranslate: c, slidesGrid: d, enabled: u } = t; if (!u) return; if (!r.simulateTouch && "mouse" === s.pointerType) return; if (i.allowTouchCallbacks && t.emit("touchEnd", s), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && r.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void (i.startMoving = !1); r.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const p = l(), f = p - i.touchStartTime; if (t.allowClick) { const e = s.path || s.composedPath && s.composedPath(); t.updateClickedSlide(e && e[0] || s.target, e), t.emit("tap click", s), f < 300 && p - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", s) } if (i.lastClickTime = l(), a(() => { t.destroyed || (t.allowClick = !0) }), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === o.diff && !i.loopSwapReset || i.currentTranslate === i.startTranslate && !i.loopSwapReset) return i.isTouched = !1, i.isMoved = !1, void (i.startMoving = !1); let h; if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, h = r.followFinger ? c ? t.translate : -t.translate : -i.currentTranslate, r.cssMode) return; if (r.freeMode && r.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: h }); const m = h >= -t.maxTranslate() && !t.params.loop; let g = 0, v = t.slidesSizesGrid[0]; for (let e = 0; e < d.length; e += e < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) { const t = e < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; void 0 !== d[e + t] ? (m || h >= d[e] && h < d[e + t]) && (g = e, v = d[e + t] - d[e]) : (m || h >= d[e]) && (g = e, v = d[d.length - 1] - d[d.length - 2]) } let y = null, b = null; r.rewind && (t.isBeginning ? b = r.virtual && r.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (y = 0)); const w = (h - d[g]) / v, E = g < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; if (f > r.longSwipesMs) { if (!r.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (w >= r.longSwipesRatio ? t.slideTo(r.rewind && t.isEnd ? y : g + E) : t.slideTo(g)), "prev" === t.swipeDirection && (w > 1 - r.longSwipesRatio ? t.slideTo(g + E) : null !== b && w < 0 && Math.abs(w) > r.longSwipesRatio ? t.slideTo(b) : t.slideTo(g)) } else { if (!r.shortSwipes) return void t.slideTo(t.activeIndex); !t.navigation || s.target !== t.navigation.nextEl && s.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(null !== y ? y : g + E), "prev" === t.swipeDirection && t.slideTo(null !== b ? b : g)) : s.target === t.navigation.nextEl ? t.slideTo(g + E) : t.slideTo(g) } } function R() { const e = this, { params: t, el: i } = e; if (i && 0 === i.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: n, allowSlidePrev: s, snapGrid: r } = e, o = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const a = o && t.loop; !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || a ? e.params.loop && !o ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout(() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume() }, 500)), e.allowSlidePrev = s, e.allowSlideNext = n, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() } function F(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function q() { const e = this, { wrapperEl: t, rtlTranslate: i, enabled: n } = e; if (!n) return; let s; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); s = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, s !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } function Y(e) { const t = this; z(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update() } function G() { const e = this; e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto")) } const X = (e, t) => { const i = n(), { params: s, el: r, wrapperEl: o, device: a } = e, l = !!s.nested, c = "on" === t ? "addEventListener" : "removeEventListener", d = t; r && "string" != typeof r && (i[c]("touchstart", e.onDocumentTouchStart, { passive: !1, capture: l }), r[c]("touchstart", e.onTouchStart, { passive: !1 }), r[c]("pointerdown", e.onTouchStart, { passive: !1 }), i[c]("touchmove", e.onTouchMove, { passive: !1, capture: l }), i[c]("pointermove", e.onTouchMove, { passive: !1, capture: l }), i[c]("touchend", e.onTouchEnd, { passive: !0 }), i[c]("pointerup", e.onTouchEnd, { passive: !0 }), i[c]("pointercancel", e.onTouchEnd, { passive: !0 }), i[c]("touchcancel", e.onTouchEnd, { passive: !0 }), i[c]("pointerout", e.onTouchEnd, { passive: !0 }), i[c]("pointerleave", e.onTouchEnd, { passive: !0 }), i[c]("contextmenu", e.onTouchEnd, { passive: !0 }), (s.preventClicks || s.preventClicksPropagation) && r[c]("click", e.onClick, !0), s.cssMode && o[c]("scroll", e.onScroll), s.updateOnWindowResize ? e[d](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", R, !0) : e[d]("observerUpdate", R, !0), r[c]("load", e.onLoad, { capture: !0 })) }, V = (e, t) => e.grid && t.grid && t.grid.rows > 1; var U = { init: !0, direction: "horizontal", oneWayMovement: !1, swiperElementNodeName: "SWIPER-CONTAINER", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: "swiper", enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-blank", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideFullyVisibleClass: "swiper-slide-fully-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function Q(e, t) { return function (i) { void 0 === i && (i = {}); const n = Object.keys(i)[0], s = i[n]; "object" == typeof s && null !== s ? (!0 === e[n] && (e[n] = { enabled: !0 }), "navigation" === n && e[n] && e[n].enabled && !e[n].prevEl && !e[n].nextEl && (e[n].auto = !0), ["pagination", "scrollbar"].indexOf(n) >= 0 && e[n] && e[n].enabled && !e[n].el && (e[n].auto = !0), n in e && "enabled" in s ? ("object" != typeof e[n] || "enabled" in e[n] || (e[n].enabled = !0), e[n] || (e[n] = { enabled: !1 }), u(t, i)) : u(t, i)) : u(t, i) } } const K = { eventsEmitter: { on(e, t, i) { const n = this; if (!n.eventsListeners || n.destroyed) return n; if ("function" != typeof t) return n; const s = i ? "unshift" : "push"; return e.split(" ").forEach(e => { n.eventsListeners[e] || (n.eventsListeners[e] = []), n.eventsListeners[e][s](t) }), n }, once(e, t, i) { const n = this; if (!n.eventsListeners || n.destroyed) return n; if ("function" != typeof t) return n; function s() { n.off(e, s), s.__emitterProxy && delete s.__emitterProxy; for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++)r[o] = arguments[o]; t.apply(n, r) } return s.__emitterProxy = t, n.on(e, s, i) }, onAny(e, t) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof e) return i; const n = t ? "unshift" : "push"; return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[n](e), i }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const i = t.eventsAnyListeners.indexOf(e); return i >= 0 && t.eventsAnyListeners.splice(i, 1), t }, off(e, t) { const i = this; return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach(e => { void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach((n, s) => { (n === t || n.__emitterProxy && n.__emitterProxy === t) && i.eventsListeners[e].splice(s, 1) }) }), i) : i }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let t, i, n; for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++)r[o] = arguments[o]; return "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], i = r.slice(1, r.length), n = e) : (t = r[0].events, i = r[0].data, n = r[0].context || e), i.unshift(n), (Array.isArray(t) ? t : t.split(" ")).forEach(t => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(e => { e.apply(n, [t, ...i]) }), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach(e => { e.apply(n, i) }) }), e } }, update: { updateSize: function () { const e = this; let t, i; const n = e.el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : n.clientWidth, i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : n.clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(b(n, "padding-left") || 0, 10) - parseInt(b(n, "padding-right") || 0, 10), i = i - parseInt(b(n, "padding-top") || 0, 10) - parseInt(b(n, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(i) && (i = 0), Object.assign(e, { width: t, height: i, size: e.isHorizontal() ? t : i })) }, updateSlides: function () { const e = this; function t(t, i) { return parseFloat(t.getPropertyValue(e.getDirectionLabel(i)) || 0) } const i = e.params, { wrapperEl: n, slidesEl: s, size: r, rtlTranslate: o, wrongRTL: a } = e, l = e.virtual && i.virtual.enabled, c = l ? e.virtual.slides.length : e.slides.length, d = m(s, `.${e.params.slideClass}, swiper-slide`), u = l ? e.virtual.slides.length : d.length; let f = []; const h = [], g = []; let v = i.slidesOffsetBefore; "function" == typeof v && (v = i.slidesOffsetBefore.call(e)); let y = i.slidesOffsetAfter; "function" == typeof y && (y = i.slidesOffsetAfter.call(e)); const w = e.snapGrid.length, E = e.slidesGrid.length; let _ = i.spaceBetween, S = -v, T = 0, C = 0; if (void 0 === r) return; "string" == typeof _ && _.indexOf("%") >= 0 ? _ = parseFloat(_.replace("%", "")) / 100 * r : "string" == typeof _ && (_ = parseFloat(_)), e.virtualSize = -_, d.forEach(e => { o ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = "" }), i.centeredSlides && i.cssMode && (p(n, "--swiper-centered-offset-before", ""), p(n, "--swiper-centered-offset-after", "")); const M = i.grid && i.grid.rows > 1 && e.grid; let L; M ? e.grid.initSlides(d) : e.grid && e.grid.unsetSlides(); const I = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter(e => void 0 !== i.breakpoints[e].slidesPerView).length > 0; for (let n = 0; n < u; n += 1) { let s; if (L = 0, d[n] && (s = d[n]), M && e.grid.updateSlide(n, s, d), !d[n] || "none" !== b(s, "display")) { if ("auto" === i.slidesPerView) { I && (d[n].style[e.getDirectionLabel("width")] = ""); const r = getComputedStyle(s), o = s.style.transform, a = s.style.webkitTransform; if (o && (s.style.transform = "none"), a && (s.style.webkitTransform = "none"), i.roundLengths) L = e.isHorizontal() ? x(s, "width", !0) : x(s, "height", !0); else { const e = t(r, "width"), i = t(r, "padding-left"), n = t(r, "padding-right"), o = t(r, "margin-left"), a = t(r, "margin-right"), l = r.getPropertyValue("box-sizing"); if (l && "border-box" === l) L = e + o + a; else { const { clientWidth: t, offsetWidth: r } = s; L = e + i + n + o + a + (r - t) } } o && (s.style.transform = o), a && (s.style.webkitTransform = a), i.roundLengths && (L = Math.floor(L)) } else L = (r - (i.slidesPerView - 1) * _) / i.slidesPerView, i.roundLengths && (L = Math.floor(L)), d[n] && (d[n].style[e.getDirectionLabel("width")] = L + "px"); d[n] && (d[n].swiperSlideSize = L), g.push(L), i.centeredSlides ? (S = S + L / 2 + T / 2 + _, 0 === T && 0 !== n && (S = S - r / 2 - _), 0 === n && (S = S - r / 2 - _), Math.abs(S) < .001 && (S = 0), i.roundLengths && (S = Math.floor(S)), C % i.slidesPerGroup == 0 && f.push(S), h.push(S)) : (i.roundLengths && (S = Math.floor(S)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && f.push(S), h.push(S), S = S + L + _), e.virtualSize += L + _, T = L, C += 1 } } if (e.virtualSize = Math.max(e.virtualSize, r) + y, o && a && ("slide" === i.effect || "coverflow" === i.effect) && (n.style.width = e.virtualSize + _ + "px"), i.setWrapperSize && (n.style[e.getDirectionLabel("width")] = e.virtualSize + _ + "px"), M && e.grid.updateWrapperSize(L, f), !i.centeredSlides) { const t = []; for (let n = 0; n < f.length; n += 1) { let s = f[n]; i.roundLengths && (s = Math.floor(s)), f[n] <= e.virtualSize - r && t.push(s) } f = t, Math.floor(e.virtualSize - r) - Math.floor(f[f.length - 1]) > 1 && f.push(e.virtualSize - r) } if (l && i.loop) { const t = g[0] + _; if (i.slidesPerGroup > 1) { const n = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup), s = t * i.slidesPerGroup; for (let e = 0; e < n; e += 1)f.push(f[f.length - 1] + s) } for (let n = 0; n < e.virtual.slidesBefore + e.virtual.slidesAfter; n += 1)1 === i.slidesPerGroup && f.push(f[f.length - 1] + t), h.push(h[h.length - 1] + t), e.virtualSize += t } if (0 === f.length && (f = [0]), 0 !== _) { const t = e.isHorizontal() && o ? "marginLeft" : e.getDirectionLabel("marginRight"); d.filter((e, t) => !(i.cssMode && !i.loop) || t !== d.length - 1).forEach(e => { e.style[t] = _ + "px" }) } if (i.centeredSlides && i.centeredSlidesBounds) { let e = 0; g.forEach(t => { e += t + (_ || 0) }), e -= _; const t = e > r ? e - r : 0; f = f.map(e => e <= 0 ? -v : e > t ? t + y : e) } if (i.centerInsufficientSlides) { let e = 0; g.forEach(t => { e += t + (_ || 0) }), e -= _; const t = (i.slidesOffsetBefore || 0) + (i.slidesOffsetAfter || 0); if (e + t < r) { const i = (r - e - t) / 2; f.forEach((e, t) => { f[t] = e - i }), h.forEach((e, t) => { h[t] = e + i }) } } if (Object.assign(e, { slides: d, snapGrid: f, slidesGrid: h, slidesSizesGrid: g }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) { p(n, "--swiper-centered-offset-before", -f[0] + "px"), p(n, "--swiper-centered-offset-after", e.size / 2 - g[g.length - 1] / 2 + "px"); const t = -e.snapGrid[0], i = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map(e => e + t), e.slidesGrid = e.slidesGrid.map(e => e + i) } if (u !== c && e.emit("slidesLengthChange"), f.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== E && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), e.emit("slidesUpdated"), !(l || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) { const t = i.containerModifierClass + "backface-hidden", n = e.el.classList.contains(t); u <= i.maxBackfaceHiddenSlides ? n || e.el.classList.add(t) : n && e.el.classList.remove(t) } }, updateAutoHeight: function (e) { const t = this, i = [], n = t.virtual && t.params.virtual.enabled; let s, r = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const o = e => n ? t.slides[t.getSlideIndexByData(e)] : t.slides[e]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || []).forEach(e => { i.push(e) }); else for (s = 0; s < Math.ceil(t.params.slidesPerView); s += 1) { const e = t.activeIndex + s; if (e > t.slides.length && !n) break; i.push(o(e)) } else i.push(o(t.activeIndex)); for (s = 0; s < i.length; s += 1)if (void 0 !== i[s]) { const e = i[s].offsetHeight; r = e > r ? e : r } (r || 0 === r) && (t.wrapperEl.style.height = r + "px") }, updateSlidesOffset: function () { const e = this, t = e.slides, i = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0; for (let n = 0; n < t.length; n += 1)t[n].swiperSlideOffset = (e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop) - i - e.cssOverflowAdjustment() }, updateSlidesProgress: function (e) { void 0 === e && (e = this && this.translate || 0); const t = this, i = t.params, { slides: n, rtlTranslate: s, snapGrid: r } = t; if (0 === n.length) return; void 0 === n[0].swiperSlideOffset && t.updateSlidesOffset(); let o = -e; s && (o = e), t.visibleSlidesIndexes = [], t.visibleSlides = []; let a = i.spaceBetween; "string" == typeof a && a.indexOf("%") >= 0 ? a = parseFloat(a.replace("%", "")) / 100 * t.size : "string" == typeof a && (a = parseFloat(a)); for (let e = 0; e < n.length; e += 1) { const l = n[e]; let c = l.swiperSlideOffset; i.cssMode && i.centeredSlides && (c -= n[0].swiperSlideOffset); const d = (o + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + a), u = (o - r[0] + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + a), p = -(o - c), f = p + t.slidesSizesGrid[e], h = p >= 0 && p <= t.size - t.slidesSizesGrid[e], m = p >= 0 && p < t.size - 1 || f > 1 && f <= t.size || p <= 0 && f >= t.size; m && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e)), O(l, m, i.slideVisibleClass), O(l, h, i.slideFullyVisibleClass), l.progress = s ? -d : d, l.originalProgress = s ? -u : u } }, updateProgress: function (e) { const t = this; if (void 0 === e) { const i = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * i || 0 } const i = t.params, n = t.maxTranslate() - t.minTranslate(); let { progress: s, isBeginning: r, isEnd: o, progressLoop: a } = t; const l = r, c = o; if (0 === n) s = 0, r = !0, o = !0; else { s = (e - t.minTranslate()) / n; const i = Math.abs(e - t.minTranslate()) < 1, a = Math.abs(e - t.maxTranslate()) < 1; r = i || s <= 0, o = a || s >= 1, i && (s = 0), a && (s = 1) } if (i.loop) { const i = t.getSlideIndexByData(0), n = t.getSlideIndexByData(t.slides.length - 1), s = t.slidesGrid[i], r = t.slidesGrid[n], o = t.slidesGrid[t.slidesGrid.length - 1], l = Math.abs(e); a = l >= s ? (l - s) / o : (l + o - r) / o, a > 1 && (a -= 1) } Object.assign(t, { progress: s, progressLoop: a, isBeginning: r, isEnd: o }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), o && !c && t.emit("reachEnd toEdge"), (l && !r || c && !o) && t.emit("fromEdge"), t.emit("progress", s) }, updateSlidesClasses: function () { const e = this, { slides: t, params: i, slidesEl: n, activeIndex: s } = e, r = e.virtual && i.virtual.enabled, o = e.grid && i.grid && i.grid.rows > 1, a = e => m(n, `.${i.slideClass}${e}, swiper-slide${e}`)[0]; let l, c, d; if (r) if (i.loop) { let t = s - e.virtual.slidesBefore; t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), l = a(`[data-swiper-slide-index="${t}"]`) } else l = a(`[data-swiper-slide-index="${s}"]`); else o ? (l = t.find(e => e.column === s), d = t.find(e => e.column === s + 1), c = t.find(e => e.column === s - 1)) : l = t[s]; l && (o || (d = function (e, t) { const i = []; for (; e.nextElementSibling;) { const n = e.nextElementSibling; t ? n.matches(t) && i.push(n) : i.push(n), e = n } return i }(l, `.${i.slideClass}, swiper-slide`)[0], i.loop && !d && (d = t[0]), c = function (e, t) { const i = []; for (; e.previousElementSibling;) { const n = e.previousElementSibling; t ? n.matches(t) && i.push(n) : i.push(n), e = n } return i }(l, `.${i.slideClass}, swiper-slide`)[0], i.loop && 0 === !c && (c = t[t.length - 1]))), t.forEach(e => { k(e, e === l, i.slideActiveClass), k(e, e === d, i.slideNextClass), k(e, e === c, i.slidePrevClass) }), e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, i = t.rtlTranslate ? t.translate : -t.translate, { snapGrid: n, params: s, activeIndex: r, realIndex: o, snapIndex: a } = t; let l, c = e; const d = e => { let i = e - t.virtual.slidesBefore; return i < 0 && (i = t.virtual.slides.length + i), i >= t.virtual.slides.length && (i -= t.virtual.slides.length), i }; if (void 0 === c && (c = function (e) { const { slidesGrid: t, params: i } = e, n = e.rtlTranslate ? e.translate : -e.translate; let s; for (let e = 0; e < t.length; e += 1)void 0 !== t[e + 1] ? n >= t[e] && n < t[e + 1] - (t[e + 1] - t[e]) / 2 ? s = e : n >= t[e] && n < t[e + 1] && (s = e + 1) : n >= t[e] && (s = e); return i.normalizeSlideIndex && (s < 0 || void 0 === s) && (s = 0), s }(t)), n.indexOf(i) >= 0) l = n.indexOf(i); else { const e = Math.min(s.slidesPerGroupSkip, c); l = e + Math.floor((c - e) / s.slidesPerGroup) } if (l >= n.length && (l = n.length - 1), c === r && !t.params.loop) return void (l !== a && (t.snapIndex = l, t.emit("snapIndexChange"))); if (c === r && t.params.loop && t.virtual && t.params.virtual.enabled) return void (t.realIndex = d(c)); const u = t.grid && s.grid && s.grid.rows > 1; let p; if (t.virtual && s.virtual.enabled && s.loop) p = d(c); else if (u) { const e = t.slides.find(e => e.column === c); let i = parseInt(e.getAttribute("data-swiper-slide-index"), 10); Number.isNaN(i) && (i = Math.max(t.slides.indexOf(e), 0)), p = Math.floor(i / s.grid.rows) } else if (t.slides[c]) { const e = t.slides[c].getAttribute("data-swiper-slide-index"); p = e ? parseInt(e, 10) : c } else p = c; Object.assign(t, { previousSnapIndex: a, snapIndex: l, previousRealIndex: o, realIndex: p, previousIndex: r, activeIndex: c }), t.initialized && j(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (o !== p && t.emit("realIndexChange"), t.emit("slideChange")) }, updateClickedSlide: function (e, t) { const i = this, n = i.params; let s = e.closest(`.${n.slideClass}, swiper-slide`); !s && i.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach(e => { !s && e.matches && e.matches(`.${n.slideClass}, swiper-slide`) && (s = e) }); let r, o = !1; if (s) for (let e = 0; e < i.slides.length; e += 1)if (i.slides[e] === s) { o = !0, r = e; break } if (!s || !o) return i.clickedSlide = void 0, void (i.clickedIndex = void 0); i.clickedSlide = s, i.virtual && i.params.virtual.enabled ? i.clickedIndex = parseInt(s.getAttribute("data-swiper-slide-index"), 10) : i.clickedIndex = r, n.slideToClickedSlide && void 0 !== i.clickedIndex && i.clickedIndex !== i.activeIndex && i.slideToClickedSlide() } }, translate: { getTranslate: function (e) { void 0 === e && (e = this.isHorizontal() ? "x" : "y"); const { params: t, rtlTranslate: i, translate: n, wrapperEl: s } = this; if (t.virtualTranslate) return i ? -n : n; if (t.cssMode) return n; let r = c(s, e); return r += this.cssOverflowAdjustment(), i && (r = -r), r || 0 }, setTranslate: function (e, t) { const i = this, { rtlTranslate: n, params: s, wrapperEl: r, progress: o } = i; let a, l = 0, c = 0; i.isHorizontal() ? l = n ? -e : e : c = e, s.roundLengths && (l = Math.floor(l), c = Math.floor(c)), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? l : c, s.cssMode ? r[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -l : -c : s.virtualTranslate || (i.isHorizontal() ? l -= i.cssOverflowAdjustment() : c -= i.cssOverflowAdjustment(), r.style.transform = `translate3d(${l}px, ${c}px, 0px)`); const d = i.maxTranslate() - i.minTranslate(); a = 0 === d ? 0 : (e - i.minTranslate()) / d, a !== o && i.updateProgress(e), i.emit("setTranslate", i.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e, t, i, n, s) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), void 0 === n && (n = !0); const r = this, { params: o, wrapperEl: a } = r; if (r.animating && o.preventInteractionOnTransition) return !1; const l = r.minTranslate(), c = r.maxTranslate(); let d; if (d = n && e > l ? l : n && e < c ? c : e, r.updateProgress(d), o.cssMode) { const e = r.isHorizontal(); if (0 === t) a[e ? "scrollLeft" : "scrollTop"] = -d; else { if (!r.support.smoothScroll) return f({ swiper: r, targetPosition: -d, side: e ? "left" : "top" }), !0; a.scrollTo({ [e ? "left" : "top"]: -d, behavior: "smooth" }) } return !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(d), i && (r.emit("beforeTransitionStart", t, s), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(d), i && (r.emit("beforeTransitionStart", t, s), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, r.animating = !1, i && r.emit("transitionEnd")) }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0 } }, transition: { setTransition: function (e, t) { const i = this; i.params.cssMode || (i.wrapperEl.style.transitionDuration = e + "ms", i.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), i.emit("setTransition", e, t) }, transitionStart: function (e, t) { void 0 === e && (e = !0); const i = this, { params: n } = i; n.cssMode || (n.autoHeight && i.updateAutoHeight(), $({ swiper: i, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e, t) { void 0 === e && (e = !0); const i = this, { params: n } = i; i.animating = !1, n.cssMode || (i.setTransition(0), $({ swiper: i, runCallbacks: e, direction: t, step: "End" })) } }, slide: { slideTo: function (e, t, i, n, s) { void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e && (e = parseInt(e, 10)); const r = this; let o = e; o < 0 && (o = 0); const { params: a, snapGrid: l, slidesGrid: c, previousIndex: d, activeIndex: u, rtlTranslate: p, wrapperEl: h, enabled: m } = r; if (!m && !n && !s || r.destroyed || r.animating && a.preventInteractionOnTransition) return !1; void 0 === t && (t = r.params.speed); const g = Math.min(r.params.slidesPerGroupSkip, o); let v = g + Math.floor((o - g) / r.params.slidesPerGroup); v >= l.length && (v = l.length - 1); const y = -l[v]; if (a.normalizeSlideIndex) for (let e = 0; e < c.length; e += 1) { const t = -Math.floor(100 * y), i = Math.floor(100 * c[e]), n = Math.floor(100 * c[e + 1]); void 0 !== c[e + 1] ? t >= i && t < n - (n - i) / 2 ? o = e : t >= i && t < n && (o = e + 1) : t >= i && (o = e) } if (r.initialized && o !== u) { if (!r.allowSlideNext && (p ? y > r.translate && y > r.minTranslate() : y < r.translate && y < r.minTranslate())) return !1; if (!r.allowSlidePrev && y > r.translate && y > r.maxTranslate() && (u || 0) !== o) return !1 } let b; o !== (d || 0) && i && r.emit("beforeSlideChangeStart"), r.updateProgress(y), b = o > u ? "next" : o < u ? "prev" : "reset"; const w = r.virtual && r.params.virtual.enabled; if ((!w || !s) && (p && -y === r.translate || !p && y === r.translate)) return r.updateActiveIndex(o), a.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== a.effect && r.setTranslate(y), "reset" !== b && (r.transitionStart(i, b), r.transitionEnd(i, b)), !1; if (a.cssMode) { const e = r.isHorizontal(), i = p ? y : -y; if (0 === t) w && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), w && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => { h[e ? "scrollLeft" : "scrollTop"] = i })) : h[e ? "scrollLeft" : "scrollTop"] = i, w && requestAnimationFrame(() => { r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1 }); else { if (!r.support.smoothScroll) return f({ swiper: r, targetPosition: i, side: e ? "left" : "top" }), !0; h.scrollTo({ [e ? "left" : "top"]: i, behavior: "smooth" }) } return !0 } const E = P().isSafari; return w && !s && E && r.isElement && r.virtual.update(!1, !1, o), r.setTransition(t), r.setTranslate(y), r.updateActiveIndex(o), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, n), r.transitionStart(i, b), 0 === t ? r.transitionEnd(i, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(i, b)) }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e, t, i, n) { void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e && (e = parseInt(e, 10)); const s = this; if (s.destroyed) return; void 0 === t && (t = s.params.speed); const r = s.grid && s.params.grid && s.params.grid.rows > 1; let o = e; if (s.params.loop) if (s.virtual && s.params.virtual.enabled) o += s.virtual.slidesBefore; else { let e; if (r) { const t = o * s.params.grid.rows; e = s.slides.find(e => 1 * e.getAttribute("data-swiper-slide-index") === t).column } else e = s.getSlideIndexByData(o); const t = r ? Math.ceil(s.slides.length / s.params.grid.rows) : s.slides.length, { centeredSlides: i } = s.params; let a = s.params.slidesPerView; "auto" === a ? a = s.slidesPerViewDynamic() : (a = Math.ceil(parseFloat(s.params.slidesPerView, 10)), i && a % 2 == 0 && (a += 1)); let l = t - e < a; if (i && (l = l || e < Math.ceil(a / 2)), n && i && "auto" !== s.params.slidesPerView && !r && (l = !1), l) { const n = i ? e < s.activeIndex ? "prev" : "next" : e - s.activeIndex - 1 < s.params.slidesPerView ? "next" : "prev"; s.loopFix({ direction: n, slideTo: !0, activeSlideIndex: "next" === n ? e + 1 : e - t + 1, slideRealIndex: "next" === n ? s.realIndex : void 0 }) } if (r) { const e = o * s.params.grid.rows; o = s.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e).column } else o = s.getSlideIndexByData(o) } return requestAnimationFrame(() => { s.slideTo(o, t, i, n) }), s }, slideNext: function (e, t, i) { void 0 === t && (t = !0); const n = this, { enabled: s, params: r, animating: o } = n; if (!s || n.destroyed) return n; void 0 === e && (e = n.params.speed); let a = r.slidesPerGroup; "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (a = Math.max(n.slidesPerViewDynamic("current", !0), 1)); const l = n.activeIndex < r.slidesPerGroupSkip ? 1 : a, c = n.virtual && r.virtual.enabled; if (r.loop) { if (o && !c && r.loopPreventsSliding) return !1; if (n.loopFix({ direction: "next" }), n._clientLeft = n.wrapperEl.clientLeft, n.activeIndex === n.slides.length - 1 && r.cssMode) return requestAnimationFrame(() => { n.slideTo(n.activeIndex + l, e, t, i) }), !0 } return r.rewind && n.isEnd ? n.slideTo(0, e, t, i) : n.slideTo(n.activeIndex + l, e, t, i) }, slidePrev: function (e, t, i) { void 0 === t && (t = !0); const n = this, { params: s, snapGrid: r, slidesGrid: o, rtlTranslate: a, enabled: l, animating: c } = n; if (!l || n.destroyed) return n; void 0 === e && (e = n.params.speed); const d = n.virtual && s.virtual.enabled; if (s.loop) { if (c && !d && s.loopPreventsSliding) return !1; n.loopFix({ direction: "prev" }), n._clientLeft = n.wrapperEl.clientLeft } function u(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const p = u(a ? n.translate : -n.translate), f = r.map(e => u(e)), h = s.freeMode && s.freeMode.enabled; let m = r[f.indexOf(p) - 1]; if (void 0 === m && (s.cssMode || h)) { let e; r.forEach((t, i) => { p >= t && (e = i) }), void 0 !== e && (m = h ? r[e] : r[e > 0 ? e - 1 : e]) } let g = 0; if (void 0 !== m && (g = o.indexOf(m), g < 0 && (g = n.activeIndex - 1), "auto" === s.slidesPerView && 1 === s.slidesPerGroup && s.slidesPerGroupAuto && (g = g - n.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), s.rewind && n.isBeginning) { const s = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1; return n.slideTo(s, e, t, i) } return s.loop && 0 === n.activeIndex && s.cssMode ? (requestAnimationFrame(() => { n.slideTo(g, e, t, i) }), !0) : n.slideTo(g, e, t, i) }, slideReset: function (e, t, i) { void 0 === t && (t = !0); const n = this; if (!n.destroyed) return void 0 === e && (e = n.params.speed), n.slideTo(n.activeIndex, e, t, i) }, slideToClosest: function (e, t, i, n) { void 0 === t && (t = !0), void 0 === n && (n = .5); const s = this; if (s.destroyed) return; void 0 === e && (e = s.params.speed); let r = s.activeIndex; const o = Math.min(s.params.slidesPerGroupSkip, r), a = o + Math.floor((r - o) / s.params.slidesPerGroup), l = s.rtlTranslate ? s.translate : -s.translate; if (l >= s.snapGrid[a]) { const e = s.snapGrid[a]; l - e > (s.snapGrid[a + 1] - e) * n && (r += s.params.slidesPerGroup) } else { const e = s.snapGrid[a - 1]; l - e <= (s.snapGrid[a] - e) * n && (r -= s.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, s.slidesGrid.length - 1), s.slideTo(r, e, t, i) }, slideToClickedSlide: function () { const e = this; if (e.destroyed) return; const { params: t, slidesEl: i } = e, n = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let s, r = e.clickedIndex; const o = e.isElement ? "swiper-slide" : "." + t.slideClass; if (t.loop) { if (e.animating) return; s = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - n / 2 || r > e.slides.length - e.loopedSlides + n / 2 ? (e.loopFix(), r = e.getSlideIndex(m(i, `${o}[data-swiper-slide-index="${s}"]`)[0]), a(() => { e.slideTo(r) })) : e.slideTo(r) : r > e.slides.length - n ? (e.loopFix(), r = e.getSlideIndex(m(i, `${o}[data-swiper-slide-index="${s}"]`)[0]), a(() => { e.slideTo(r) })) : e.slideTo(r) } else e.slideTo(r) } }, loop: { loopCreate: function (e) { const t = this, { params: i, slidesEl: n } = t; if (!i.loop || t.virtual && t.params.virtual.enabled) return; const s = () => { m(n, `.${i.slideClass}, swiper-slide`).forEach((e, t) => { e.setAttribute("data-swiper-slide-index", t) }) }, r = t.grid && i.grid && i.grid.rows > 1, o = i.slidesPerGroup * (r ? i.grid.rows : 1), a = t.slides.length % o != 0, l = r && t.slides.length % i.grid.rows != 0, c = e => { for (let n = 0; n < e; n += 1) { const e = t.isElement ? v("swiper-slide", [i.slideBlankClass]) : v("div", [i.slideClass, i.slideBlankClass]); t.slidesEl.append(e) } }; a ? (i.loopAddBlankSlides ? (c(o - t.slides.length % o), t.recalcSlides(), t.updateSlides()) : g("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"), s()) : l ? (i.loopAddBlankSlides ? (c(i.grid.rows - t.slides.length % i.grid.rows), t.recalcSlides(), t.updateSlides()) : g("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"), s()) : s(), t.loopFix({ slideRealIndex: e, direction: i.centeredSlides ? void 0 : "next" }) }, loopFix: function (e) { let { slideRealIndex: t, slideTo: i = !0, direction: n, setTranslate: s, activeSlideIndex: r, byController: o, byMousewheel: a } = void 0 === e ? {} : e; const l = this; if (!l.params.loop) return; l.emit("beforeLoopFix"); const { slides: c, allowSlidePrev: d, allowSlideNext: u, slidesEl: p, params: f } = l, { centeredSlides: h } = f; if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && f.virtual.enabled) return i && (f.centeredSlides || 0 !== l.snapIndex ? f.centeredSlides && l.snapIndex < f.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)), l.allowSlidePrev = d, l.allowSlideNext = u, void l.emit("loopFix"); let m = f.slidesPerView; "auto" === m ? m = l.slidesPerViewDynamic() : (m = Math.ceil(parseFloat(f.slidesPerView, 10)), h && m % 2 == 0 && (m += 1)); const v = f.slidesPerGroupAuto ? m : f.slidesPerGroup; let y = v; y % v != 0 && (y += v - y % v), y += f.loopAdditionalSlides, l.loopedSlides = y; const b = l.grid && f.grid && f.grid.rows > 1; c.length < m + y ? g("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : b && "row" === f.grid.fill && g("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"); const w = [], E = []; let _ = l.activeIndex; void 0 === r ? r = l.getSlideIndex(c.find(e => e.classList.contains(f.slideActiveClass))) : _ = r; const x = "next" === n || !n, S = "prev" === n || !n; let T = 0, C = 0; const M = b ? Math.ceil(c.length / f.grid.rows) : c.length, L = (b ? c[r].column : r) + (h && void 0 === s ? -m / 2 + .5 : 0); if (L < y) { T = Math.max(y - L, v); for (let e = 0; e < y - L; e += 1) { const t = e - Math.floor(e / M) * M; if (b) { const e = M - t - 1; for (let t = c.length - 1; t >= 0; t -= 1)c[t].column === e && w.push(t) } else w.push(M - t - 1) } } else if (L + m > M - y) { C = Math.max(L - (M - 2 * y), v); for (let e = 0; e < C; e += 1) { const t = e - Math.floor(e / M) * M; b ? c.forEach((e, i) => { e.column === t && E.push(i) }) : E.push(t) } } if (l.__preventObserver__ = !0, requestAnimationFrame(() => { l.__preventObserver__ = !1 }), S && w.forEach(e => { c[e].swiperLoopMoveDOM = !0, p.prepend(c[e]), c[e].swiperLoopMoveDOM = !1 }), x && E.forEach(e => { c[e].swiperLoopMoveDOM = !0, p.append(c[e]), c[e].swiperLoopMoveDOM = !1 }), l.recalcSlides(), "auto" === f.slidesPerView ? l.updateSlides() : b && (w.length > 0 && S || E.length > 0 && x) && l.slides.forEach((e, t) => { l.grid.updateSlide(t, e, l.slides) }), f.watchSlidesProgress && l.updateSlidesOffset(), i) if (w.length > 0 && S) { if (void 0 === t) { const e = l.slidesGrid[_], t = l.slidesGrid[_ + T] - e; a ? l.setTranslate(l.translate - t) : (l.slideTo(_ + Math.ceil(T), 0, !1, !0), s && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t)) } else if (s) { const e = b ? w.length / f.grid.rows : w.length; l.slideTo(l.activeIndex + e, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate } } else if (E.length > 0 && x) if (void 0 === t) { const e = l.slidesGrid[_], t = l.slidesGrid[_ - C] - e; a ? l.setTranslate(l.translate - t) : (l.slideTo(_ - C, 0, !1, !0), s && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t)) } else { const e = b ? E.length / f.grid.rows : E.length; l.slideTo(l.activeIndex - e, 0, !1, !0) } if (l.allowSlidePrev = d, l.allowSlideNext = u, l.controller && l.controller.control && !o) { const e = { slideRealIndex: t, direction: n, setTranslate: s, activeSlideIndex: r, byController: !0 }; Array.isArray(l.controller.control) ? l.controller.control.forEach(t => { !t.destroyed && t.params.loop && t.loopFix({ ...e, slideTo: t.params.slidesPerView === f.slidesPerView && i }) }) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({ ...e, slideTo: l.controller.control.params.slidesPerView === f.slidesPerView && i }) } l.emit("loopFix") }, loopDestroy: function () { const e = this, { params: t, slidesEl: i } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; e.recalcSlides(); const n = []; e.slides.forEach(e => { const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex; n[t] = e }), e.slides.forEach(e => { e.removeAttribute("data-swiper-slide-index") }), n.forEach(e => { i.append(e) }), e.recalcSlides(), e.slideTo(e.realIndex, 0) } }, grabCursor: { setGrabCursor: function (e) { const t = this; if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame(() => { t.__preventObserver__ = !1 }) }, unsetGrabCursor: function () { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame(() => { e.__preventObserver__ = !1 })) } }, events: { attachEvents: function () { const e = this, { params: t } = e; e.onTouchStart = H.bind(e), e.onTouchMove = B.bind(e), e.onTouchEnd = W.bind(e), e.onDocumentTouchStart = G.bind(e), t.cssMode && (e.onScroll = q.bind(e)), e.onClick = F.bind(e), e.onLoad = Y.bind(e), X(e, "on") }, detachEvents: function () { X(this, "off") } }, breakpoints: { setBreakpoint: function () { const e = this, { realIndex: t, initialized: i, params: s, el: r } = e, o = s.breakpoints; if (!o || o && 0 === Object.keys(o).length) return; const a = n(), l = "window" !== s.breakpointsBase && s.breakpointsBase ? "container" : s.breakpointsBase, c = ["window", "container"].includes(s.breakpointsBase) || !s.breakpointsBase ? e.el : a.querySelector(s.breakpointsBase), d = e.getBreakpoint(o, l, c); if (!d || e.currentBreakpoint === d) return; const p = (d in o ? o[d] : void 0) || e.originalParams, f = V(e, s), h = V(e, p), m = e.params.grabCursor, g = p.grabCursor, v = s.enabled; f && !h ? (r.classList.remove(s.containerModifierClass + "grid", s.containerModifierClass + "grid-column"), e.emitContainerClasses()) : !f && h && (r.classList.add(s.containerModifierClass + "grid"), (p.grid.fill && "column" === p.grid.fill || !p.grid.fill && "column" === s.grid.fill) && r.classList.add(s.containerModifierClass + "grid-column"), e.emitContainerClasses()), m && !g ? e.unsetGrabCursor() : !m && g && e.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(t => { if (void 0 === p[t]) return; const i = s[t] && s[t].enabled, n = p[t] && p[t].enabled; i && !n && e[t].disable(), !i && n && e[t].enable() }); const y = p.direction && p.direction !== s.direction, b = s.loop && (p.slidesPerView !== s.slidesPerView || y), w = s.loop; y && i && e.changeDirection(), u(e.params, p); const E = e.params.enabled, _ = e.params.loop; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), v && !E ? e.disable() : !v && E && e.enable(), e.currentBreakpoint = d, e.emit("_beforeBreakpoint", p), i && (b ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !w && _ ? (e.loopCreate(t), e.updateSlides()) : w && !_ && e.loopDestroy()), e.emit("breakpoint", p) }, getBreakpoint: function (e, t, i) { if (void 0 === t && (t = "window"), !e || "container" === t && !i) return; let n = !1; const s = r(), o = "window" === t ? s.innerHeight : i.clientHeight, a = Object.keys(e).map(e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: o * t, point: e } } return { value: e, point: e } }); a.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)); for (let e = 0; e < a.length; e += 1) { const { point: r, value: o } = a[e]; "window" === t ? s.matchMedia(`(min-width: ${o}px)`).matches && (n = r) : o <= i.clientWidth && (n = r) } return n || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: i } = e, { slidesOffsetBefore: n } = i; if (n) { const t = e.slides.length - 1, i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * n; e.isLocked = e.size > i } else e.isLocked = 1 === e.snapGrid.length; !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: { addClasses: function () { const e = this, { classNames: t, params: i, rtl: n, el: s, device: r } = e, o = function (e, t) { const i = []; return e.forEach(e => { "object" == typeof e ? Object.keys(e).forEach(n => { e[n] && i.push(t + n) }) : "string" == typeof e && i.push(t + e) }), i }(["initialized", i.direction, { "free-mode": e.params.freeMode && i.freeMode.enabled }, { autoheight: i.autoHeight }, { rtl: n }, { grid: i.grid && i.grid.rows > 1 }, { "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": i.cssMode }, { centered: i.cssMode && i.centeredSlides }, { "watch-progress": i.watchSlidesProgress }], i.containerModifierClass); t.push(...o), s.classList.add(...t), e.emitContainerClasses() }, removeClasses: function () { const { el: e, classNames: t } = this; e && "string" != typeof e && (e.classList.remove(...t), this.emitContainerClasses()) } } }, Z = {}; class J { constructor() { let e, t; for (var i = arguments.length, s = new Array(i), r = 0; r < i; r++)s[r] = arguments[r]; 1 === s.length && s[0].constructor && "Object" === Object.prototype.toString.call(s[0]).slice(8, -1) ? t = s[0] : [e, t] = s, t || (t = {}), t = u({}, t), e && !t.el && (t.el = e); const o = n(); if (t.el && "string" == typeof t.el && o.querySelectorAll(t.el).length > 1) { const e = []; return o.querySelectorAll(t.el).forEach(i => { const n = u({}, t, { el: i }); e.push(new J(n)) }), e } const a = this; a.__swiper__ = !0, a.support = I(), a.device = A({ userAgent: t.userAgent }), a.browser = P(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], t.modules && Array.isArray(t.modules) && a.modules.push(...t.modules); const l = {}; a.modules.forEach(e => { e({ params: t, swiper: a, extendParams: Q(t, l), on: a.on.bind(a), once: a.once.bind(a), off: a.off.bind(a), emit: a.emit.bind(a) }) }); const c = u({}, U, l); return a.params = u({}, c, Z, t), a.originalParams = u({}, a.params), a.passedParams = u({}, t), a.params && a.params.on && Object.keys(a.params.on).forEach(e => { a.on(e, a.params.on[e]) }), a.params && a.params.onAny && a.onAny(a.params.onAny), Object.assign(a, { enabled: a.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === a.params.direction, isVertical: () => "vertical" === a.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: a.params.allowSlideNext, allowSlidePrev: a.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: a.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: a.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), a.emit("_swiper"), a.params.init && a.init(), a } getDirectionLabel(e) { return this.isHorizontal() ? e : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[e] } getSlideIndex(e) { const { slidesEl: t, params: i } = this, n = w(m(t, `.${i.slideClass}, swiper-slide`)[0]); return w(e) - n } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e)) } recalcSlides() { const { slidesEl: e, params: t } = this; this.slides = m(e, `.${t.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const i = this; e = Math.min(Math.max(e, 0), 1); const n = i.minTranslate(), s = (i.maxTranslate() - n) * e + n; i.translateTo(s, void 0 === t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter(t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter(e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass)).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach(i => { const n = e.getSlideClasses(i); t.push({ slideEl: i, classNames: n }), e.emit("_slideClass", i, n) }), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { void 0 === e && (e = "current"), void 0 === t && (t = !1); const { params: i, slides: n, slidesGrid: s, slidesSizesGrid: r, size: o, activeIndex: a } = this; let l = 1; if ("number" == typeof i.slidesPerView) return i.slidesPerView; if (i.centeredSlides) { let e, t = n[a] ? Math.ceil(n[a].swiperSlideSize) : 0; for (let i = a + 1; i < n.length; i += 1)n[i] && !e && (t += Math.ceil(n[i].swiperSlideSize), l += 1, t > o && (e = !0)); for (let i = a - 1; i >= 0; i -= 1)n[i] && !e && (t += n[i].swiperSlideSize, l += 1, t > o && (e = !0)) } else if ("current" === e) for (let e = a + 1; e < n.length; e += 1)(t ? s[e] + r[e] - s[a] < o : s[e] - s[a] < o) && (l += 1); else for (let e = a - 1; e >= 0; e -= 1)s[a] - s[e] < o && (l += 1); return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: i } = e; function n() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses() } let s; if (i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(t => { t.complete && z(e, t) }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), i.freeMode && i.freeMode.enabled && !i.cssMode) n(), i.autoHeight && e.updateAutoHeight(); else { if (("auto" === i.slidesPerView || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) { const t = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides; s = e.slideTo(t.length - 1, 0, !1, !0) } else s = e.slideTo(e.activeIndex, 0, !1, !0); s || n() } i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t) { void 0 === t && (t = !0); const i = this, n = i.params.direction; return e || (e = "horizontal" === n ? "vertical" : "horizontal"), e === n || "horizontal" !== e && "vertical" !== e || (i.el.classList.remove(`${i.params.containerModifierClass}${n}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach(t => { "vertical" === e ? t.style.width = "" : t.style.height = "" }), i.emit("changeDirection"), t && i.update()), i } changeLanguageDirection(e) { const t = this; t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(t.params.containerModifierClass + "rtl"), t.el.dir = "rtl") : (t.el.classList.remove(t.params.containerModifierClass + "rtl"), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let i = e || t.params.el; if ("string" == typeof i && (i = document.querySelector(i)), !i) return !1; i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0); const n = () => "." + (t.params.wrapperClass || "").trim().split(" ").join("."); let s = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(n()) : m(i, n())[0]; return !s && t.params.createElements && (s = v("div", t.params.wrapperClass), i.append(s), m(i, "." + t.params.slideClass).forEach(e => { s.append(e) })), Object.assign(t, { el: i, wrapperEl: s, slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : s, hostEl: t.isElement ? i.parentNode.host : i, mounted: !0, rtl: "rtl" === i.dir.toLowerCase() || "rtl" === b(i, "direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === i.dir.toLowerCase() || "rtl" === b(i, "direction")), wrongRTL: "-webkit-box" === b(s, "display") }), !0 } init(e) { const t = this; if (t.initialized) return t; if (!1 === t.mount(e)) return t; t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(); const i = [...t.el.querySelectorAll('[loading="lazy"]')]; return t.isElement && i.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), i.forEach(e => { e.complete ? z(t, e) : e.addEventListener("load", e => { z(t, e.target) }) }), j(t), t.initialized = !0, j(t), t.emit("init"), t.emit("afterInit"), t } destroy(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const i = this, { params: n, el: s, wrapperEl: r, slides: o } = i; return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), n.loop && i.loopDestroy(), t && (i.removeClasses(), s && "string" != typeof s && s.removeAttribute("style"), r && r.removeAttribute("style"), o && o.length && o.forEach(e => { e.classList.remove(n.slideVisibleClass, n.slideFullyVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index") })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(e => { i.off(e) }), !1 !== e && (i.el && "string" != typeof i.el && (i.el.swiper = null), function (e) { const t = e; Object.keys(t).forEach(e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } }) }(i)), i.destroyed = !0), null } static extendDefaults(e) { u(Z, e) } static get extendedDefaults() { return Z } static get defaults() { return U } static installModule(e) { J.prototype.__modules__ || (J.prototype.__modules__ = []); const t = J.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach(e => J.installModule(e)), J) : (J.installModule(e), J) } } function ee(e, t, i, n) { return e.params.createElements && Object.keys(n).forEach(s => { if (!i[s] && !0 === i.auto) { let r = m(e.el, "." + n[s])[0]; r || (r = v("div", n[s]), r.className = n[s], e.el.append(r)), i[s] = r, t[s] = r } }), i } function te(e) { return void 0 === e && (e = ""), "." + e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".") } function ie(e) { const t = this, { params: i, slidesEl: n } = t; i.loop && t.loopDestroy(); const s = e => { if ("string" == typeof e) { const t = document.createElement("div"); t.innerHTML = e, n.append(t.children[0]), t.innerHTML = "" } else n.append(e) }; if ("object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && s(e[t]); else s(e); t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update() } function ne(e) { const t = this, { params: i, activeIndex: n, slidesEl: s } = t; i.loop && t.loopDestroy(); let r = n + 1; const o = e => { if ("string" == typeof e) { const t = document.createElement("div"); t.innerHTML = e, s.prepend(t.children[0]), t.innerHTML = "" } else s.prepend(e) }; if ("object" == typeof e && "length" in e) { for (let t = 0; t < e.length; t += 1)e[t] && o(e[t]); r = n + e.length } else o(e); t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update(), t.slideTo(r, 0, !1) } function se(e, t) { const i = this, { params: n, activeIndex: s, slidesEl: r } = i; let o = s; n.loop && (o -= i.loopedSlides, i.loopDestroy(), i.recalcSlides()); const a = i.slides.length; if (e <= 0) return void i.prependSlide(t); if (e >= a) return void i.appendSlide(t); let l = o > e ? o + 1 : o; const c = []; for (let t = a - 1; t >= e; t -= 1) { const e = i.slides[t]; e.remove(), c.unshift(e) } if ("object" == typeof t && "length" in t) { for (let e = 0; e < t.length; e += 1)t[e] && r.append(t[e]); l = o > e ? o + t.length : o } else r.append(t); for (let e = 0; e < c.length; e += 1)r.append(c[e]); i.recalcSlides(), n.loop && i.loopCreate(), n.observer && !i.isElement || i.update(), n.loop ? i.slideTo(l + i.loopedSlides, 0, !1) : i.slideTo(l, 0, !1) } function re(e) { const t = this, { params: i, activeIndex: n } = t; let s = n; i.loop && (s -= t.loopedSlides, t.loopDestroy()); let r, o = s; if ("object" == typeof e && "length" in e) { for (let i = 0; i < e.length; i += 1)r = e[i], t.slides[r] && t.slides[r].remove(), r < o && (o -= 1); o = Math.max(o, 0) } else r = e, t.slides[r] && t.slides[r].remove(), r < o && (o -= 1), o = Math.max(o, 0); t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update(), i.loop ? t.slideTo(o + t.loopedSlides, 0, !1) : t.slideTo(o, 0, !1) } function oe() { const e = this, t = []; for (let i = 0; i < e.slides.length; i += 1)t.push(i); e.removeSlide(t) } function ae(e) { const { effect: t, swiper: i, on: n, setTranslate: s, setTransition: r, overwriteParams: o, perspective: a, recreateShadows: l, getEffectParams: c } = e; let d; n("beforeInit", () => { if (i.params.effect !== t) return; i.classNames.push(`${i.params.containerModifierClass}${t}`), a && a() && i.classNames.push(i.params.containerModifierClass + "3d"); const e = o ? o() : {}; Object.assign(i.params, e), Object.assign(i.originalParams, e) }), n("setTranslate", () => { i.params.effect === t && s() }), n("setTransition", (e, n) => { i.params.effect === t && r(n) }), n("transitionEnd", () => { if (i.params.effect === t && l) { if (!c || !c().slideShadows) return; i.slides.forEach(e => { e.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(e => e.remove()) }), l() } }), n("virtualUpdate", () => { i.params.effect === t && (i.slides.length || (d = !0), requestAnimationFrame(() => { d && i.slides && i.slides.length && (s(), d = !1) })) }) } function le(e, t) { const i = h(t); return i !== t && (i.style.backfaceVisibility = "hidden", i.style["-webkit-backface-visibility"] = "hidden"), i } function ce(e) { let { swiper: t, duration: i, transformElements: n, allSlides: s } = e; const { activeIndex: r } = t; if (t.params.virtualTranslate && 0 !== i) { let e, i = !1; e = s ? n : n.filter(e => { const i = e.classList.contains("swiper-slide-transform") ? (e => e.parentElement ? e.parentElement : t.slides.find(t => t.shadowRoot && t.shadowRoot === e.parentNode))(e) : e; return t.getSlideIndex(i) === r }), e.forEach(e => { _(e, () => { if (i) return; if (!t || t.destroyed) return; i = !0, t.animating = !1; const e = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); t.wrapperEl.dispatchEvent(e) }) }) } } function de(e, t, i) { const n = `swiper-slide-shadow${i ? "-" + i : ""}${e ? " swiper-slide-shadow-" + e : ""}`, s = h(t); let r = s.querySelector("." + n.split(" ").join(".")); return r || (r = v("div", n.split(" ")), s.append(r)), r } Object.keys(K).forEach(e => { Object.keys(K[e]).forEach(t => { J.prototype[t] = K[e][t] }) }), J.use([function (e) { let { swiper: t, on: i, emit: n } = e; const s = r(); let o = null, a = null; const l = () => { t && !t.destroyed && t.initialized && (n("beforeResize"), n("resize")) }, c = () => { t && !t.destroyed && t.initialized && n("orientationchange") }; i("init", () => { t.params.resizeObserver && void 0 !== s.ResizeObserver ? t && !t.destroyed && t.initialized && (o = new ResizeObserver(e => { a = s.requestAnimationFrame(() => { const { width: i, height: n } = t; let s = i, r = n; e.forEach(e => { let { contentBoxSize: i, contentRect: n, target: o } = e; o && o !== t.el || (s = n ? n.width : (i[0] || i).inlineSize, r = n ? n.height : (i[0] || i).blockSize) }), s === i && r === n || l() }) }), o.observe(t.el)) : (s.addEventListener("resize", l), s.addEventListener("orientationchange", c)) }), i("destroy", () => { a && s.cancelAnimationFrame(a), o && o.unobserve && t.el && (o.unobserve(t.el), o = null), s.removeEventListener("resize", l), s.removeEventListener("orientationchange", c) }) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; const o = [], a = r(), l = function (e, i) { void 0 === i && (i = {}); const n = new (a.MutationObserver || a.WebkitMutationObserver)(e => { if (t.__preventObserver__) return; if (1 === e.length) return void s("observerUpdate", e[0]); const i = function () { s("observerUpdate", e[0]) }; a.requestAnimationFrame ? a.requestAnimationFrame(i) : a.setTimeout(i, 0) }); n.observe(e, { attributes: void 0 === i.attributes || i.attributes, childList: t.isElement || (void 0 === i.childList || i).childList, characterData: void 0 === i.characterData || i.characterData }), o.push(n) }; i({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), n("init", () => { if (t.params.observer) { if (t.params.observeParents) { const e = E(t.hostEl); for (let t = 0; t < e.length; t += 1)l(e[t]) } l(t.hostEl, { childList: t.params.observeSlideChildren }), l(t.wrapperEl, { attributes: !1 }) } }), n("destroy", () => { o.forEach(e => { e.disconnect() }), o.splice(0, o.length) }) }]); const ue = [function (e) { let t, { swiper: i, extendParams: s, on: r, emit: o } = e; s({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }); const a = n(); i.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }; const l = a.createElement("div"); function c(e, t) { const n = i.params.virtual; if (n.cache && i.virtual.cache[t]) return i.virtual.cache[t]; let s; return n.renderSlide ? (s = n.renderSlide.call(i, e, t), "string" == typeof s && (l.innerHTML = s, s = l.children[0])) : s = i.isElement ? v("swiper-slide") : v("div", i.params.slideClass), s.setAttribute("data-swiper-slide-index", t), n.renderSlide || (s.innerHTML = e), n.cache && (i.virtual.cache[t] = s), s } function d(e, t, n) { const { slidesPerView: s, slidesPerGroup: r, centeredSlides: a, loop: l, initialSlide: d } = i.params; if (t && !l && d > 0) return; const { addSlidesBefore: u, addSlidesAfter: p } = i.params.virtual, { from: f, to: h, slides: g, slidesGrid: v, offset: y } = i.virtual; i.params.cssMode || i.updateActiveIndex(); const b = void 0 === n ? i.activeIndex || 0 : n; let w, E, _; w = i.rtlTranslate ? "right" : i.isHorizontal() ? "left" : "top", a ? (E = Math.floor(s / 2) + r + p, _ = Math.floor(s / 2) + r + u) : (E = s + (r - 1) + p, _ = (l ? s : r) + u); let x = b - _, S = b + E; l || (x = Math.max(x, 0), S = Math.min(S, g.length - 1)); let T = (i.slidesGrid[x] || 0) - (i.slidesGrid[0] || 0); function C() { i.updateSlides(), i.updateProgress(), i.updateSlidesClasses(), o("virtualUpdate") } if (l && b >= _ ? (x -= _, a || (T += i.slidesGrid[0])) : l && b < _ && (x = -_, a && (T += i.slidesGrid[0])), Object.assign(i.virtual, { from: x, to: S, offset: T, slidesGrid: i.slidesGrid, slidesBefore: _, slidesAfter: E }), f === x && h === S && !e) return i.slidesGrid !== v && T !== y && i.slides.forEach(e => { e.style[w] = T - Math.abs(i.cssOverflowAdjustment()) + "px" }), i.updateProgress(), void o("virtualUpdate"); if (i.params.virtual.renderExternal) return i.params.virtual.renderExternal.call(i, { offset: T, from: x, to: S, slides: function () { const e = []; for (let t = x; t <= S; t += 1)e.push(g[t]); return e }() }), void (i.params.virtual.renderExternalUpdate ? C() : o("virtualUpdate")); const M = [], L = [], I = e => { let t = e; return e < 0 ? t = g.length + e : t >= g.length && (t -= g.length), t }; if (e) i.slides.filter(e => e.matches(`.${i.params.slideClass}, swiper-slide`)).forEach(e => { e.remove() }); else for (let e = f; e <= h; e += 1)if (e < x || e > S) { const t = I(e); i.slides.filter(e => e.matches(`.${i.params.slideClass}[data-swiper-slide-index="${t}"], swiper-slide[data-swiper-slide-index="${t}"]`)).forEach(e => { e.remove() }) } const A = l ? -g.length : 0, P = l ? 2 * g.length : g.length; for (let t = A; t < P; t += 1)if (t >= x && t <= S) { const i = I(t); void 0 === h || e ? L.push(i) : (t > h && L.push(i), t < f && M.push(i)) } if (L.forEach(e => { i.slidesEl.append(c(g[e], e)) }), l) for (let e = M.length - 1; e >= 0; e -= 1) { const t = M[e]; i.slidesEl.prepend(c(g[t], t)) } else M.sort((e, t) => t - e), M.forEach(e => { i.slidesEl.prepend(c(g[e], e)) }); m(i.slidesEl, ".swiper-slide, swiper-slide").forEach(e => { e.style[w] = T - Math.abs(i.cssOverflowAdjustment()) + "px" }), C() } r("beforeInit", () => { if (!i.params.virtual.enabled) return; let e; if (void 0 === i.passedParams.virtual.slides) { const t = [...i.slidesEl.children].filter(e => e.matches(`.${i.params.slideClass}, swiper-slide`)); t && t.length && (i.virtual.slides = [...t], e = !0, t.forEach((e, t) => { e.setAttribute("data-swiper-slide-index", t), i.virtual.cache[t] = e, e.remove() })) } e || (i.virtual.slides = i.params.virtual.slides), i.classNames.push(i.params.containerModifierClass + "virtual"), i.params.watchSlidesProgress = !0, i.originalParams.watchSlidesProgress = !0, d(!1, !0) }), r("setTranslate", () => { i.params.virtual.enabled && (i.params.cssMode && !i._immediateVirtual ? (clearTimeout(t), t = setTimeout(() => { d() }, 100)) : d()) }), r("init update resize", () => { i.params.virtual.enabled && i.params.cssMode && p(i.wrapperEl, "--swiper-virtual-size", i.virtualSize + "px") }), Object.assign(i.virtual, { appendSlide: function (e) { if ("object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && i.virtual.slides.push(e[t]); else i.virtual.slides.push(e); d(!0) }, prependSlide: function (e) { const t = i.activeIndex; let n = t + 1, s = 1; if (Array.isArray(e)) { for (let t = 0; t < e.length; t += 1)e[t] && i.virtual.slides.unshift(e[t]); n = t + e.length, s = e.length } else i.virtual.slides.unshift(e); if (i.params.virtual.cache) { const e = i.virtual.cache, t = {}; Object.keys(e).forEach(i => { const n = e[i], r = n.getAttribute("data-swiper-slide-index"); r && n.setAttribute("data-swiper-slide-index", parseInt(r, 10) + s), t[parseInt(i, 10) + s] = n }), i.virtual.cache = t } d(!0), i.slideTo(n, 0) }, removeSlide: function (e) { if (null == e) return; let t = i.activeIndex; if (Array.isArray(e)) for (let n = e.length - 1; n >= 0; n -= 1)i.params.virtual.cache && (delete i.virtual.cache[e[n]], Object.keys(i.virtual.cache).forEach(t => { t > e && (i.virtual.cache[t - 1] = i.virtual.cache[t], i.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete i.virtual.cache[t]) })), i.virtual.slides.splice(e[n], 1), e[n] < t && (t -= 1), t = Math.max(t, 0); else i.params.virtual.cache && (delete i.virtual.cache[e], Object.keys(i.virtual.cache).forEach(t => { t > e && (i.virtual.cache[t - 1] = i.virtual.cache[t], i.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete i.virtual.cache[t]) })), i.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0); d(!0), i.slideTo(t, 0) }, removeAllSlides: function () { i.virtual.slides = [], i.params.virtual.cache && (i.virtual.cache = {}), d(!0), i.slideTo(0, 0) }, update: d }) }, function (e) { let { swiper: t, extendParams: i, on: s, emit: o } = e; const a = n(), l = r(); function c(e) { if (!t.enabled) return; const { rtlTranslate: i } = t; let n = e; n.originalEvent && (n = n.originalEvent); const s = n.keyCode || n.charCode, r = t.params.keyboard.pageUpDown, c = r && 33 === s, d = r && 34 === s, u = 37 === s, p = 39 === s, f = 38 === s, h = 40 === s; if (!t.allowSlideNext && (t.isHorizontal() && p || t.isVertical() && h || d)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && u || t.isVertical() && f || c)) return !1; if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || a.activeElement && a.activeElement.nodeName && ("input" === a.activeElement.nodeName.toLowerCase() || "textarea" === a.activeElement.nodeName.toLowerCase()))) { if (t.params.keyboard.onlyInViewport && (c || d || u || p || f || h)) { let e = !1; if (E(t.el, `.${t.params.slideClass}, swiper-slide`).length > 0 && 0 === E(t.el, "." + t.params.slideActiveClass).length) return; const n = t.el, s = n.clientWidth, r = n.clientHeight, o = l.innerWidth, a = l.innerHeight, c = y(n); i && (c.left -= n.scrollLeft); const d = [[c.left, c.top], [c.left + s, c.top], [c.left, c.top + r], [c.left + s, c.top + r]]; for (let t = 0; t < d.length; t += 1) { const i = d[t]; if (i[0] >= 0 && i[0] <= o && i[1] >= 0 && i[1] <= a) { if (0 === i[0] && 0 === i[1]) continue; e = !0 } } if (!e) return } t.isHorizontal() ? ((c || d || u || p) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), ((d || p) && !i || (c || u) && i) && t.slideNext(), ((c || u) && !i || (d || p) && i) && t.slidePrev()) : ((c || d || f || h) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (d || h) && t.slideNext(), (c || f) && t.slidePrev()), o("keyPress", s) } } function d() { t.keyboard.enabled || (a.addEventListener("keydown", c), t.keyboard.enabled = !0) } function u() { t.keyboard.enabled && (a.removeEventListener("keydown", c), t.keyboard.enabled = !1) } t.keyboard = { enabled: !1 }, i({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), s("init", () => { t.params.keyboard.enabled && d() }), s("destroy", () => { t.keyboard.enabled && u() }), Object.assign(t.keyboard, { enable: d, disable: u }) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; const o = r(); let c; i({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null, noMousewheelClass: "swiper-no-mousewheel" } }), t.mousewheel = { enabled: !1 }; let d, u = l(); const p = []; function f() { t.enabled && (t.mouseEntered = !0) } function h() { t.enabled && (t.mouseEntered = !1) } function m(e) { return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta || t.params.mousewheel.thresholdTime && l() - u < t.params.mousewheel.thresholdTime || !(e.delta >= 6 && l() - u < 60) && (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), s("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), s("scroll", e.raw)), u = (new o.Date).getTime(), 1)) } function g(e) { let i = e, n = !0; if (!t.enabled) return; if (e.target.closest("." + t.params.mousewheel.noMousewheelClass)) return; const r = t.params.mousewheel; t.params.cssMode && i.preventDefault(); let o = t.el; "container" !== t.params.mousewheel.eventsTarget && (o = document.querySelector(t.params.mousewheel.eventsTarget)); const u = o && o.contains(i.target); if (!t.mouseEntered && !u && !r.releaseOnEdges) return !0; i.originalEvent && (i = i.originalEvent); let f = 0; const h = t.rtlTranslate ? -1 : 1, g = function (e) { let t = 0, i = 0, n = 0, s = 0; return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = i, i = 0), n = 10 * t, s = 10 * i, "deltaY" in e && (s = e.deltaY), "deltaX" in e && (n = e.deltaX), e.shiftKey && !n && (n = s, s = 0), (n || s) && e.deltaMode && (1 === e.deltaMode ? (n *= 40, s *= 40) : (n *= 800, s *= 800)), n && !t && (t = n < 1 ? -1 : 1), s && !i && (i = s < 1 ? -1 : 1), { spinX: t, spinY: i, pixelX: n, pixelY: s } }(i); if (r.forceToAxis) if (t.isHorizontal()) { if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0; f = -g.pixelX * h } else { if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0; f = -g.pixelY } else f = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * h : -g.pixelY; if (0 === f) return !0; r.invert && (f = -f); let v = t.getTranslate() + f * r.sensitivity; if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), n = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), n && t.params.nested && i.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) { const e = { time: l(), delta: Math.abs(f), direction: Math.sign(f) }, n = d && e.time < d.time + 500 && e.delta <= d.delta && e.direction === d.direction; if (!n) { d = void 0; let o = t.getTranslate() + f * r.sensitivity; const l = t.isBeginning, u = t.isEnd; if (o >= t.minTranslate() && (o = t.minTranslate()), o <= t.maxTranslate() && (o = t.maxTranslate()), t.setTransition(0), t.setTranslate(o), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!l && t.isBeginning || !u && t.isEnd) && t.updateSlidesClasses(), t.params.loop && t.loopFix({ direction: e.direction < 0 ? "next" : "prev", byMousewheel: !0 }), t.params.freeMode.sticky) { clearTimeout(c), c = void 0, p.length >= 15 && p.shift(); const i = p.length ? p[p.length - 1] : void 0, n = p[0]; if (p.push(e), i && (e.delta > i.delta || e.direction !== i.direction)) p.splice(0); else if (p.length >= 15 && e.time - n.time < 500 && n.delta - e.delta >= 1 && e.delta <= 6) { const i = f > 0 ? .8 : .2; d = e, p.splice(0), c = a(() => { !t.destroyed && t.params && t.slideToClosest(t.params.speed, !0, void 0, i) }, 0) } c || (c = a(() => { !t.destroyed && t.params && (d = e, p.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5)) }, 500)) } if (n || s("scroll", i), t.params.autoplay && t.params.autoplay.disableOnInteraction && t.autoplay.stop(), r.releaseOnEdges && (o === t.minTranslate() || o === t.maxTranslate())) return !0 } } else { const i = { time: l(), delta: Math.abs(f), direction: Math.sign(f), raw: e }; p.length >= 2 && p.shift(); const n = p.length ? p[p.length - 1] : void 0; if (p.push(i), n ? (i.direction !== n.direction || i.delta > n.delta || i.time > n.time + 150) && m(i) : m(i), function (e) { const i = t.params.mousewheel; if (e.direction < 0) { if (t.isEnd && !t.params.loop && i.releaseOnEdges) return !0 } else if (t.isBeginning && !t.params.loop && i.releaseOnEdges) return !0; return !1 }(i)) return !0 } return i.preventDefault ? i.preventDefault() : i.returnValue = !1, !1 } function v(e) { let i = t.el; "container" !== t.params.mousewheel.eventsTarget && (i = document.querySelector(t.params.mousewheel.eventsTarget)), i[e]("mouseenter", f), i[e]("mouseleave", h), i[e]("wheel", g) } function y() { return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", g), !0) : !t.mousewheel.enabled && (v("addEventListener"), t.mousewheel.enabled = !0, !0) } function b() { return t.params.cssMode ? (t.wrapperEl.addEventListener(event, g), !0) : !!t.mousewheel.enabled && (v("removeEventListener"), t.mousewheel.enabled = !1, !0) } n("init", () => { !t.params.mousewheel.enabled && t.params.cssMode && b(), t.params.mousewheel.enabled && y() }), n("destroy", () => { t.params.cssMode && y(), t.mousewheel.enabled && b() }), Object.assign(t.mousewheel, { enable: y, disable: b }) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; function r(e) { let i; return e && "string" == typeof e && t.isElement && (i = t.el.querySelector(e) || t.hostEl.querySelector(e), i) ? i : (e && ("string" == typeof e && (i = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" == typeof e && i && i.length > 1 && 1 === t.el.querySelectorAll(e).length ? i = t.el.querySelector(e) : i && 1 === i.length && (i = i[0])), e && !i ? e : i) } function o(e, i) { const n = t.params.navigation; (e = S(e)).forEach(e => { e && (e.classList[i ? "add" : "remove"](...n.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = i), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](n.lockClass)) }) } function a() { const { nextEl: e, prevEl: i } = t.navigation; if (t.params.loop) return o(i, !1), void o(e, !1); o(i, t.isBeginning && !t.params.rewind), o(e, t.isEnd && !t.params.rewind) } function l(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), s("navigationPrev")) } function c(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), s("navigationNext")) } function d() { const e = t.params.navigation; if (t.params.navigation = ee(t, t.originalParams.navigation, t.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !e.nextEl && !e.prevEl) return; let i = r(e.nextEl), n = r(e.prevEl); Object.assign(t.navigation, { nextEl: i, prevEl: n }), i = S(i), n = S(n); const s = (i, n) => { i && i.addEventListener("click", "next" === n ? c : l), !t.enabled && i && i.classList.add(...e.lockClass.split(" ")) }; i.forEach(e => s(e, "next")), n.forEach(e => s(e, "prev")) } function u() { let { nextEl: e, prevEl: i } = t.navigation; e = S(e), i = S(i); const n = (e, i) => { e.removeEventListener("click", "next" === i ? c : l), e.classList.remove(...t.params.navigation.disabledClass.split(" ")) }; e.forEach(e => n(e, "next")), i.forEach(e => n(e, "prev")) } i({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), t.navigation = { nextEl: null, prevEl: null }, n("init", () => { !1 === t.params.navigation.enabled ? p() : (d(), a()) }), n("toEdge fromEdge lock unlock", () => { a() }), n("destroy", () => { u() }), n("enable disable", () => { let { nextEl: e, prevEl: i } = t.navigation; e = S(e), i = S(i), t.enabled ? a() : [...e, ...i].filter(e => !!e).forEach(e => e.classList.add(t.params.navigation.lockClass)) }), n("click", (e, i) => { let { nextEl: n, prevEl: r } = t.navigation; n = S(n), r = S(r); const o = i.target; let a = r.includes(o) || n.includes(o); if (t.isElement && !a) { const e = i.path || i.composedPath && i.composedPath(); e && (a = e.find(e => n.includes(e) || r.includes(e))) } if (t.params.navigation.hideOnClick && !a) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === o || t.pagination.el.contains(o))) return; let e; n.length ? e = n[0].classList.contains(t.params.navigation.hiddenClass) : r.length && (e = r[0].classList.contains(t.params.navigation.hiddenClass)), s(!0 === e ? "navigationShow" : "navigationHide"), [...n, ...r].filter(e => !!e).forEach(e => e.classList.toggle(t.params.navigation.hiddenClass)) } }); const p = () => { t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), u() }; Object.assign(t.navigation, { enable: () => { t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), d(), a() }, disable: p, update: a, init: d, destroy: u }) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; const r = "swiper-pagination"; let o; i({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: r + "-bullet", bulletActiveClass: r + "-bullet-active", modifierClass: r + "-", currentClass: r + "-current", totalClass: r + "-total", hiddenClass: r + "-hidden", progressbarFillClass: r + "-progressbar-fill", progressbarOppositeClass: r + "-progressbar-opposite", clickableClass: r + "-clickable", lockClass: r + "-lock", horizontalClass: r + "-horizontal", verticalClass: r + "-vertical", paginationDisabledClass: r + "-disabled" } }), t.pagination = { el: null, bullets: [] }; let a = 0; function l() { return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length } function c(e, i) { const { bulletActiveClass: n } = t.params.pagination; e && (e = e[("prev" === i ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${n}-${i}`), (e = e[("prev" === i ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${n}-${i}-${i}`)) } function d(e) { const i = e.target.closest(te(t.params.pagination.bulletClass)); if (!i) return; e.preventDefault(); const n = w(i) * t.params.slidesPerGroup; if (t.params.loop) { if (t.realIndex === n) return; const e = (s = t.realIndex, r = n, (r %= o = t.slides.length) == 1 + (s %= o) ? "next" : r === s - 1 ? "previous" : void 0); "next" === e ? t.slideNext() : "previous" === e ? t.slidePrev() : t.slideToLoop(n) } else t.slideTo(n); var s, r, o } function u() { const e = t.rtl, i = t.params.pagination; if (l()) return; let n, r, d = t.pagination.el; d = S(d); const u = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length, p = t.params.loop ? Math.ceil(u / t.params.slidesPerGroup) : t.snapGrid.length; if (t.params.loop ? (r = t.previousRealIndex || 0, n = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (n = t.snapIndex, r = t.previousSnapIndex) : (r = t.previousIndex || 0, n = t.activeIndex || 0), "bullets" === i.type && t.pagination.bullets && t.pagination.bullets.length > 0) { const s = t.pagination.bullets; let l, u, p; if (i.dynamicBullets && (o = x(s[0], t.isHorizontal() ? "width" : "height", !0), d.forEach(e => { e.style[t.isHorizontal() ? "width" : "height"] = o * (i.dynamicMainBullets + 4) + "px" }), i.dynamicMainBullets > 1 && void 0 !== r && (a += n - (r || 0), a > i.dynamicMainBullets - 1 ? a = i.dynamicMainBullets - 1 : a < 0 && (a = 0)), l = Math.max(n - a, 0), u = l + (Math.min(s.length, i.dynamicMainBullets) - 1), p = (u + l) / 2), s.forEach(e => { const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(e => `${i.bulletActiveClass}${e}`)].map(e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e).flat(); e.classList.remove(...t) }), d.length > 1) s.forEach(e => { const s = w(e); s === n ? e.classList.add(...i.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"), i.dynamicBullets && (s >= l && s <= u && e.classList.add(...(i.bulletActiveClass + "-main").split(" ")), s === l && c(e, "prev"), s === u && c(e, "next")) }); else { const e = s[n]; if (e && e.classList.add(...i.bulletActiveClass.split(" ")), t.isElement && s.forEach((e, t) => { e.setAttribute("part", t === n ? "bullet-active" : "bullet") }), i.dynamicBullets) { const e = s[l], t = s[u]; for (let e = l; e <= u; e += 1)s[e] && s[e].classList.add(...(i.bulletActiveClass + "-main").split(" ")); c(e, "prev"), c(t, "next") } } if (i.dynamicBullets) { const n = Math.min(s.length, i.dynamicMainBullets + 4), r = (o * n - o) / 2 - p * o, a = e ? "right" : "left"; s.forEach(e => { e.style[t.isHorizontal() ? a : "top"] = r + "px" }) } } d.forEach((e, r) => { if ("fraction" === i.type && (e.querySelectorAll(te(i.currentClass)).forEach(e => { e.textContent = i.formatFractionCurrent(n + 1) }), e.querySelectorAll(te(i.totalClass)).forEach(e => { e.textContent = i.formatFractionTotal(p) })), "progressbar" === i.type) { let s; s = i.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical"; const r = (n + 1) / p; let o = 1, a = 1; "horizontal" === s ? o = r : a = r, e.querySelectorAll(te(i.progressbarFillClass)).forEach(e => { e.style.transform = `translate3d(0,0,0) scaleX(${o}) scaleY(${a})`, e.style.transitionDuration = t.params.speed + "ms" }) } "custom" === i.type && i.renderCustom ? (e.innerHTML = i.renderCustom(t, n + 1, p), 0 === r && s("paginationRender", e)) : (0 === r && s("paginationRender", e), s("paginationUpdate", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](i.lockClass) }) } function p() { const e = t.params.pagination; if (l()) return; const i = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.grid && t.params.grid.rows > 1 ? t.slides.length / Math.ceil(t.params.grid.rows) : t.slides.length; let n = t.pagination.el; n = S(n); let r = ""; if ("bullets" === e.type) { let n = t.params.loop ? Math.ceil(i / t.params.slidesPerGroup) : t.snapGrid.length; t.params.freeMode && t.params.freeMode.enabled && n > i && (n = i); for (let i = 0; i < n; i += 1)e.renderBullet ? r += e.renderBullet.call(t, i, e.bulletClass) : r += `<${e.bulletElement} ${t.isElement ? 'part="bullet"' : ""} class="${e.bulletClass}"></${e.bulletElement}>` } "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), t.pagination.bullets = [], n.forEach(i => { "custom" !== e.type && (i.innerHTML = r || ""), "bullets" === e.type && t.pagination.bullets.push(...i.querySelectorAll(te(e.bulletClass))) }), "custom" !== e.type && s("paginationRender", n[0]) } function f() { t.params.pagination = ee(t, t.originalParams.pagination, t.params.pagination, { el: "swiper-pagination" }); const e = t.params.pagination; if (!e.el) return; let i; "string" == typeof e.el && t.isElement && (i = t.el.querySelector(e.el)), i || "string" != typeof e.el || (i = [...document.querySelectorAll(e.el)]), i || (i = e.el), i && 0 !== i.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(i) && i.length > 1 && (i = [...t.el.querySelectorAll(e.el)], i.length > 1 && (i = i.find(e => E(e, ".swiper")[0] === t.el))), Array.isArray(i) && 1 === i.length && (i = i[0]), Object.assign(t.pagination, { el: i }), i = S(i), i.forEach(i => { "bullets" === e.type && e.clickable && i.classList.add(...(e.clickableClass || "").split(" ")), i.classList.add(e.modifierClass + e.type), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (i.classList.add(`${e.modifierClass}${e.type}-dynamic`), a = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && i.classList.add(e.progressbarOppositeClass), e.clickable && i.addEventListener("click", d), t.enabled || i.classList.add(e.lockClass) })) } function h() { const e = t.params.pagination; if (l()) return; let i = t.pagination.el; i && (i = S(i), i.forEach(i => { i.classList.remove(e.hiddenClass), i.classList.remove(e.modifierClass + e.type), i.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (i.classList.remove(...(e.clickableClass || "").split(" ")), i.removeEventListener("click", d)) })), t.pagination.bullets && t.pagination.bullets.forEach(t => t.classList.remove(...e.bulletActiveClass.split(" "))) } n("changeDirection", () => { if (!t.pagination || !t.pagination.el) return; const e = t.params.pagination; let { el: i } = t.pagination; i = S(i), i.forEach(i => { i.classList.remove(e.horizontalClass, e.verticalClass), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass) }) }), n("init", () => { !1 === t.params.pagination.enabled ? m() : (f(), p(), u()) }), n("activeIndexChange", () => { void 0 === t.snapIndex && u() }), n("snapIndexChange", () => { u() }), n("snapGridLengthChange", () => { p(), u() }), n("destroy", () => { h() }), n("enable disable", () => { let { el: e } = t.pagination; e && (e = S(e), e.forEach(e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass))) }), n("lock unlock", () => { u() }), n("click", (e, i) => { const n = i.target, r = S(t.pagination.el); if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !n.classList.contains(t.params.pagination.bulletClass)) { if (t.navigation && (t.navigation.nextEl && n === t.navigation.nextEl || t.navigation.prevEl && n === t.navigation.prevEl)) return; const e = r[0].classList.contains(t.params.pagination.hiddenClass); s(!0 === e ? "paginationShow" : "paginationHide"), r.forEach(e => e.classList.toggle(t.params.pagination.hiddenClass)) } }); const m = () => { t.el.classList.add(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = S(e), e.forEach(e => e.classList.add(t.params.pagination.paginationDisabledClass))), h() }; Object.assign(t.pagination, { enable: () => { t.el.classList.remove(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = S(e), e.forEach(e => e.classList.remove(t.params.pagination.paginationDisabledClass))), f(), p(), u() }, disable: m, render: p, update: u, init: f, destroy: h }) }, function (e) { let { swiper: t, extendParams: i, on: s, emit: r } = e; const l = n(); let c, d, u, p, f = !1, h = null, m = null; function g() { if (!t.params.scrollbar.el || !t.scrollbar.el) return; const { scrollbar: e, rtlTranslate: i } = t, { dragEl: n, el: s } = e, r = t.params.scrollbar, o = t.params.loop ? t.progressLoop : t.progress; let a = d, l = (u - d) * o; i ? (l = -l, l > 0 ? (a = d - l, l = 0) : -l + d > u && (a = u + l)) : l < 0 ? (a = d + l, l = 0) : l + d > u && (a = u - l), t.isHorizontal() ? (n.style.transform = `translate3d(${l}px, 0, 0)`, n.style.width = a + "px") : (n.style.transform = `translate3d(0px, ${l}px, 0)`, n.style.height = a + "px"), r.hide && (clearTimeout(h), s.style.opacity = 1, h = setTimeout(() => { s.style.opacity = 0, s.style.transitionDuration = "400ms" }, 1e3)) } function b() { if (!t.params.scrollbar.el || !t.scrollbar.el) return; const { scrollbar: e } = t, { dragEl: i, el: n } = e; i.style.width = "", i.style.height = "", u = t.isHorizontal() ? n.offsetWidth : n.offsetHeight, p = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), d = "auto" === t.params.scrollbar.dragSize ? u * p : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? i.style.width = d + "px" : i.style.height = d + "px", n.style.display = p >= 1 ? "none" : "", t.params.scrollbar.hide && (n.style.opacity = 0), t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass) } function w(e) { return t.isHorizontal() ? e.clientX : e.clientY } function E(e) { const { scrollbar: i, rtlTranslate: n } = t, { el: s } = i; let r; r = (w(e) - y(s)[t.isHorizontal() ? "left" : "top"] - (null !== c ? c : d / 2)) / (u - d), r = Math.max(Math.min(r, 1), 0), n && (r = 1 - r); const o = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r; t.updateProgress(o), t.setTranslate(o), t.updateActiveIndex(), t.updateSlidesClasses() } function _(e) { const i = t.params.scrollbar, { scrollbar: n, wrapperEl: s } = t, { el: o, dragEl: a } = n; f = !0, c = e.target === a ? w(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), s.style.transitionDuration = "100ms", a.style.transitionDuration = "100ms", E(e), clearTimeout(m), o.style.transitionDuration = "0ms", i.hide && (o.style.opacity = 1), t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "none"), r("scrollbarDragStart", e) } function x(e) { const { scrollbar: i, wrapperEl: n } = t, { el: s, dragEl: o } = i; f && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1, E(e), n.style.transitionDuration = "0ms", s.style.transitionDuration = "0ms", o.style.transitionDuration = "0ms", r("scrollbarDragMove", e)) } function T(e) { const i = t.params.scrollbar, { scrollbar: n, wrapperEl: s } = t, { el: o } = n; f && (f = !1, t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "", s.style.transitionDuration = ""), i.hide && (clearTimeout(m), m = a(() => { o.style.opacity = 0, o.style.transitionDuration = "400ms" }, 1e3)), r("scrollbarDragEnd", e), i.snapOnRelease && t.slideToClosest()) } function C(e) { const { scrollbar: i, params: n } = t, s = i.el; if (!s) return; const r = s, o = !!n.passiveListeners && { passive: !1, capture: !1 }, a = !!n.passiveListeners && { passive: !0, capture: !1 }; if (!r) return; const c = "on" === e ? "addEventListener" : "removeEventListener"; r[c]("pointerdown", _, o), l[c]("pointermove", x, o), l[c]("pointerup", T, a) } function M() { const { scrollbar: e, el: i } = t; t.params.scrollbar = ee(t, t.originalParams.scrollbar, t.params.scrollbar, { el: "swiper-scrollbar" }); const n = t.params.scrollbar; if (!n.el) return; let s, r; if ("string" == typeof n.el && t.isElement && (s = t.el.querySelector(n.el)), s || "string" != typeof n.el) s || (s = n.el); else if (s = l.querySelectorAll(n.el), !s.length) return; t.params.uniqueNavElements && "string" == typeof n.el && s.length > 1 && 1 === i.querySelectorAll(n.el).length && (s = i.querySelector(n.el)), s.length > 0 && (s = s[0]), s.classList.add(t.isHorizontal() ? n.horizontalClass : n.verticalClass), s && (r = s.querySelector(te(t.params.scrollbar.dragClass)), r || (r = v("div", t.params.scrollbar.dragClass), s.append(r))), Object.assign(e, { el: s, dragEl: r }), n.draggable && t.params.scrollbar.el && t.scrollbar.el && C("on"), s && s.classList[t.enabled ? "remove" : "add"](...o(t.params.scrollbar.lockClass)) } function L() { const e = t.params.scrollbar, i = t.scrollbar.el; i && i.classList.remove(...o(t.isHorizontal() ? e.horizontalClass : e.verticalClass)), t.params.scrollbar.el && t.scrollbar.el && C("off") } i({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: "swiper-scrollbar-horizontal", verticalClass: "swiper-scrollbar-vertical" } }), t.scrollbar = { el: null, dragEl: null }, s("changeDirection", () => { if (!t.scrollbar || !t.scrollbar.el) return; const e = t.params.scrollbar; let { el: i } = t.scrollbar; i = S(i), i.forEach(i => { i.classList.remove(e.horizontalClass, e.verticalClass), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass) }) }), s("init", () => { !1 === t.params.scrollbar.enabled ? I() : (M(), b(), g()) }), s("update resize observerUpdate lock unlock changeDirection", () => { b() }), s("setTranslate", () => { g() }), s("setTransition", (e, i) => { !function (e) { t.params.scrollbar.el && t.scrollbar.el && (t.scrollbar.dragEl.style.transitionDuration = e + "ms") }(i) }), s("enable disable", () => { const { el: e } = t.scrollbar; e && e.classList[t.enabled ? "remove" : "add"](...o(t.params.scrollbar.lockClass)) }), s("destroy", () => { L() }); const I = () => { t.el.classList.add(...o(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.add(...o(t.params.scrollbar.scrollbarDisabledClass)), L() }; Object.assign(t.scrollbar, { enable: () => { t.el.classList.remove(...o(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.remove(...o(t.params.scrollbar.scrollbarDisabledClass)), M(), b(), g() }, disable: I, updateSize: b, setTranslate: g, init: M, destroy: L }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ parallax: { enabled: !1 } }); const s = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]", r = (e, i) => { const { rtl: n } = t, s = n ? -1 : 1, r = e.getAttribute("data-swiper-parallax") || "0"; let o = e.getAttribute("data-swiper-parallax-x"), a = e.getAttribute("data-swiper-parallax-y"); const l = e.getAttribute("data-swiper-parallax-scale"), c = e.getAttribute("data-swiper-parallax-opacity"), d = e.getAttribute("data-swiper-parallax-rotate"); if (o || a ? (o = o || "0", a = a || "0") : t.isHorizontal() ? (o = r, a = "0") : (a = r, o = "0"), o = o.indexOf("%") >= 0 ? parseInt(o, 10) * i * s + "%" : o * i * s + "px", a = a.indexOf("%") >= 0 ? parseInt(a, 10) * i + "%" : a * i + "px", null != c) { const t = c - (c - 1) * (1 - Math.abs(i)); e.style.opacity = t } let u = `translate3d(${o}, ${a}, 0px)`; null != l && (u += ` scale(${l - (l - 1) * (1 - Math.abs(i))})`), d && null != d && (u += ` rotate(${d * i * -1}deg)`), e.style.transform = u }, o = () => { const { el: e, slides: i, progress: n, snapGrid: o, isElement: a } = t, l = m(e, s); t.isElement && l.push(...m(t.hostEl, s)), l.forEach(e => { r(e, n) }), i.forEach((e, i) => { let a = e.progress; t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (a += Math.ceil(i / 2) - n * (o.length - 1)), a = Math.min(Math.max(a, -1), 1), e.querySelectorAll(s + ", [data-swiper-parallax-rotate]").forEach(e => { r(e, a) }) }) }; n("beforeInit", () => { t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0) }), n("init", () => { t.params.parallax.enabled && o() }), n("setTranslate", () => { t.params.parallax.enabled && o() }), n("setTransition", (e, i) => { t.params.parallax.enabled && function (e) { void 0 === e && (e = t.params.speed); const { el: i, hostEl: n } = t, r = [...i.querySelectorAll(s)]; t.isElement && r.push(...n.querySelectorAll(s)), r.forEach(t => { let i = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e; 0 === e && (i = 0), t.style.transitionDuration = i + "ms" }) }(i) }) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; const o = r(); i({ zoom: { enabled: !1, limitToOriginalSize: !1, maxRatio: 3, minRatio: 1, panOnMouseMove: !1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), t.zoom = { enabled: !1 }; let a = 1, l = !1, d = !1, u = { x: 0, y: 0 }; let p, f; const h = [], g = { originX: 0, originY: 0, slideEl: void 0, slideWidth: void 0, slideHeight: void 0, imageEl: void 0, imageWrapEl: void 0, maxRatio: 3 }, v = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, b = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let w, _ = 1; function x() { if (h.length < 2) return 1; const e = h[0].pageX, t = h[0].pageY, i = h[1].pageX, n = h[1].pageY; return Math.sqrt((i - e) ** 2 + (n - t) ** 2) } function S() { const e = t.params.zoom, i = g.imageWrapEl.getAttribute("data-swiper-zoom") || e.maxRatio; if (e.limitToOriginalSize && g.imageEl && g.imageEl.naturalWidth) { const e = g.imageEl.naturalWidth / g.imageEl.offsetWidth; return Math.min(e, i) } return i } function T(e) { const i = t.isElement ? "swiper-slide" : "." + t.params.slideClass; return !!e.target.matches(i) || t.slides.filter(t => t.contains(e.target)).length > 0 } function C(e) { const i = "." + t.params.zoom.containerClass; return !!e.target.matches(i) || [...t.hostEl.querySelectorAll(i)].filter(t => t.contains(e.target)).length > 0 } function M(e) { if ("mouse" === e.pointerType && h.splice(0, h.length), !T(e)) return; const i = t.params.zoom; if (p = !1, f = !1, h.push(e), !(h.length < 2)) { if (p = !0, g.scaleStart = x(), !g.slideEl) { g.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`), g.slideEl || (g.slideEl = t.slides[t.activeIndex]); let n = g.slideEl.querySelector("." + i.containerClass); if (n && (n = n.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = n, g.imageWrapEl = n ? E(g.imageEl, "." + i.containerClass)[0] : void 0, !g.imageWrapEl) return void (g.imageEl = void 0); g.maxRatio = S() } if (g.imageEl) { const [e, t] = function () { if (h.length < 2) return { x: null, y: null }; const e = g.imageEl.getBoundingClientRect(); return [(h[0].pageX + (h[1].pageX - h[0].pageX) / 2 - e.x - o.scrollX) / a, (h[0].pageY + (h[1].pageY - h[0].pageY) / 2 - e.y - o.scrollY) / a] }(); g.originX = e, g.originY = t, g.imageEl.style.transitionDuration = "0ms" } l = !0 } } function L(e) { if (!T(e)) return; const i = t.params.zoom, n = t.zoom, s = h.findIndex(t => t.pointerId === e.pointerId); s >= 0 && (h[s] = e), h.length < 2 || (f = !0, g.scaleMove = x(), g.imageEl && (n.scale = g.scaleMove / g.scaleStart * a, n.scale > g.maxRatio && (n.scale = g.maxRatio - 1 + (n.scale - g.maxRatio + 1) ** .5), n.scale < i.minRatio && (n.scale = i.minRatio + 1 - (i.minRatio - n.scale + 1) ** .5), g.imageEl.style.transform = `translate3d(0,0,0) scale(${n.scale})`)) } function I(e) { if (!T(e)) return; if ("mouse" === e.pointerType && "pointerout" === e.type) return; const i = t.params.zoom, n = t.zoom, s = h.findIndex(t => t.pointerId === e.pointerId); s >= 0 && h.splice(s, 1), p && f && (p = !1, f = !1, g.imageEl && (n.scale = Math.max(Math.min(n.scale, g.maxRatio), i.minRatio), g.imageEl.style.transitionDuration = t.params.speed + "ms", g.imageEl.style.transform = `translate3d(0,0,0) scale(${n.scale})`, a = n.scale, l = !1, n.scale > 1 && g.slideEl ? g.slideEl.classList.add("" + i.zoomedSlideClass) : n.scale <= 1 && g.slideEl && g.slideEl.classList.remove("" + i.zoomedSlideClass), 1 === n.scale && (g.originX = 0, g.originY = 0, g.slideEl = void 0))) } function A() { t.touchEventsData.preventTouchMoveFromPointerMove = !1 } function P(e) { const i = "mouse" === e.pointerType && t.params.zoom.panOnMouseMove; if (!T(e) || !C(e)) return; const n = t.zoom; if (!g.imageEl) return; if (!v.isTouched || !g.slideEl) return void (i && k(e)); if (i) return void k(e); v.isMoved || (v.width = g.imageEl.offsetWidth || g.imageEl.clientWidth, v.height = g.imageEl.offsetHeight || g.imageEl.clientHeight, v.startX = c(g.imageWrapEl, "x") || 0, v.startY = c(g.imageWrapEl, "y") || 0, g.slideWidth = g.slideEl.offsetWidth, g.slideHeight = g.slideEl.offsetHeight, g.imageWrapEl.style.transitionDuration = "0ms"); const s = v.width * n.scale, r = v.height * n.scale; if (v.minX = Math.min(g.slideWidth / 2 - s / 2, 0), v.maxX = -v.minX, v.minY = Math.min(g.slideHeight / 2 - r / 2, 0), v.maxY = -v.minY, v.touchesCurrent.x = h.length > 0 ? h[0].pageX : e.pageX, v.touchesCurrent.y = h.length > 0 ? h[0].pageY : e.pageY, Math.max(Math.abs(v.touchesCurrent.x - v.touchesStart.x), Math.abs(v.touchesCurrent.y - v.touchesStart.y)) > 5 && (t.allowClick = !1), !v.isMoved && !l) { if (t.isHorizontal() && (Math.floor(v.minX) === Math.floor(v.startX) && v.touchesCurrent.x < v.touchesStart.x || Math.floor(v.maxX) === Math.floor(v.startX) && v.touchesCurrent.x > v.touchesStart.x)) return v.isTouched = !1, void A(); if (!t.isHorizontal() && (Math.floor(v.minY) === Math.floor(v.startY) && v.touchesCurrent.y < v.touchesStart.y || Math.floor(v.maxY) === Math.floor(v.startY) && v.touchesCurrent.y > v.touchesStart.y)) return v.isTouched = !1, void A() } e.cancelable && e.preventDefault(), e.stopPropagation(), clearTimeout(w), t.touchEventsData.preventTouchMoveFromPointerMove = !0, w = setTimeout(() => { t.destroyed || A() }), v.isMoved = !0; const o = (n.scale - a) / (g.maxRatio - t.params.zoom.minRatio), { originX: d, originY: u } = g; v.currentX = v.touchesCurrent.x - v.touchesStart.x + v.startX + o * (v.width - 2 * d), v.currentY = v.touchesCurrent.y - v.touchesStart.y + v.startY + o * (v.height - 2 * u), v.currentX < v.minX && (v.currentX = v.minX + 1 - (v.minX - v.currentX + 1) ** .8), v.currentX > v.maxX && (v.currentX = v.maxX - 1 + (v.currentX - v.maxX + 1) ** .8), v.currentY < v.minY && (v.currentY = v.minY + 1 - (v.minY - v.currentY + 1) ** .8), v.currentY > v.maxY && (v.currentY = v.maxY - 1 + (v.currentY - v.maxY + 1) ** .8), b.prevPositionX || (b.prevPositionX = v.touchesCurrent.x), b.prevPositionY || (b.prevPositionY = v.touchesCurrent.y), b.prevTime || (b.prevTime = Date.now()), b.x = (v.touchesCurrent.x - b.prevPositionX) / (Date.now() - b.prevTime) / 2, b.y = (v.touchesCurrent.y - b.prevPositionY) / (Date.now() - b.prevTime) / 2, Math.abs(v.touchesCurrent.x - b.prevPositionX) < 2 && (b.x = 0), Math.abs(v.touchesCurrent.y - b.prevPositionY) < 2 && (b.y = 0), b.prevPositionX = v.touchesCurrent.x, b.prevPositionY = v.touchesCurrent.y, b.prevTime = Date.now(), g.imageWrapEl.style.transform = `translate3d(${v.currentX}px, ${v.currentY}px,0)` } function O() { const e = t.zoom; g.slideEl && t.activeIndex !== t.slides.indexOf(g.slideEl) && (g.imageEl && (g.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), g.imageWrapEl && (g.imageWrapEl.style.transform = "translate3d(0,0,0)"), g.slideEl.classList.remove("" + t.params.zoom.zoomedSlideClass), e.scale = 1, a = 1, g.slideEl = void 0, g.imageEl = void 0, g.imageWrapEl = void 0, g.originX = 0, g.originY = 0) } function k(e) { if (a <= 1 || !g.imageWrapEl) return; if (!T(e) || !C(e)) return; const t = o.getComputedStyle(g.imageWrapEl).transform, i = new o.DOMMatrix(t); if (!d) return d = !0, u.x = e.clientX, u.y = e.clientY, v.startX = i.e, v.startY = i.f, v.width = g.imageEl.offsetWidth || g.imageEl.clientWidth, v.height = g.imageEl.offsetHeight || g.imageEl.clientHeight, g.slideWidth = g.slideEl.offsetWidth, void (g.slideHeight = g.slideEl.offsetHeight); const n = -3 * (e.clientX - u.x), s = -3 * (e.clientY - u.y), r = v.width * a, l = v.height * a, c = g.slideWidth, p = g.slideHeight, f = Math.min(c / 2 - r / 2, 0), h = -f, m = Math.min(p / 2 - l / 2, 0), y = -m, b = Math.max(Math.min(v.startX + n, h), f), w = Math.max(Math.min(v.startY + s, y), m); g.imageWrapEl.style.transitionDuration = "0ms", g.imageWrapEl.style.transform = `translate3d(${b}px, ${w}px, 0)`, u.x = e.clientX, u.y = e.clientY, v.startX = b, v.startY = w } function z(e) { const i = t.zoom, n = t.params.zoom; if (!g.slideEl) { e && e.target && (g.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`)), g.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? g.slideEl = m(t.slidesEl, "." + t.params.slideActiveClass)[0] : g.slideEl = t.slides[t.activeIndex]); let i = g.slideEl.querySelector("." + n.containerClass); i && (i = i.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = i, g.imageWrapEl = i ? E(g.imageEl, "." + n.containerClass)[0] : void 0 } if (!g.imageEl || !g.imageWrapEl) return; let s, r, l, c, d, u, p, f, h, b, w, _, x, T, C, M, L, I; t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), g.slideEl.classList.add("" + n.zoomedSlideClass), void 0 === v.touchesStart.x && e ? (s = e.pageX, r = e.pageY) : (s = v.touchesStart.x, r = v.touchesStart.y); const A = "number" == typeof e ? e : null; 1 === a && A && (s = void 0, r = void 0, v.touchesStart.x = void 0, v.touchesStart.y = void 0); const P = S(); i.scale = A || P, a = A || P, !e || 1 === a && A ? (p = 0, f = 0) : (L = g.slideEl.offsetWidth, I = g.slideEl.offsetHeight, l = y(g.slideEl).left + o.scrollX, c = y(g.slideEl).top + o.scrollY, d = l + L / 2 - s, u = c + I / 2 - r, h = g.imageEl.offsetWidth || g.imageEl.clientWidth, b = g.imageEl.offsetHeight || g.imageEl.clientHeight, w = h * i.scale, _ = b * i.scale, x = Math.min(L / 2 - w / 2, 0), T = Math.min(I / 2 - _ / 2, 0), C = -x, M = -T, p = d * i.scale, f = u * i.scale, p < x && (p = x), p > C && (p = C), f < T && (f = T), f > M && (f = M)), A && 1 === i.scale && (g.originX = 0, g.originY = 0), g.imageWrapEl.style.transitionDuration = "300ms", g.imageWrapEl.style.transform = `translate3d(${p}px, ${f}px,0)`, g.imageEl.style.transitionDuration = "300ms", g.imageEl.style.transform = `translate3d(0,0,0) scale(${i.scale})` } function D() { const e = t.zoom, i = t.params.zoom; if (!g.slideEl) { t.params.virtual && t.params.virtual.enabled && t.virtual ? g.slideEl = m(t.slidesEl, "." + t.params.slideActiveClass)[0] : g.slideEl = t.slides[t.activeIndex]; let e = g.slideEl.querySelector("." + i.containerClass); e && (e = e.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = e, g.imageWrapEl = e ? E(g.imageEl, "." + i.containerClass)[0] : void 0 } g.imageEl && g.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, a = 1, v.touchesStart.x = void 0, v.touchesStart.y = void 0, g.imageWrapEl.style.transitionDuration = "300ms", g.imageWrapEl.style.transform = "translate3d(0,0,0)", g.imageEl.style.transitionDuration = "300ms", g.imageEl.style.transform = "translate3d(0,0,0) scale(1)", g.slideEl.classList.remove("" + i.zoomedSlideClass), g.slideEl = void 0, g.originX = 0, g.originY = 0, t.params.zoom.panOnMouseMove && (u = { x: 0, y: 0 }, d && (d = !1, v.startX = 0, v.startY = 0))) } function j(e) { const i = t.zoom; i.scale && 1 !== i.scale ? D() : z(e) } function $() { return { passiveListener: !!t.params.passiveListeners && { passive: !0, capture: !1 }, activeListenerWithCapture: !t.params.passiveListeners || { passive: !1, capture: !0 } } } function N() { const e = t.zoom; if (e.enabled) return; e.enabled = !0; const { passiveListener: i, activeListenerWithCapture: n } = $(); t.wrapperEl.addEventListener("pointerdown", M, i), t.wrapperEl.addEventListener("pointermove", L, n), ["pointerup", "pointercancel", "pointerout"].forEach(e => { t.wrapperEl.addEventListener(e, I, i) }), t.wrapperEl.addEventListener("pointermove", P, n) } function H() { const e = t.zoom; if (!e.enabled) return; e.enabled = !1; const { passiveListener: i, activeListenerWithCapture: n } = $(); t.wrapperEl.removeEventListener("pointerdown", M, i), t.wrapperEl.removeEventListener("pointermove", L, n), ["pointerup", "pointercancel", "pointerout"].forEach(e => { t.wrapperEl.removeEventListener(e, I, i) }), t.wrapperEl.removeEventListener("pointermove", P, n) } Object.defineProperty(t.zoom, "scale", { get: () => _, set(e) { if (_ !== e) { const t = g.imageEl, i = g.slideEl; s("zoomChange", e, t, i) } _ = e } }), n("init", () => { t.params.zoom.enabled && N() }), n("destroy", () => { H() }), n("touchStart", (e, i) => { t.zoom.enabled && function (e) { const i = t.device; if (!g.imageEl) return; if (v.isTouched) return; i.android && e.cancelable && e.preventDefault(), v.isTouched = !0; const n = h.length > 0 ? h[0] : e; v.touchesStart.x = n.pageX, v.touchesStart.y = n.pageY }(i) }), n("touchEnd", (e, i) => { t.zoom.enabled && function () { const e = t.zoom; if (h.length = 0, !g.imageEl) return; if (!v.isTouched || !v.isMoved) return v.isTouched = !1, void (v.isMoved = !1); v.isTouched = !1, v.isMoved = !1; let i = 300, n = 300; const s = b.x * i, r = v.currentX + s, o = b.y * n, a = v.currentY + o; 0 !== b.x && (i = Math.abs((r - v.currentX) / b.x)), 0 !== b.y && (n = Math.abs((a - v.currentY) / b.y)); const l = Math.max(i, n); v.currentX = r, v.currentY = a; const c = v.width * e.scale, d = v.height * e.scale; v.minX = Math.min(g.slideWidth / 2 - c / 2, 0), v.maxX = -v.minX, v.minY = Math.min(g.slideHeight / 2 - d / 2, 0), v.maxY = -v.minY, v.currentX = Math.max(Math.min(v.currentX, v.maxX), v.minX), v.currentY = Math.max(Math.min(v.currentY, v.maxY), v.minY), g.imageWrapEl.style.transitionDuration = l + "ms", g.imageWrapEl.style.transform = `translate3d(${v.currentX}px, ${v.currentY}px,0)` }() }), n("doubleTap", (e, i) => { !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && j(i) }), n("transitionEnd", () => { t.zoom.enabled && t.params.zoom.enabled && O() }), n("slideChange", () => { t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && O() }), Object.assign(t.zoom, { enable: N, disable: H, in: z, out: D, toggle: j }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; function s(e, t) { const i = function () { let e, t, i; return (n, s) => { for (t = -1, e = n.length; e - t > 1;)i = e + t >> 1, n[i] <= s ? t = i : e = i; return e } }(); let n, s; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (s = i(this.x, e), n = s - 1, (e - this.x[n]) * (this.y[s] - this.y[n]) / (this.x[s] - this.x[n]) + this.y[n]) : 0 }, this } function r() { t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline) } i({ controller: { control: void 0, inverse: !1, by: "slide" } }), t.controller = { control: void 0 }, n("beforeInit", () => { "undefined" != typeof window && ("string" == typeof t.params.controller.control || t.params.controller.control instanceof HTMLElement) ? ("string" == typeof t.params.controller.control ? [...document.querySelectorAll(t.params.controller.control)] : [t.params.controller.control]).forEach(e => { if (t.controller.control || (t.controller.control = []), e && e.swiper) t.controller.control.push(e.swiper); else if (e) { const i = t.params.eventsPrefix + "init", n = s => { t.controller.control.push(s.detail[0]), t.update(), e.removeEventListener(i, n) }; e.addEventListener(i, n) } }) : t.controller.control = t.params.controller.control }), n("update", () => { r() }), n("resize", () => { r() }), n("observerUpdate", () => { r() }), n("setTranslate", (e, i, n) => { t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(i, n) }), n("setTransition", (e, i, n) => { t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(i, n) }), Object.assign(t.controller, { setTranslate: function (e, i) { const n = t.controller.control; let r, o; const a = t.constructor; function l(e) { if (e.destroyed) return; const i = t.rtlTranslate ? -t.translate : t.translate; "slide" === t.params.controller.by && (function (e) { t.controller.spline = t.params.loop ? new s(t.slidesGrid, e.slidesGrid) : new s(t.snapGrid, e.snapGrid) }(e), o = -t.controller.spline.interpolate(-i)), o && "container" !== t.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), !Number.isNaN(r) && Number.isFinite(r) || (r = 1), o = (i - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (o = e.maxTranslate() - o), e.updateProgress(o), e.setTranslate(o, t), e.updateActiveIndex(), e.updateSlidesClasses() } if (Array.isArray(n)) for (let e = 0; e < n.length; e += 1)n[e] !== i && n[e] instanceof a && l(n[e]); else n instanceof a && i !== n && l(n) }, setTransition: function (e, i) { const n = t.constructor, s = t.controller.control; let r; function o(i) { i.destroyed || (i.setTransition(e, t), 0 !== e && (i.transitionStart(), i.params.autoHeight && a(() => { i.updateAutoHeight() }), _(i.wrapperEl, () => { s && i.transitionEnd() }))) } if (Array.isArray(s)) for (r = 0; r < s.length; r += 1)s[r] !== i && s[r] instanceof n && o(s[r]); else s instanceof n && i !== s && o(s) } }) }, function (e) { let { swiper: t, extendParams: i, on: s } = e; i({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, containerRole: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null, scrollOnFocus: !0 } }), t.a11y = { clicked: !1 }; let r, o, a = null, l = (new Date).getTime(); function c(e) { const t = a; 0 !== t.length && (t.innerHTML = "", t.innerHTML = e) } function d(e) { (e = S(e)).forEach(e => { e.setAttribute("tabIndex", "0") }) } function u(e) { (e = S(e)).forEach(e => { e.setAttribute("tabIndex", "-1") }) } function p(e, t) { (e = S(e)).forEach(e => { e.setAttribute("role", t) }) } function f(e, t) { (e = S(e)).forEach(e => { e.setAttribute("aria-roledescription", t) }) } function h(e, t) { (e = S(e)).forEach(e => { e.setAttribute("aria-label", t) }) } function m(e) { (e = S(e)).forEach(e => { e.setAttribute("aria-disabled", !0) }) } function g(e) { (e = S(e)).forEach(e => { e.setAttribute("aria-disabled", !1) }) } function y(e) { if (13 !== e.keyCode && 32 !== e.keyCode) return; const i = t.params.a11y, n = e.target; if (!t.pagination || !t.pagination.el || n !== t.pagination.el && !t.pagination.el.contains(e.target) || e.target.matches(te(t.params.pagination.bulletClass))) { if (t.navigation && t.navigation.prevEl && t.navigation.nextEl) { const e = S(t.navigation.prevEl); S(t.navigation.nextEl).includes(n) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? c(i.lastSlideMessage) : c(i.nextSlideMessage)), e.includes(n) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? c(i.firstSlideMessage) : c(i.prevSlideMessage)) } t.pagination && n.matches(te(t.params.pagination.bulletClass)) && n.click() } } function b() { return t.pagination && t.pagination.bullets && t.pagination.bullets.length } function E() { return b() && t.params.pagination.clickable } const _ = (e, t, i) => { d(e), "BUTTON" !== e.tagName && (p(e, "button"), e.addEventListener("keydown", y)), h(e, i), function (e, t) { (e = S(e)).forEach(e => { e.setAttribute("aria-controls", t) }) }(e, t) }, x = e => { o && o !== e.target && !o.contains(e.target) && (r = !0), t.a11y.clicked = !0 }, T = () => { r = !1, requestAnimationFrame(() => { requestAnimationFrame(() => { t.destroyed || (t.a11y.clicked = !1) }) }) }, C = e => { l = (new Date).getTime() }, M = e => { if (t.a11y.clicked || !t.params.a11y.scrollOnFocus) return; if ((new Date).getTime() - l < 100) return; const i = e.target.closest(`.${t.params.slideClass}, swiper-slide`); if (!i || !t.slides.includes(i)) return; o = i; const n = t.slides.indexOf(i) === t.activeIndex, s = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(i); n || s || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, requestAnimationFrame(() => { r || (t.params.loop ? t.slideToLoop(parseInt(i.getAttribute("data-swiper-slide-index")), 0) : t.slideTo(t.slides.indexOf(i), 0), r = !1) })) }, L = () => { const e = t.params.a11y; e.itemRoleDescriptionMessage && f(t.slides, e.itemRoleDescriptionMessage), e.slideRole && p(t.slides, e.slideRole); const i = t.slides.length; e.slideLabelMessage && t.slides.forEach((n, s) => { const r = t.params.loop ? parseInt(n.getAttribute("data-swiper-slide-index"), 10) : s; h(n, e.slideLabelMessage.replace(/\{\{index\}\}/, r + 1).replace(/\{\{slidesLength\}\}/, i)) }) }; s("beforeInit", () => { a = v("span", t.params.a11y.notificationClass), a.setAttribute("aria-live", "assertive"), a.setAttribute("aria-atomic", "true") }), s("afterInit", () => { t.params.a11y.enabled && (() => { const e = t.params.a11y; t.el.append(a); const i = t.el; e.containerRoleDescriptionMessage && f(i, e.containerRoleDescriptionMessage), e.containerMessage && h(i, e.containerMessage), e.containerRole && p(i, e.containerRole); const s = t.wrapperEl, r = e.id || s.getAttribute("id") || "swiper-wrapper-" + (void 0 === (o = 16) && (o = 16), "x".repeat(o).replace(/x/g, () => Math.round(16 * Math.random()).toString(16))); var o; const l = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite"; var c; c = r, S(s).forEach(e => { e.setAttribute("id", c) }), function (e, t) { (e = S(e)).forEach(e => { e.setAttribute("aria-live", t) }) }(s, l), L(); let { nextEl: d, prevEl: u } = t.navigation ? t.navigation : {}; d = S(d), u = S(u), d && d.forEach(t => _(t, r, e.nextSlideMessage)), u && u.forEach(t => _(t, r, e.prevSlideMessage)), E() && S(t.pagination.el).forEach(e => { e.addEventListener("keydown", y) }), n().addEventListener("visibilitychange", C), t.el.addEventListener("focus", M, !0), t.el.addEventListener("focus", M, !0), t.el.addEventListener("pointerdown", x, !0), t.el.addEventListener("pointerup", T, !0) })() }), s("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => { t.params.a11y.enabled && L() }), s("fromEdge toEdge afterInit lock unlock", () => { t.params.a11y.enabled && function () { if (t.params.loop || t.params.rewind || !t.navigation) return; const { nextEl: e, prevEl: i } = t.navigation; i && (t.isBeginning ? (m(i), u(i)) : (g(i), d(i))), e && (t.isEnd ? (m(e), u(e)) : (g(e), d(e))) }() }), s("paginationUpdate", () => { t.params.a11y.enabled && function () { const e = t.params.a11y; b() && t.pagination.bullets.forEach(i => { t.params.pagination.clickable && (d(i), t.params.pagination.renderBullet || (p(i, "button"), h(i, e.paginationBulletMessage.replace(/\{\{index\}\}/, w(i) + 1)))), i.matches(te(t.params.pagination.bulletActiveClass)) ? i.setAttribute("aria-current", "true") : i.removeAttribute("aria-current") }) }() }), s("destroy", () => { t.params.a11y.enabled && function () { a && a.remove(); let { nextEl: e, prevEl: i } = t.navigation ? t.navigation : {}; e = S(e), i = S(i), e && e.forEach(e => e.removeEventListener("keydown", y)), i && i.forEach(e => e.removeEventListener("keydown", y)), E() && S(t.pagination.el).forEach(e => { e.removeEventListener("keydown", y) }), n().removeEventListener("visibilitychange", C), t.el && "string" != typeof t.el && (t.el.removeEventListener("focus", M, !0), t.el.removeEventListener("pointerdown", x, !0), t.el.removeEventListener("pointerup", T, !0)) }() }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ history: { enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1 } }); let s = !1, o = {}; const a = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), l = e => { const t = r(); let i; i = e ? new URL(e) : t.location; const n = i.pathname.slice(1).split("/").filter(e => "" !== e), s = n.length; return { key: n[s - 2], value: n[s - 1] } }, c = (e, i) => { const n = r(); if (!s || !t.params.history.enabled) return; let o; o = t.params.url ? new URL(t.params.url) : n.location; const l = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${i}"]`) : t.slides[i]; let c = a(l.getAttribute("data-history")); if (t.params.history.root.length > 0) { let i = t.params.history.root; "/" === i[i.length - 1] && (i = i.slice(0, i.length - 1)), c = `${i}/${e ? e + "/" : ""}${c}` } else o.pathname.includes(e) || (c = `${e ? e + "/" : ""}${c}`); t.params.history.keepQuery && (c += o.search); const d = n.history.state; d && d.value === c || (t.params.history.replaceState ? n.history.replaceState({ value: c }, null, c) : n.history.pushState({ value: c }, null, c)) }, d = (e, i, n) => { if (i) for (let s = 0, r = t.slides.length; s < r; s += 1) { const r = t.slides[s]; if (a(r.getAttribute("data-history")) === i) { const i = t.getSlideIndex(r); t.slideTo(i, e, n) } } else t.slideTo(0, e, n) }, u = () => { o = l(t.params.url), d(t.params.speed, o.value, !1) }; n("init", () => { t.params.history.enabled && (() => { const e = r(); if (t.params.history) { if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0); s = !0, o = l(t.params.url), o.key || o.value ? (d(0, o.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", u)) : t.params.history.replaceState || e.addEventListener("popstate", u) } })() }), n("destroy", () => { t.params.history.enabled && (() => { const e = r(); t.params.history.replaceState || e.removeEventListener("popstate", u) })() }), n("transitionEnd _freeModeNoMomentumRelease", () => { s && c(t.params.history.key, t.activeIndex) }), n("slideChange", () => { s && t.params.cssMode && c(t.params.history.key, t.activeIndex) }) }, function (e) { let { swiper: t, extendParams: i, emit: s, on: o } = e, a = !1; const l = n(), c = r(); i({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1, getSlideIndex(e, i) { if (t.virtual && t.params.virtual.enabled) { const e = t.slides.find(e => e.getAttribute("data-hash") === i); return e ? parseInt(e.getAttribute("data-swiper-slide-index"), 10) : 0 } return t.getSlideIndex(m(t.slidesEl, `.${t.params.slideClass}[data-hash="${i}"], swiper-slide[data-hash="${i}"]`)[0]) } } }); const d = () => { s("hashChange"); const e = l.location.hash.replace("#", ""), i = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex]; if (e !== (i ? i.getAttribute("data-hash") : "")) { const i = t.params.hashNavigation.getSlideIndex(t, e); if (void 0 === i || Number.isNaN(i)) return; t.slideTo(i) } }, u = () => { if (!a || !t.params.hashNavigation.enabled) return; const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex], i = e ? e.getAttribute("data-hash") || e.getAttribute("data-history") : ""; t.params.hashNavigation.replaceState && c.history && c.history.replaceState ? (c.history.replaceState(null, null, "#" + i || ""), s("hashSet")) : (l.location.hash = i || "", s("hashSet")) }; o("init", () => { t.params.hashNavigation.enabled && (() => { if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return; a = !0; const e = l.location.hash.replace("#", ""); if (e) { const i = 0, n = t.params.hashNavigation.getSlideIndex(t, e); t.slideTo(n || 0, i, t.params.runCallbacksOnInit, !0) } t.params.hashNavigation.watchState && c.addEventListener("hashchange", d) })() }), o("destroy", () => { t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && c.removeEventListener("hashchange", d) }), o("transitionEnd _freeModeNoMomentumRelease", () => { a && u() }), o("slideChange", () => { a && t.params.cssMode && u() }) }, function (e) { let t, i, { swiper: s, extendParams: r, on: o, emit: a, params: l } = e; s.autoplay = { running: !1, paused: !1, timeLeft: 0 }, r({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let c, d, u, p, f, h, m, g, v = l && l.autoplay ? l.autoplay.delay : 3e3, y = l && l.autoplay ? l.autoplay.delay : 3e3, b = (new Date).getTime(); function w(e) { s && !s.destroyed && s.wrapperEl && e.target === s.wrapperEl && (s.wrapperEl.removeEventListener("transitionend", w), g || e.detail && e.detail.bySwiperTouchMove || C()) } const E = () => { if (s.destroyed || !s.autoplay.running) return; s.autoplay.paused ? d = !0 : d && (y = c, d = !1); const e = s.autoplay.paused ? c : b + y - (new Date).getTime(); s.autoplay.timeLeft = e, a("autoplayTimeLeft", e, e / v), i = requestAnimationFrame(() => { E() }) }, _ = e => { if (s.destroyed || !s.autoplay.running) return; cancelAnimationFrame(i), E(); let n = void 0 === e ? s.params.autoplay.delay : e; v = s.params.autoplay.delay, y = s.params.autoplay.delay; const r = (() => { let e; if (e = s.virtual && s.params.virtual.enabled ? s.slides.find(e => e.classList.contains("swiper-slide-active")) : s.slides[s.activeIndex], e) return parseInt(e.getAttribute("data-swiper-autoplay"), 10) })(); !Number.isNaN(r) && r > 0 && void 0 === e && (n = r, v = r, y = r), c = n; const o = s.params.speed, l = () => { s && !s.destroyed && (s.params.autoplay.reverseDirection ? !s.isBeginning || s.params.loop || s.params.rewind ? (s.slidePrev(o, !0, !0), a("autoplay")) : s.params.autoplay.stopOnLastSlide || (s.slideTo(s.slides.length - 1, o, !0, !0), a("autoplay")) : !s.isEnd || s.params.loop || s.params.rewind ? (s.slideNext(o, !0, !0), a("autoplay")) : s.params.autoplay.stopOnLastSlide || (s.slideTo(0, o, !0, !0), a("autoplay")), s.params.cssMode && (b = (new Date).getTime(), requestAnimationFrame(() => { _() }))) }; return n > 0 ? (clearTimeout(t), t = setTimeout(() => { l() }, n)) : requestAnimationFrame(() => { l() }), n }, x = () => { b = (new Date).getTime(), s.autoplay.running = !0, _(), a("autoplayStart") }, S = () => { s.autoplay.running = !1, clearTimeout(t), cancelAnimationFrame(i), a("autoplayStop") }, T = (e, i) => { if (s.destroyed || !s.autoplay.running) return; clearTimeout(t), e || (m = !0); const n = () => { a("autoplayPause"), s.params.autoplay.waitForTransition ? s.wrapperEl.addEventListener("transitionend", w) : C() }; if (s.autoplay.paused = !0, i) return h && (c = s.params.autoplay.delay), h = !1, void n(); const r = c || s.params.autoplay.delay; c = r - ((new Date).getTime() - b), s.isEnd && c < 0 && !s.params.loop || (c < 0 && (c = 0), n()) }, C = () => { s.isEnd && c < 0 && !s.params.loop || s.destroyed || !s.autoplay.running || (b = (new Date).getTime(), m ? (m = !1, _(c)) : _(), s.autoplay.paused = !1, a("autoplayResume")) }, M = () => { if (s.destroyed || !s.autoplay.running) return; const e = n(); "hidden" === e.visibilityState && (m = !0, T(!0)), "visible" === e.visibilityState && C() }, L = e => { "mouse" === e.pointerType && (m = !0, g = !0, s.animating || s.autoplay.paused || T(!0)) }, I = e => { "mouse" === e.pointerType && (g = !1, s.autoplay.paused && C()) }; o("init", () => { s.params.autoplay.enabled && (s.params.autoplay.pauseOnMouseEnter && (s.el.addEventListener("pointerenter", L), s.el.addEventListener("pointerleave", I)), n().addEventListener("visibilitychange", M), x()) }), o("destroy", () => { s.el && "string" != typeof s.el && (s.el.removeEventListener("pointerenter", L), s.el.removeEventListener("pointerleave", I)), n().removeEventListener("visibilitychange", M), s.autoplay.running && S() }), o("_freeModeStaticRelease", () => { (p || m) && C() }), o("_freeModeNoMomentumRelease", () => { s.params.autoplay.disableOnInteraction ? S() : T(!0, !0) }), o("beforeTransitionStart", (e, t, i) => { !s.destroyed && s.autoplay.running && (i || !s.params.autoplay.disableOnInteraction ? T(!0, !0) : S()) }), o("sliderFirstMove", () => { !s.destroyed && s.autoplay.running && (s.params.autoplay.disableOnInteraction ? S() : (u = !0, p = !1, m = !1, f = setTimeout(() => { m = !0, p = !0, T(!0) }, 200))) }), o("touchEnd", () => { if (!s.destroyed && s.autoplay.running && u) { if (clearTimeout(f), clearTimeout(t), s.params.autoplay.disableOnInteraction) return p = !1, void (u = !1); p && s.params.cssMode && C(), p = !1, u = !1 } }), o("slideChange", () => { !s.destroyed && s.autoplay.running && (h = !0) }), Object.assign(s.autoplay, { start: x, stop: S, pause: T, resume: C }) }, function (e) { let { swiper: t, extendParams: i, on: s } = e; i({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let r = !1, o = !1; function a() { const e = t.thumbs.swiper; if (!e || e.destroyed) return; const i = e.clickedIndex, n = e.clickedSlide; if (n && n.classList.contains(t.params.thumbs.slideThumbActiveClass)) return; if (null == i) return; let s; s = e.params.loop ? parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : i, t.params.loop ? t.slideToLoop(s) : t.slideTo(s) } function l() { const { thumbs: e } = t.params; if (r) return !1; r = !0; const i = t.constructor; if (e.swiper instanceof i) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(t.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper.update(); else if (d(e.swiper)) { const n = Object.assign({}, e.swiper); Object.assign(n, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper = new i(n), o = !0 } return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", a), !0 } function c(e) { const i = t.thumbs.swiper; if (!i || i.destroyed) return; const n = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView; let s = 1; const r = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (s = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (s = 1), s = Math.floor(s), i.slides.forEach(e => e.classList.remove(r)), i.params.loop || i.params.virtual && i.params.virtual.enabled) for (let e = 0; e < s; e += 1)m(i.slidesEl, `[data-swiper-slide-index="${t.realIndex + e}"]`).forEach(e => { e.classList.add(r) }); else for (let e = 0; e < s; e += 1)i.slides[t.realIndex + e] && i.slides[t.realIndex + e].classList.add(r); const o = t.params.thumbs.autoScrollOffset, a = o && !i.params.loop; if (t.realIndex !== i.realIndex || a) { const s = i.activeIndex; let r, l; if (i.params.loop) { const e = i.slides.find(e => e.getAttribute("data-swiper-slide-index") === "" + t.realIndex); r = i.slides.indexOf(e), l = t.activeIndex > t.previousIndex ? "next" : "prev" } else r = t.realIndex, l = r > t.previousIndex ? "next" : "prev"; a && (r += "next" === l ? o : -1 * o), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(r) < 0 && (i.params.centeredSlides ? r = r > s ? r - Math.floor(n / 2) + 1 : r + Math.floor(n / 2) - 1 : r > s && i.params.slidesPerGroup, i.slideTo(r, e ? 0 : void 0)) } } t.thumbs = { swiper: null }, s("beforeInit", () => { const { thumbs: e } = t.params; if (e && e.swiper) if ("string" == typeof e.swiper || e.swiper instanceof HTMLElement) { const i = n(), s = () => { const n = "string" == typeof e.swiper ? i.querySelector(e.swiper) : e.swiper; if (n && n.swiper) e.swiper = n.swiper, l(), c(!0); else if (n) { const i = t.params.eventsPrefix + "init", s = r => { e.swiper = r.detail[0], n.removeEventListener(i, s), l(), c(!0), e.swiper.update(), t.update() }; n.addEventListener(i, s) } return n }, r = () => { t.destroyed || s() || requestAnimationFrame(r) }; requestAnimationFrame(r) } else l(), c(!0) }), s("slideChange update resize observerUpdate", () => { c() }), s("setTransition", (e, i) => { const n = t.thumbs.swiper; n && !n.destroyed && n.setTransition(i) }), s("beforeDestroy", () => { const e = t.thumbs.swiper; e && !e.destroyed && o && e.destroy() }), Object.assign(t.thumbs, { init: l, update: c }) }, function (e) { let { swiper: t, extendParams: i, emit: n, once: s } = e; i({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }), Object.assign(t, { freeMode: { onTouchStart: function () { if (t.params.cssMode) return; const e = t.getTranslate(); t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({ currentPos: t.rtl ? t.translate : -t.translate }) }, onTouchMove: function () { if (t.params.cssMode) return; const { touchEventsData: e, touches: i } = t; 0 === e.velocities.length && e.velocities.push({ position: i[t.isHorizontal() ? "startX" : "startY"], time: e.touchStartTime }), e.velocities.push({ position: i[t.isHorizontal() ? "currentX" : "currentY"], time: l() }) }, onTouchEnd: function (e) { let { currentPos: i } = e; if (t.params.cssMode) return; const { params: r, wrapperEl: o, rtlTranslate: a, snapGrid: c, touchEventsData: d } = t, u = l() - d.touchStartTime; if (i < -t.minTranslate()) t.slideTo(t.activeIndex); else if (i > -t.maxTranslate()) t.slides.length < c.length ? t.slideTo(c.length - 1) : t.slideTo(t.slides.length - 1); else { if (r.freeMode.momentum) { if (d.velocities.length > 1) { const e = d.velocities.pop(), i = d.velocities.pop(), n = e.position - i.position, s = e.time - i.time; t.velocity = n / s, t.velocity /= 2, Math.abs(t.velocity) < r.freeMode.minimumVelocity && (t.velocity = 0), (s > 150 || l() - e.time > 300) && (t.velocity = 0) } else t.velocity = 0; t.velocity *= r.freeMode.momentumVelocityRatio, d.velocities.length = 0; let e = 1e3 * r.freeMode.momentumRatio; const i = t.velocity * e; let u = t.translate + i; a && (u = -u); let p, f = !1; const h = 20 * Math.abs(t.velocity) * r.freeMode.momentumBounceRatio; let m; if (u < t.maxTranslate()) r.freeMode.momentumBounce ? (u + t.maxTranslate() < -h && (u = t.maxTranslate() - h), p = t.maxTranslate(), f = !0, d.allowMomentumBounce = !0) : u = t.maxTranslate(), r.loop && r.centeredSlides && (m = !0); else if (u > t.minTranslate()) r.freeMode.momentumBounce ? (u - t.minTranslate() > h && (u = t.minTranslate() + h), p = t.minTranslate(), f = !0, d.allowMomentumBounce = !0) : u = t.minTranslate(), r.loop && r.centeredSlides && (m = !0); else if (r.freeMode.sticky) { let e; for (let t = 0; t < c.length; t += 1)if (c[t] > -u) { e = t; break } u = Math.abs(c[e] - u) < Math.abs(c[e - 1] - u) || "next" === t.swipeDirection ? c[e] : c[e - 1], u = -u } if (m && s("transitionEnd", () => { t.loopFix() }), 0 !== t.velocity) { if (e = a ? Math.abs((-u - t.translate) / t.velocity) : Math.abs((u - t.translate) / t.velocity), r.freeMode.sticky) { const i = Math.abs((a ? -u : u) - t.translate), n = t.slidesSizesGrid[t.activeIndex]; e = i < n ? r.speed : i < 2 * n ? 1.5 * r.speed : 2.5 * r.speed } } else if (r.freeMode.sticky) return void t.slideToClosest(); r.freeMode.momentumBounce && f ? (t.updateProgress(p), t.setTransition(e), t.setTranslate(u), t.transitionStart(!0, t.swipeDirection), t.animating = !0, _(o, () => { t && !t.destroyed && d.allowMomentumBounce && (n("momentumBounce"), t.setTransition(r.speed), setTimeout(() => { t.setTranslate(p), _(o, () => { t && !t.destroyed && t.transitionEnd() }) }, 0)) })) : t.velocity ? (n("_freeModeNoMomentumRelease"), t.updateProgress(u), t.setTransition(e), t.setTranslate(u), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, _(o, () => { t && !t.destroyed && t.transitionEnd() }))) : t.updateProgress(u), t.updateActiveIndex(), t.updateSlidesClasses() } else { if (r.freeMode.sticky) return void t.slideToClosest(); r.freeMode && n("_freeModeNoMomentumRelease") } (!r.freeMode.momentum || u >= r.longSwipesMs) && (n("_freeModeStaticRelease"), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()) } } } }) }, function (e) { let t, i, n, s, { swiper: r, extendParams: o, on: a } = e; o({ grid: { rows: 1, fill: "column" } }); const l = () => { let e = r.params.spaceBetween; return "string" == typeof e && e.indexOf("%") >= 0 ? e = parseFloat(e.replace("%", "")) / 100 * r.size : "string" == typeof e && (e = parseFloat(e)), e }; a("init", () => { s = r.params.grid && r.params.grid.rows > 1 }), a("update", () => { const { params: e, el: t } = r, i = e.grid && e.grid.rows > 1; s && !i ? (t.classList.remove(e.containerModifierClass + "grid", e.containerModifierClass + "grid-column"), n = 1, r.emitContainerClasses()) : !s && i && (t.classList.add(e.containerModifierClass + "grid"), "column" === e.grid.fill && t.classList.add(e.containerModifierClass + "grid-column"), r.emitContainerClasses()), s = i }), r.grid = { initSlides: e => { const { slidesPerView: s } = r.params, { rows: o, fill: a } = r.params.grid, l = r.virtual && r.params.virtual.enabled ? r.virtual.slides.length : e.length; n = Math.floor(l / o), t = Math.floor(l / o) === l / o ? l : Math.ceil(l / o) * o, "auto" !== s && "row" === a && (t = Math.max(t, s * o)), i = t / o }, unsetSlides: () => { r.slides && r.slides.forEach(e => { e.swiperSlideGridSet && (e.style.height = "", e.style[r.getDirectionLabel("margin-top")] = "") }) }, updateSlide: (e, s, o) => { const { slidesPerGroup: a } = r.params, c = l(), { rows: d, fill: u } = r.params.grid, p = r.virtual && r.params.virtual.enabled ? r.virtual.slides.length : o.length; let f, h, m; if ("row" === u && a > 1) { const i = Math.floor(e / (a * d)), n = e - d * a * i, r = 0 === i ? a : Math.min(Math.ceil((p - i * d * a) / d), a); m = Math.floor(n / r), h = n - m * r + i * a, f = h + m * t / d, s.style.order = f } else "column" === u ? (h = Math.floor(e / d), m = e - h * d, (h > n || h === n && m === d - 1) && (m += 1, m >= d && (m = 0, h += 1))) : (m = Math.floor(e / i), h = e - m * i); s.row = m, s.column = h, s.style.height = `calc((100% - ${(d - 1) * c}px) / ${d})`, s.style[r.getDirectionLabel("margin-top")] = 0 !== m ? c && c + "px" : "", s.swiperSlideGridSet = !0 }, updateWrapperSize: (e, i) => { const { centeredSlides: n, roundLengths: s } = r.params, o = l(), { rows: a } = r.params.grid; if (r.virtualSize = (e + o) * t, r.virtualSize = Math.ceil(r.virtualSize / a) - o, r.params.cssMode || (r.wrapperEl.style[r.getDirectionLabel("width")] = r.virtualSize + o + "px"), n) { const e = []; for (let t = 0; t < i.length; t += 1) { let n = i[t]; s && (n = Math.floor(n)), i[t] < r.virtualSize + i[0] && e.push(n) } i.splice(0, i.length), i.push(...e) } } } }, function (e) { let { swiper: t } = e; Object.assign(t, { appendSlide: ie.bind(t), prependSlide: ne.bind(t), addSlide: se.bind(t), removeSlide: re.bind(t), removeAllSlides: oe.bind(t) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ fadeEffect: { crossFade: !1 } }), ae({ effect: "fade", swiper: t, on: n, setTranslate: () => { const { slides: e } = t; t.params.fadeEffect; for (let i = 0; i < e.length; i += 1) { const e = t.slides[i]; let n = -e.swiperSlideOffset; t.params.virtualTranslate || (n -= t.translate); let s = 0; t.isHorizontal() || (s = n, n = 0); const r = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e.progress), 0) : 1 + Math.min(Math.max(e.progress, -1), 0), o = le(0, e); o.style.opacity = r, o.style.transform = `translate3d(${n}px, ${s}px, 0px)` } }, setTransition: e => { const i = t.slides.map(e => h(e)); i.forEach(t => { t.style.transitionDuration = e + "ms" }), ce({ swiper: t, duration: e, transformElements: i, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const s = (e, t, i) => { let n = i ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"), s = i ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom"); n || (n = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (i ? "left" : "top")).split(" ")), e.append(n)), s || (s = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (i ? "right" : "bottom")).split(" ")), e.append(s)), n && (n.style.opacity = Math.max(-t, 0)), s && (s.style.opacity = Math.max(t, 0)) }; ae({ effect: "cube", swiper: t, on: n, setTranslate: () => { const { el: e, wrapperEl: i, slides: n, width: r, height: o, rtlTranslate: a, size: l, browser: c } = t, d = T(t), u = t.params.cubeEffect, p = t.isHorizontal(), f = t.virtual && t.params.virtual.enabled; let h, m = 0; u.shadow && (p ? (h = t.wrapperEl.querySelector(".swiper-cube-shadow"), h || (h = v("div", "swiper-cube-shadow"), t.wrapperEl.append(h)), h.style.height = r + "px") : (h = e.querySelector(".swiper-cube-shadow"), h || (h = v("div", "swiper-cube-shadow"), e.append(h)))); for (let e = 0; e < n.length; e += 1) { const t = n[e]; let i = e; f && (i = parseInt(t.getAttribute("data-swiper-slide-index"), 10)); let r = 90 * i, o = Math.floor(r / 360); a && (r = -r, o = Math.floor(-r / 360)); const c = Math.max(Math.min(t.progress, 1), -1); let h = 0, g = 0, v = 0; i % 4 == 0 ? (h = 4 * -o * l, v = 0) : (i - 1) % 4 == 0 ? (h = 0, v = 4 * -o * l) : (i - 2) % 4 == 0 ? (h = l + 4 * o * l, v = l) : (i - 3) % 4 == 0 && (h = -l, v = 3 * l + 4 * l * o), a && (h = -h), p || (g = h, h = 0); const y = `rotateX(${d(p ? 0 : -r)}deg) rotateY(${d(p ? r : 0)}deg) translate3d(${h}px, ${g}px, ${v}px)`; c <= 1 && c > -1 && (m = 90 * i + 90 * c, a && (m = 90 * -i - 90 * c)), t.style.transform = y, u.slideShadows && s(t, c, p) } if (i.style.transformOrigin = `50% 50% -${l / 2}px`, i.style["-webkit-transform-origin"] = `50% 50% -${l / 2}px`, u.shadow) if (p) h.style.transform = `translate3d(0px, ${r / 2 + u.shadowOffset}px, ${-r / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${u.shadowScale})`; else { const e = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90), t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), i = u.shadowScale, n = u.shadowScale / t, s = u.shadowOffset; h.style.transform = `scale3d(${i}, 1, ${n}) translate3d(0px, ${o / 2 + s}px, ${-o / 2 / n}px) rotateX(-89.99deg)` } const g = (c.isSafari || c.isWebView) && c.needPerspectiveFix ? -l / 2 : 0; i.style.transform = `translate3d(0px,0,${g}px) rotateX(${d(t.isHorizontal() ? 0 : m)}deg) rotateY(${d(t.isHorizontal() ? -m : 0)}deg)`, i.style.setProperty("--swiper-cube-translate-z", g + "px") }, setTransition: e => { const { el: i, slides: n } = t; if (n.forEach(t => { t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => { t.style.transitionDuration = e + "ms" }) }), t.params.cubeEffect.shadow && !t.isHorizontal()) { const t = i.querySelector(".swiper-cube-shadow"); t && (t.style.transitionDuration = e + "ms") } }, recreateShadows: () => { const e = t.isHorizontal(); t.slides.forEach(t => { const i = Math.max(Math.min(t.progress, 1), -1); s(t, i, e) }) }, getEffectParams: () => t.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ flipEffect: { slideShadows: !0, limitRotation: !0 } }); const s = (e, i) => { let n = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"), s = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom"); n || (n = de("flip", e, t.isHorizontal() ? "left" : "top")), s || (s = de("flip", e, t.isHorizontal() ? "right" : "bottom")), n && (n.style.opacity = Math.max(-i, 0)), s && (s.style.opacity = Math.max(i, 0)) }; ae({ effect: "flip", swiper: t, on: n, setTranslate: () => { const { slides: e, rtlTranslate: i } = t, n = t.params.flipEffect, r = T(t); for (let o = 0; o < e.length; o += 1) { const a = e[o]; let l = a.progress; t.params.flipEffect.limitRotation && (l = Math.max(Math.min(a.progress, 1), -1)); const c = a.swiperSlideOffset; let d = -180 * l, u = 0, p = t.params.cssMode ? -c - t.translate : -c, f = 0; t.isHorizontal() ? i && (d = -d) : (f = p, p = 0, u = -d, d = 0), a.style.zIndex = -Math.abs(Math.round(l)) + e.length, n.slideShadows && s(a, l); const h = `translate3d(${p}px, ${f}px, 0px) rotateX(${r(u)}deg) rotateY(${r(d)}deg)`; le(0, a).style.transform = h } }, setTransition: e => { const i = t.slides.map(e => h(e)); i.forEach(t => { t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => { t.style.transitionDuration = e + "ms" }) }), ce({ swiper: t, duration: e, transformElements: i }) }, recreateShadows: () => { t.params.flipEffect, t.slides.forEach(e => { let i = e.progress; t.params.flipEffect.limitRotation && (i = Math.max(Math.min(e.progress, 1), -1)), s(e, i) }) }, getEffectParams: () => t.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0 } }), ae({ effect: "coverflow", swiper: t, on: n, setTranslate: () => { const { width: e, height: i, slides: n, slidesSizesGrid: s } = t, r = t.params.coverflowEffect, o = t.isHorizontal(), a = t.translate, l = o ? e / 2 - a : i / 2 - a, c = o ? r.rotate : -r.rotate, d = r.depth, u = T(t); for (let e = 0, t = n.length; e < t; e += 1) { const t = n[e], i = s[e], a = (l - t.swiperSlideOffset - i / 2) / i, p = "function" == typeof r.modifier ? r.modifier(a) : a * r.modifier; let f = o ? c * p : 0, h = o ? 0 : c * p, m = -d * Math.abs(p), g = r.stretch; "string" == typeof g && -1 !== g.indexOf("%") && (g = parseFloat(r.stretch) / 100 * i); let v = o ? 0 : g * p, y = o ? g * p : 0, b = 1 - (1 - r.scale) * Math.abs(p); Math.abs(y) < .001 && (y = 0), Math.abs(v) < .001 && (v = 0), Math.abs(m) < .001 && (m = 0), Math.abs(f) < .001 && (f = 0), Math.abs(h) < .001 && (h = 0), Math.abs(b) < .001 && (b = 0); const w = `translate3d(${y}px,${v}px,${m}px)  rotateX(${u(h)}deg) rotateY(${u(f)}deg) scale(${b})`; if (le(0, t).style.transform = w, t.style.zIndex = 1 - Math.abs(Math.round(p)), r.slideShadows) { let e = o ? t.querySelector(".swiper-slide-shadow-left") : t.querySelector(".swiper-slide-shadow-top"), i = o ? t.querySelector(".swiper-slide-shadow-right") : t.querySelector(".swiper-slide-shadow-bottom"); e || (e = de("coverflow", t, o ? "left" : "top")), i || (i = de("coverflow", t, o ? "right" : "bottom")), e && (e.style.opacity = p > 0 ? p : 0), i && (i.style.opacity = -p > 0 ? -p : 0) } } }, setTransition: e => { t.slides.map(e => h(e)).forEach(t => { t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => { t.style.transitionDuration = e + "ms" }) }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ creativeEffect: { limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const s = e => "string" == typeof e ? e : e + "px"; ae({ effect: "creative", swiper: t, on: n, setTranslate: () => { const { slides: e, wrapperEl: i, slidesSizesGrid: n } = t, r = t.params.creativeEffect, { progressMultiplier: o } = r, a = t.params.centeredSlides, l = T(t); if (a) { const e = n[0] / 2 - t.params.slidesOffsetBefore || 0; i.style.transform = `translateX(calc(50% - ${e}px))` } for (let i = 0; i < e.length; i += 1) { const n = e[i], c = n.progress, d = Math.min(Math.max(n.progress, -r.limitProgress), r.limitProgress); let u = d; a || (u = Math.min(Math.max(n.originalProgress, -r.limitProgress), r.limitProgress)); const p = n.swiperSlideOffset, f = [t.params.cssMode ? -p - t.translate : -p, 0, 0], h = [0, 0, 0]; let m = !1; t.isHorizontal() || (f[1] = f[0], f[0] = 0); let g = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; d < 0 ? (g = r.next, m = !0) : d > 0 && (g = r.prev, m = !0), f.forEach((e, t) => { f[t] = `calc(${e}px + (${s(g.translate[t])} * ${Math.abs(d * o)}))` }), h.forEach((e, t) => { let i = g.rotate[t] * Math.abs(d * o); h[t] = i }), n.style.zIndex = -Math.abs(Math.round(c)) + e.length; const v = f.join(", "), y = `rotateX(${l(h[0])}deg) rotateY(${l(h[1])}deg) rotateZ(${l(h[2])}deg)`, b = u < 0 ? `scale(${1 + (1 - g.scale) * u * o})` : `scale(${1 - (1 - g.scale) * u * o})`, w = u < 0 ? 1 + (1 - g.opacity) * u * o : 1 - (1 - g.opacity) * u * o, E = `translate3d(${v}) ${y} ${b}`; if (m && g.shadow || !m) { let e = n.querySelector(".swiper-slide-shadow"); if (!e && g.shadow && (e = de("creative", n)), e) { const t = r.shadowPerProgress ? d * (1 / r.limitProgress) : d; e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1) } } const _ = le(0, n); _.style.transform = E, _.style.opacity = w, g.origin && (_.style.transformOrigin = g.origin) } }, setTransition: e => { const i = t.slides.map(e => h(e)); i.forEach(t => { t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow").forEach(t => { t.style.transitionDuration = e + "ms" }) }), ce({ swiper: t, duration: e, transformElements: i, allSlides: !0 }) }, perspective: () => t.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ cardsEffect: { slideShadows: !0, rotate: !0, perSlideRotate: 2, perSlideOffset: 8 } }), ae({ effect: "cards", swiper: t, on: n, setTranslate: () => { const { slides: e, activeIndex: i, rtlTranslate: n } = t, s = t.params.cardsEffect, { startTranslate: r, isTouched: o } = t.touchEventsData, a = n ? -t.translate : t.translate; for (let l = 0; l < e.length; l += 1) { const c = e[l], d = c.progress, u = Math.min(Math.max(d, -4), 4); let p = c.swiperSlideOffset; t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (p -= e[0].swiperSlideOffset); let f = t.params.cssMode ? -p - t.translate : -p, h = 0; const m = -100 * Math.abs(u); let g = 1, v = -s.perSlideRotate * u, y = s.perSlideOffset - .75 * Math.abs(u); const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + l : l, w = (b === i || b === i - 1) && u > 0 && u < 1 && (o || t.params.cssMode) && a < r, E = (b === i || b === i + 1) && u < 0 && u > -1 && (o || t.params.cssMode) && a > r; if (w || E) { const e = (1 - Math.abs((Math.abs(u) - .5) / .5)) ** .5; v += -28 * u * e, g += -.5 * e, y += 96 * e, h = -25 * e * Math.abs(u) + "%" } if (f = u < 0 ? `calc(${f}px ${n ? "-" : "+"} (${y * Math.abs(u)}%))` : u > 0 ? `calc(${f}px ${n ? "-" : "+"} (-${y * Math.abs(u)}%))` : f + "px", !t.isHorizontal()) { const e = h; h = f, f = e } const _ = u < 0 ? "" + (1 + (1 - g) * u) : "" + (1 - (1 - g) * u), x = `\n        translate3d(${f}, ${h}, ${m}px)\n        rotateZ(${s.rotate ? n ? -v : v : 0}deg)\n        scale(${_})\n      `; if (s.slideShadows) { let e = c.querySelector(".swiper-slide-shadow"); e || (e = de("cards", c)), e && (e.style.opacity = Math.min(Math.max((Math.abs(u) - .5) / .5, 0), 1)) } c.style.zIndex = -Math.abs(Math.round(d)) + e.length, le(0, c).style.transform = x } }, setTransition: e => { const i = t.slides.map(e => h(e)); i.forEach(t => { t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow").forEach(t => { t.style.transitionDuration = e + "ms" }) }), ce({ swiper: t, duration: e, transformElements: i }) }, perspective: () => !0, overwriteParams: () => ({ _loopSwapReset: !1, watchSlidesProgress: !0, loopAdditionalSlides: 3, centeredSlides: !0, virtualTranslate: !t.params.cssMode }) }) }]; return J.use(ue), J }();